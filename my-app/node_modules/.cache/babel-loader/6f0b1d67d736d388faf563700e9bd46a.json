{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateMethodGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport { assert, isHexString } from \"../utils/index.js\";\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider, event) {\n  if (event === \"block\") {\n    return new PollingBlockSubscriber(provider);\n  }\n  if (isHexString(event, 32)) {\n    return new PollingTransactionSubscriber(provider, event);\n  }\n  assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"getPollingSubscriber\",\n    info: {\n      event\n    }\n  });\n}\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _provider = /*#__PURE__*/new WeakMap();\nvar _poller = /*#__PURE__*/new WeakMap();\nvar _interval = /*#__PURE__*/new WeakMap();\nvar _blockNumber = /*#__PURE__*/new WeakMap();\nvar _poll = /*#__PURE__*/new WeakSet();\nexport class PollingBlockSubscriber {\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n\n  /**\n   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    _classPrivateMethodInitSpec(this, _poll);\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _poller, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _interval, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _blockNumber, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _provider, provider);\n    _classPrivateFieldSet(this, _poller, null);\n    _classPrivateFieldSet(this, _interval, 4000);\n    _classPrivateFieldSet(this, _blockNumber, -2);\n  }\n  /**\n   *  The polling interval.\n   */\n  get pollingInterval() {\n    return _classPrivateFieldGet(this, _interval);\n  }\n  set pollingInterval(value) {\n    _classPrivateFieldSet(this, _interval, value);\n  }\n  start() {\n    if (_classPrivateFieldGet(this, _poller)) {\n      return;\n    }\n    _classPrivateFieldSet(this, _poller, _classPrivateFieldGet(this, _provider)._setTimeout(_classPrivateMethodGet(this, _poll, _poll2).bind(this), _classPrivateFieldGet(this, _interval)));\n    _classPrivateMethodGet(this, _poll, _poll2).call(this);\n  }\n  stop() {\n    if (!_classPrivateFieldGet(this, _poller)) {\n      return;\n    }\n    _classPrivateFieldGet(this, _provider)._clearTimeout(_classPrivateFieldGet(this, _poller));\n    _classPrivateFieldSet(this, _poller, null);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      _classPrivateFieldSet(this, _blockNumber, -2);\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nasync function _poll2() {\n  try {\n    const blockNumber = await _classPrivateFieldGet(this, _provider).getBlockNumber();\n    // Bootstrap poll to setup our initial block number\n    if (_classPrivateFieldGet(this, _blockNumber) === -2) {\n      _classPrivateFieldSet(this, _blockNumber, blockNumber);\n      return;\n    }\n    // @TODO: Put a cap on the maximum number of events per loop?\n    if (blockNumber !== _classPrivateFieldGet(this, _blockNumber)) {\n      for (let b = _classPrivateFieldGet(this, _blockNumber) + 1; b <= blockNumber; b++) {\n        // We have been stopped\n        if (_classPrivateFieldGet(this, _poller) == null) {\n          return;\n        }\n        await _classPrivateFieldGet(this, _provider).emit(\"block\", b);\n      }\n      _classPrivateFieldSet(this, _blockNumber, blockNumber);\n    }\n  } catch (error) {\n    // @TODO: Minor bump, add an \"error\" event to let subscribers\n    //        know things went awry.\n    //console.log(error);\n  }\n  // We have been stopped\n  if (_classPrivateFieldGet(this, _poller) == null) {\n    return;\n  }\n  _classPrivateFieldSet(this, _poller, _classPrivateFieldGet(this, _provider)._setTimeout(_classPrivateMethodGet(this, _poll, _poll2).bind(this), _classPrivateFieldGet(this, _interval)));\n}\nvar _provider2 = /*#__PURE__*/new WeakMap();\nvar _poll3 = /*#__PURE__*/new WeakMap();\nvar _running = /*#__PURE__*/new WeakMap();\nexport class OnBlockSubscriber {\n  /**\n   *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    _classPrivateFieldInitSpec(this, _provider2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _poll3, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _running, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _provider2, provider);\n    _classPrivateFieldSet(this, _running, false);\n    _classPrivateFieldSet(this, _poll3, blockNumber => {\n      this._poll(blockNumber, _classPrivateFieldGet(this, _provider2));\n    });\n  }\n  /**\n   *  Called on every new block.\n   */\n  async _poll(blockNumber, provider) {\n    throw new Error(\"sub-classes must override this\");\n  }\n  start() {\n    if (_classPrivateFieldGet(this, _running)) {\n      return;\n    }\n    _classPrivateFieldSet(this, _running, true);\n    _classPrivateFieldGet(this, _poll3).call(this, -2);\n    _classPrivateFieldGet(this, _provider2).on(\"block\", _classPrivateFieldGet(this, _poll3));\n  }\n  stop() {\n    if (!_classPrivateFieldGet(this, _running)) {\n      return;\n    }\n    _classPrivateFieldSet(this, _running, false);\n    _classPrivateFieldGet(this, _provider2).off(\"block\", _classPrivateFieldGet(this, _poll3));\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n  }\n  resume() {\n    this.start();\n  }\n}\nvar _tag = /*#__PURE__*/new WeakMap();\nvar _lastBlock = /*#__PURE__*/new WeakMap();\nexport class PollingBlockTagSubscriber extends OnBlockSubscriber {\n  constructor(provider, tag) {\n    super(provider);\n    _classPrivateFieldInitSpec(this, _tag, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _lastBlock, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _tag, tag);\n    _classPrivateFieldSet(this, _lastBlock, -2);\n  }\n  pause(dropWhilePaused) {\n    if (dropWhilePaused) {\n      _classPrivateFieldSet(this, _lastBlock, -2);\n    }\n    super.pause(dropWhilePaused);\n  }\n  async _poll(blockNumber, provider) {\n    const block = await provider.getBlock(_classPrivateFieldGet(this, _tag));\n    if (block == null) {\n      return;\n    }\n    if (_classPrivateFieldGet(this, _lastBlock) === -2) {\n      _classPrivateFieldSet(this, _lastBlock, block.number);\n    } else if (block.number > _classPrivateFieldGet(this, _lastBlock)) {\n      provider.emit(_classPrivateFieldGet(this, _tag), block.number);\n      _classPrivateFieldSet(this, _lastBlock, block.number);\n    }\n  }\n}\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _filter = /*#__PURE__*/new WeakMap();\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n  constructor(provider, filter) {\n    super(provider);\n    _classPrivateFieldInitSpec(this, _filter, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _filter, copy(filter));\n  }\n  async _poll(blockNumber, provider) {\n    throw new Error(\"@TODO\");\n    console.log(_classPrivateFieldGet(this, _filter));\n  }\n}\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _hash = /*#__PURE__*/new WeakMap();\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%hash%%.\n   */\n  constructor(provider, hash) {\n    super(provider);\n    _classPrivateFieldInitSpec(this, _hash, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _hash, hash);\n  }\n  async _poll(blockNumber, provider) {\n    const tx = await provider.getTransactionReceipt(_classPrivateFieldGet(this, _hash));\n    if (tx) {\n      provider.emit(_classPrivateFieldGet(this, _hash), tx);\n    }\n  }\n}\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _provider3 = /*#__PURE__*/new WeakMap();\nvar _filter2 = /*#__PURE__*/new WeakMap();\nvar _poller2 = /*#__PURE__*/new WeakMap();\nvar _running2 = /*#__PURE__*/new WeakMap();\nvar _blockNumber2 = /*#__PURE__*/new WeakMap();\nvar _poll4 = /*#__PURE__*/new WeakSet();\nexport class PollingEventSubscriber {\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%filter%%.\n   */\n  constructor(provider, _filter3) {\n    _classPrivateMethodInitSpec(this, _poll4);\n    _classPrivateFieldInitSpec(this, _provider3, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _filter2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _poller2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _running2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _blockNumber2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _provider3, provider);\n    _classPrivateFieldSet(this, _filter2, copy(_filter3));\n    _classPrivateFieldSet(this, _poller2, _classPrivateMethodGet(this, _poll4, _poll5).bind(this));\n    _classPrivateFieldSet(this, _running2, false);\n    _classPrivateFieldSet(this, _blockNumber2, -2);\n  }\n  start() {\n    if (_classPrivateFieldGet(this, _running2)) {\n      return;\n    }\n    _classPrivateFieldSet(this, _running2, true);\n    if (_classPrivateFieldGet(this, _blockNumber2) === -2) {\n      _classPrivateFieldGet(this, _provider3).getBlockNumber().then(blockNumber => {\n        _classPrivateFieldSet(this, _blockNumber2, blockNumber);\n      });\n    }\n    _classPrivateFieldGet(this, _provider3).on(\"block\", _classPrivateFieldGet(this, _poller2));\n  }\n  stop() {\n    if (!_classPrivateFieldGet(this, _running2)) {\n      return;\n    }\n    _classPrivateFieldSet(this, _running2, false);\n    _classPrivateFieldGet(this, _provider3).off(\"block\", _classPrivateFieldGet(this, _poller2));\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      _classPrivateFieldSet(this, _blockNumber2, -2);\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\nasync function _poll5(blockNumber) {\n  // The initial block hasn't been determined yet\n  if (_classPrivateFieldGet(this, _blockNumber2) === -2) {\n    return;\n  }\n  const filter = copy(_classPrivateFieldGet(this, _filter2));\n  filter.fromBlock = _classPrivateFieldGet(this, _blockNumber2) + 1;\n  filter.toBlock = blockNumber;\n  const logs = await _classPrivateFieldGet(this, _provider3).getLogs(filter);\n  // No logs could just mean the node has not indexed them yet,\n  // so we keep a sliding window of 60 blocks to keep scanning\n  if (logs.length === 0) {\n    if (_classPrivateFieldGet(this, _blockNumber2) < blockNumber - 60) {\n      _classPrivateFieldSet(this, _blockNumber2, blockNumber - 60);\n    }\n    return;\n  }\n  for (const log of logs) {\n    _classPrivateFieldGet(this, _provider3).emit(_classPrivateFieldGet(this, _filter2), log);\n    // Only advance the block number when logs were found to\n    // account for networks (like BNB and Polygon) which may\n    // sacrifice event consistency for block event speed\n    _classPrivateFieldSet(this, _blockNumber2, log.blockNumber);\n  }\n}","map":{"version":3,"sources":["../../src.ts/providers/subscriber-polling.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { assert, isHexString } from \"../utils/index.js\";\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider, event) {\n    if (event === \"block\") {\n        return new PollingBlockSubscriber(provider);\n    }\n    if (isHexString(event, 32)) {\n        return new PollingTransactionSubscriber(provider, event);\n    }\n    assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\", info: { event }\n    });\n}\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingBlockSubscriber {\n    #provider;\n    #poller;\n    #interval;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n        this.#blockNumber = -2;\n    }\n    /**\n     *  The polling interval.\n     */\n    get pollingInterval() { return this.#interval; }\n    set pollingInterval(value) { this.#interval = value; }\n    async #poll() {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n            // @TODO: Put a cap on the maximum number of events per loop?\n            if (blockNumber !== this.#blockNumber) {\n                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n                    // We have been stopped\n                    if (this.#poller == null) {\n                        return;\n                    }\n                    await this.#provider.emit(\"block\", b);\n                }\n                this.#blockNumber = blockNumber;\n            }\n        }\n        catch (error) {\n            // @TODO: Minor bump, add an \"error\" event to let subscribers\n            //        know things went awry.\n            //console.log(error);\n        }\n        // We have been stopped\n        if (this.#poller == null) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n    start() {\n        if (this.#poller) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n    stop() {\n        if (!this.#poller) {\n            return;\n        }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class OnBlockSubscriber {\n    #provider;\n    #poll;\n    #running;\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber) => {\n            this._poll(blockNumber, this.#provider);\n        };\n    }\n    /**\n     *  Called on every new block.\n     */\n    async _poll(blockNumber, provider) {\n        throw new Error(\"sub-classes must override this\");\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poll);\n    }\n    pause(dropWhilePaused) { this.stop(); }\n    resume() { this.start(); }\n}\nexport class PollingBlockTagSubscriber extends OnBlockSubscriber {\n    #tag;\n    #lastBlock;\n    constructor(provider, tag) {\n        super(provider);\n        this.#tag = tag;\n        this.#lastBlock = -2;\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#lastBlock = -2;\n        }\n        super.pause(dropWhilePaused);\n    }\n    async _poll(blockNumber, provider) {\n        const block = await provider.getBlock(this.#tag);\n        if (block == null) {\n            return;\n        }\n        if (this.#lastBlock === -2) {\n            this.#lastBlock = block.number;\n        }\n        else if (block.number > this.#lastBlock) {\n            provider.emit(this.#tag, block.number);\n            this.#lastBlock = block.number;\n        }\n    }\n}\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter;\n    constructor(provider, filter) {\n        super(provider);\n        this.#filter = copy(filter);\n    }\n    async _poll(blockNumber, provider) {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */\n    constructor(provider, hash) {\n        super(provider);\n        this.#hash = hash;\n    }\n    async _poll(blockNumber, provider) {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) {\n            provider.emit(this.#hash, tx);\n        }\n    }\n}\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingEventSubscriber {\n    #provider;\n    #filter;\n    #poller;\n    #running;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */\n    constructor(provider, filter) {\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n    async #poll(blockNumber) {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) {\n            return;\n        }\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n        const logs = await this.#provider.getLogs(filter);\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n        for (const log of logs) {\n            this.#provider.emit(this.#filter, log);\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber) => {\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\n//# sourceMappingURL=subscriber-polling.js.map"]},"metadata":{},"sourceType":"module"}