{"ast":null,"code":"/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nimport { assert, assertArgument } from \"./errors.js\";\nfunction _getBytes(value, name, copy) {\n  if (value instanceof Uint8Array) {\n    if (copy) {\n      return new Uint8Array(value);\n    }\n    return value;\n  }\n  if (typeof value === \"string\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n    const result = new Uint8Array((value.length - 2) / 2);\n    let offset = 2;\n    for (let i = 0; i < result.length; i++) {\n      result[i] = parseInt(value.substring(offset, offset + 2), 16);\n      offset += 2;\n    }\n    return result;\n  }\n  assertArgument(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nexport function getBytes(value, name) {\n  return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nexport function getBytesCopy(value, name) {\n  return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nexport function isHexString(value, length) {\n  if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n  if (typeof length === \"number\" && value.length !== 2 + 2 * length) {\n    return false;\n  }\n  if (length === true && value.length % 2 !== 0) {\n    return false;\n  }\n  return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nexport function isBytesLike(value) {\n  return isHexString(value, true) || value instanceof Uint8Array;\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nexport function hexlify(data) {\n  const bytes = getBytes(data);\n  let result = \"0x\";\n  for (let i = 0; i < bytes.length; i++) {\n    const v = bytes[i];\n    result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n  }\n  return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nexport function concat(datas) {\n  return \"0x\" + datas.map(d => hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nexport function dataLength(data) {\n  if (isHexString(data, true)) {\n    return (data.length - 2) / 2;\n  }\n  return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nexport function dataSlice(data, start, end) {\n  const bytes = getBytes(data);\n  if (end != null && end > bytes.length) {\n    assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n      buffer: bytes,\n      length: bytes.length,\n      offset: end\n    });\n  }\n  return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nexport function stripZerosLeft(data) {\n  let bytes = hexlify(data).substring(2);\n  while (bytes.startsWith(\"00\")) {\n    bytes = bytes.substring(2);\n  }\n  return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n  const bytes = getBytes(data);\n  assert(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n    buffer: new Uint8Array(bytes),\n    length: length,\n    offset: length + 1\n  });\n  const result = new Uint8Array(length);\n  result.fill(0);\n  if (left) {\n    result.set(bytes, length - bytes.length);\n  } else {\n    result.set(bytes, 0);\n  }\n  return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nexport function zeroPadValue(data, length) {\n  return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nexport function zeroPadBytes(data, length) {\n  return zeroPad(data, length, false);\n}","map":{"version":3,"sources":["../../src.ts/utils/data.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nimport { assert, assertArgument } from \"./errors.js\";\nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof (value) === \"string\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    assertArgument(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nexport function getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nexport function getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nexport function isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof (length) === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && (value.length % 2) !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nexport function isBytesLike(value) {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nexport function hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nexport function concat(datas) {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nexport function dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nexport function dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nexport function stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) {\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    assert(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    }\n    else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nexport function zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nexport function zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n}\n//# sourceMappingURL=data.js.map"]},"metadata":{},"sourceType":"module"}