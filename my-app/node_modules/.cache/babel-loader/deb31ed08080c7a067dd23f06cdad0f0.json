{"ast":null,"code":"import { assert } from \"../utils/index.js\";\nimport { AnkrProvider } from \"./provider-ankr.js\";\nimport { AlchemyProvider } from \"./provider-alchemy.js\";\nimport { CloudflareProvider } from \"./provider-cloudflare.js\";\nimport { EtherscanProvider } from \"./provider-etherscan.js\";\nimport { InfuraProvider } from \"./provider-infura.js\";\n//import { PocketProvider } from \"./provider-pocket.js\";\nimport { QuickNodeProvider } from \"./provider-quicknode.js\";\nimport { FallbackProvider } from \"./provider-fallback.js\";\nimport { JsonRpcProvider } from \"./provider-jsonrpc.js\";\nimport { Network } from \"./network.js\";\nimport { WebSocketProvider } from \"./provider-websocket.js\";\nfunction isWebSocketLike(value) {\n  return value && typeof value.send === \"function\" && typeof value.close === \"function\";\n}\nconst Testnets = \"goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt\".split(\" \");\n/**\n *  Returns a default provider for %%network%%.\n *\n *  If %%network%% is a [[WebSocketLike]] or string that begins with\n *  ``\"ws:\"`` or ``\"wss:\"``, a [[WebSocketProvider]] is returned backed\n *  by that WebSocket or URL.\n *\n *  If %%network%% is a string that begins with ``\"HTTP:\"`` or ``\"HTTPS:\"``,\n *  a [[JsonRpcProvider]] is returned connected to that URL.\n *\n *  Otherwise, a default provider is created backed by well-known public\n *  Web3 backends (such as [[link-infura]]) using community-provided API\n *  keys.\n *\n *  The %%options%% allows specifying custom API keys per backend (setting\n *  an API key to ``\"-\"`` will omit that provider) and ``options.exclusive``\n *  can be set to either a backend name or and array of backend names, which\n *  will whitelist **only** those backends.\n *\n *  Current backend strings supported are:\n *  - ``\"alchemy\"``\n *  - ``\"ankr\"``\n *  - ``\"cloudflare\"``\n *  - ``\"etherscan\"``\n *  - ``\"infura\"``\n *  - ``\"publicPolygon\"``\n *  - ``\"quicknode\"``\n *\n *  @example:\n *    // Connect to a local Geth node\n *    provider = getDefaultProvider(\"http://localhost:8545/\");\n *\n *    // Connect to Ethereum mainnet with any current and future\n *    // third-party services available\n *    provider = getDefaultProvider(\"mainnet\");\n *\n *    // Connect to Polygon, but only allow Etherscan and\n *    // INFURA and use \"MY_API_KEY\" in calls to Etherscan.\n *    provider = getDefaultProvider(\"matic\", {\n *      etherscan: \"MY_API_KEY\",\n *      exclusive: [ \"etherscan\", \"infura\" ]\n *    });\n */\nexport function getDefaultProvider(network, options) {\n  if (options == null) {\n    options = {};\n  }\n  const allowService = name => {\n    if (options[name] === \"-\") {\n      return false;\n    }\n    if (typeof options.exclusive === \"string\") {\n      return name === options.exclusive;\n    }\n    if (Array.isArray(options.exclusive)) {\n      return options.exclusive.indexOf(name) !== -1;\n    }\n    return true;\n  };\n  if (typeof network === \"string\" && network.match(/^https?:/)) {\n    return new JsonRpcProvider(network);\n  }\n  if (typeof network === \"string\" && network.match(/^wss?:/) || isWebSocketLike(network)) {\n    return new WebSocketProvider(network);\n  }\n  // Get the network and name, if possible\n  let staticNetwork = null;\n  try {\n    staticNetwork = Network.from(network);\n  } catch (error) {}\n  const providers = [];\n  if (allowService(\"publicPolygon\") && staticNetwork) {\n    if (staticNetwork.name === \"matic\") {\n      providers.push(new JsonRpcProvider(\"https:/\\/polygon-rpc.com/\", staticNetwork, {\n        staticNetwork\n      }));\n    }\n  }\n  if (allowService(\"alchemy\")) {\n    try {\n      providers.push(new AlchemyProvider(network, options.alchemy));\n    } catch (error) {}\n  }\n  if (allowService(\"ankr\") && options.ankr != null) {\n    try {\n      providers.push(new AnkrProvider(network, options.ankr));\n    } catch (error) {}\n  }\n  if (allowService(\"cloudflare\")) {\n    try {\n      providers.push(new CloudflareProvider(network));\n    } catch (error) {}\n  }\n  if (allowService(\"etherscan\")) {\n    try {\n      providers.push(new EtherscanProvider(network, options.etherscan));\n    } catch (error) {}\n  }\n  if (allowService(\"infura\")) {\n    try {\n      let projectId = options.infura;\n      let projectSecret = undefined;\n      if (typeof projectId === \"object\") {\n        projectSecret = projectId.projectSecret;\n        projectId = projectId.projectId;\n      }\n      providers.push(new InfuraProvider(network, projectId, projectSecret));\n    } catch (error) {}\n  }\n  /*\n      if (options.pocket !== \"-\") {\n          try {\n              let appId = options.pocket;\n              let secretKey: undefined | string = undefined;\n              let loadBalancer: undefined | boolean = undefined;\n              if (typeof(appId) === \"object\") {\n                  loadBalancer = !!appId.loadBalancer;\n                  secretKey = appId.secretKey;\n                  appId = appId.appId;\n              }\n              providers.push(new PocketProvider(network, appId, secretKey, loadBalancer));\n          } catch (error) { console.log(error); }\n      }\n  */\n  if (allowService(\"quicknode\")) {\n    try {\n      let token = options.quicknode;\n      providers.push(new QuickNodeProvider(network, token));\n    } catch (error) {}\n  }\n  assert(providers.length, \"unsupported default network\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"getDefaultProvider\"\n  });\n  // No need for a FallbackProvider\n  if (providers.length === 1) {\n    return providers[0];\n  }\n  // We use the floor because public third-party providers can be unreliable,\n  // so a low number of providers with a large quorum will fail too often\n  let quorum = Math.floor(providers.length / 2);\n  if (quorum > 2) {\n    quorum = 2;\n  }\n  // Testnets don't need as strong a security gaurantee and speed is\n  // more useful during testing\n  if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {\n    quorum = 1;\n  }\n  // Provided override qorum takes priority\n  if (options && options.quorum) {\n    quorum = options.quorum;\n  }\n  return new FallbackProvider(providers, undefined, {\n    quorum\n  });\n}","map":{"version":3,"sources":["../../src.ts/providers/default-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { assert } from \"../utils/index.js\";\nimport { AnkrProvider } from \"./provider-ankr.js\";\nimport { AlchemyProvider } from \"./provider-alchemy.js\";\nimport { CloudflareProvider } from \"./provider-cloudflare.js\";\nimport { EtherscanProvider } from \"./provider-etherscan.js\";\nimport { InfuraProvider } from \"./provider-infura.js\";\n//import { PocketProvider } from \"./provider-pocket.js\";\nimport { QuickNodeProvider } from \"./provider-quicknode.js\";\nimport { FallbackProvider } from \"./provider-fallback.js\";\nimport { JsonRpcProvider } from \"./provider-jsonrpc.js\";\nimport { Network } from \"./network.js\";\nimport { WebSocketProvider } from \"./provider-websocket.js\";\nfunction isWebSocketLike(value) {\n    return (value && typeof (value.send) === \"function\" &&\n        typeof (value.close) === \"function\");\n}\nconst Testnets = \"goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt\".split(\" \");\n/**\n *  Returns a default provider for %%network%%.\n *\n *  If %%network%% is a [[WebSocketLike]] or string that begins with\n *  ``\"ws:\"`` or ``\"wss:\"``, a [[WebSocketProvider]] is returned backed\n *  by that WebSocket or URL.\n *\n *  If %%network%% is a string that begins with ``\"HTTP:\"`` or ``\"HTTPS:\"``,\n *  a [[JsonRpcProvider]] is returned connected to that URL.\n *\n *  Otherwise, a default provider is created backed by well-known public\n *  Web3 backends (such as [[link-infura]]) using community-provided API\n *  keys.\n *\n *  The %%options%% allows specifying custom API keys per backend (setting\n *  an API key to ``\"-\"`` will omit that provider) and ``options.exclusive``\n *  can be set to either a backend name or and array of backend names, which\n *  will whitelist **only** those backends.\n *\n *  Current backend strings supported are:\n *  - ``\"alchemy\"``\n *  - ``\"ankr\"``\n *  - ``\"cloudflare\"``\n *  - ``\"etherscan\"``\n *  - ``\"infura\"``\n *  - ``\"publicPolygon\"``\n *  - ``\"quicknode\"``\n *\n *  @example:\n *    // Connect to a local Geth node\n *    provider = getDefaultProvider(\"http://localhost:8545/\");\n *\n *    // Connect to Ethereum mainnet with any current and future\n *    // third-party services available\n *    provider = getDefaultProvider(\"mainnet\");\n *\n *    // Connect to Polygon, but only allow Etherscan and\n *    // INFURA and use \"MY_API_KEY\" in calls to Etherscan.\n *    provider = getDefaultProvider(\"matic\", {\n *      etherscan: \"MY_API_KEY\",\n *      exclusive: [ \"etherscan\", \"infura\" ]\n *    });\n */\nexport function getDefaultProvider(network, options) {\n    if (options == null) {\n        options = {};\n    }\n    const allowService = (name) => {\n        if (options[name] === \"-\") {\n            return false;\n        }\n        if (typeof (options.exclusive) === \"string\") {\n            return (name === options.exclusive);\n        }\n        if (Array.isArray(options.exclusive)) {\n            return (options.exclusive.indexOf(name) !== -1);\n        }\n        return true;\n    };\n    if (typeof (network) === \"string\" && network.match(/^https?:/)) {\n        return new JsonRpcProvider(network);\n    }\n    if (typeof (network) === \"string\" && network.match(/^wss?:/) || isWebSocketLike(network)) {\n        return new WebSocketProvider(network);\n    }\n    // Get the network and name, if possible\n    let staticNetwork = null;\n    try {\n        staticNetwork = Network.from(network);\n    }\n    catch (error) { }\n    const providers = [];\n    if (allowService(\"publicPolygon\") && staticNetwork) {\n        if (staticNetwork.name === \"matic\") {\n            providers.push(new JsonRpcProvider(\"https:/\\/polygon-rpc.com/\", staticNetwork, { staticNetwork }));\n        }\n    }\n    if (allowService(\"alchemy\")) {\n        try {\n            providers.push(new AlchemyProvider(network, options.alchemy));\n        }\n        catch (error) { }\n    }\n    if (allowService(\"ankr\") && options.ankr != null) {\n        try {\n            providers.push(new AnkrProvider(network, options.ankr));\n        }\n        catch (error) { }\n    }\n    if (allowService(\"cloudflare\")) {\n        try {\n            providers.push(new CloudflareProvider(network));\n        }\n        catch (error) { }\n    }\n    if (allowService(\"etherscan\")) {\n        try {\n            providers.push(new EtherscanProvider(network, options.etherscan));\n        }\n        catch (error) { }\n    }\n    if (allowService(\"infura\")) {\n        try {\n            let projectId = options.infura;\n            let projectSecret = undefined;\n            if (typeof (projectId) === \"object\") {\n                projectSecret = projectId.projectSecret;\n                projectId = projectId.projectId;\n            }\n            providers.push(new InfuraProvider(network, projectId, projectSecret));\n        }\n        catch (error) { }\n    }\n    /*\n        if (options.pocket !== \"-\") {\n            try {\n                let appId = options.pocket;\n                let secretKey: undefined | string = undefined;\n                let loadBalancer: undefined | boolean = undefined;\n                if (typeof(appId) === \"object\") {\n                    loadBalancer = !!appId.loadBalancer;\n                    secretKey = appId.secretKey;\n                    appId = appId.appId;\n                }\n                providers.push(new PocketProvider(network, appId, secretKey, loadBalancer));\n            } catch (error) { console.log(error); }\n        }\n    */\n    if (allowService(\"quicknode\")) {\n        try {\n            let token = options.quicknode;\n            providers.push(new QuickNodeProvider(network, token));\n        }\n        catch (error) { }\n    }\n    assert(providers.length, \"unsupported default network\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getDefaultProvider\"\n    });\n    // No need for a FallbackProvider\n    if (providers.length === 1) {\n        return providers[0];\n    }\n    // We use the floor because public third-party providers can be unreliable,\n    // so a low number of providers with a large quorum will fail too often\n    let quorum = Math.floor(providers.length / 2);\n    if (quorum > 2) {\n        quorum = 2;\n    }\n    // Testnets don't need as strong a security gaurantee and speed is\n    // more useful during testing\n    if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {\n        quorum = 1;\n    }\n    // Provided override qorum takes priority\n    if (options && options.quorum) {\n        quorum = options.quorum;\n    }\n    return new FallbackProvider(providers, undefined, { quorum });\n}\n//# sourceMappingURL=default-provider.js.map"]},"metadata":{},"sourceType":"module"}