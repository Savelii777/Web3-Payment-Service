{"ast":null,"code":"// Cipher Feedback\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;\nimport { ModeOfOperation } from \"./mode.js\";\nexport class CFB extends ModeOfOperation {\n  constructor(key, iv, segmentSize = 8) {\n    super(\"CFB\", key, CFB);\n    _CFB_instances.add(this);\n    _CFB_iv.set(this, void 0);\n    _CFB_shiftRegister.set(this, void 0);\n    // This library currently only handles byte-aligned segmentSize\n    if (!Number.isInteger(segmentSize) || segmentSize % 8) {\n      throw new TypeError(\"invalid segmentSize\");\n    }\n    Object.defineProperties(this, {\n      segmentSize: {\n        enumerable: true,\n        value: segmentSize\n      }\n    });\n    if (iv) {\n      if (iv.length % 16) {\n        throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n      }\n      __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(iv), \"f\");\n    } else {\n      __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(16), \"f\");\n    }\n    __classPrivateFieldSet(this, _CFB_shiftRegister, this.iv, \"f\");\n  }\n  get iv() {\n    return new Uint8Array(__classPrivateFieldGet(this, _CFB_iv, \"f\"));\n  }\n  encrypt(plaintext) {\n    if (8 * plaintext.length % this.segmentSize) {\n      throw new TypeError(\"invalid plaintext size (must be multiple of segmentSize bytes)\");\n    }\n    const segmentSize = this.segmentSize / 8;\n    const ciphertext = new Uint8Array(plaintext);\n    for (let i = 0; i < ciphertext.length; i += segmentSize) {\n      const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\n      for (let j = 0; j < segmentSize; j++) {\n        ciphertext[i + j] ^= xorSegment[j];\n      }\n      __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\n    }\n    return ciphertext;\n  }\n  decrypt(ciphertext) {\n    if (8 * ciphertext.length % this.segmentSize) {\n      throw new TypeError(\"invalid ciphertext size (must be multiple of segmentSize bytes)\");\n    }\n    const segmentSize = this.segmentSize / 8;\n    const plaintext = new Uint8Array(ciphertext);\n    for (let i = 0; i < plaintext.length; i += segmentSize) {\n      const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\n      for (let j = 0; j < segmentSize; j++) {\n        plaintext[i + j] ^= xorSegment[j];\n      }\n      __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\n    }\n    return plaintext;\n  }\n}\n_CFB_iv = new WeakMap(), _CFB_shiftRegister = new WeakMap(), _CFB_instances = new WeakSet(), _CFB_shift = function _CFB_shift(data) {\n  const segmentSize = this.segmentSize / 8;\n  // Shift the register\n  __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").subarray(segmentSize));\n  __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(data.subarray(0, segmentSize), 16 - segmentSize);\n};","map":{"version":3,"sources":["../src.ts/mode-cfb.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// Cipher Feedback\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;\nimport { ModeOfOperation } from \"./mode.js\";\nexport class CFB extends ModeOfOperation {\n    constructor(key, iv, segmentSize = 8) {\n        super(\"CFB\", key, CFB);\n        _CFB_instances.add(this);\n        _CFB_iv.set(this, void 0);\n        _CFB_shiftRegister.set(this, void 0);\n        // This library currently only handles byte-aligned segmentSize\n        if (!Number.isInteger(segmentSize) || (segmentSize % 8)) {\n            throw new TypeError(\"invalid segmentSize\");\n        }\n        Object.defineProperties(this, {\n            segmentSize: { enumerable: true, value: segmentSize }\n        });\n        if (iv) {\n            if (iv.length % 16) {\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n            }\n            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(iv), \"f\");\n        }\n        else {\n            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(16), \"f\");\n        }\n        __classPrivateFieldSet(this, _CFB_shiftRegister, this.iv, \"f\");\n    }\n    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _CFB_iv, \"f\")); }\n    encrypt(plaintext) {\n        if (8 * plaintext.length % this.segmentSize) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of segmentSize bytes)\");\n        }\n        const segmentSize = this.segmentSize / 8;\n        const ciphertext = new Uint8Array(plaintext);\n        for (let i = 0; i < ciphertext.length; i += segmentSize) {\n            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\n            for (let j = 0; j < segmentSize; j++) {\n                ciphertext[i + j] ^= xorSegment[j];\n            }\n            __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\n        }\n        return ciphertext;\n    }\n    decrypt(ciphertext) {\n        if (8 * ciphertext.length % this.segmentSize) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of segmentSize bytes)\");\n        }\n        const segmentSize = this.segmentSize / 8;\n        const plaintext = new Uint8Array(ciphertext);\n        for (let i = 0; i < plaintext.length; i += segmentSize) {\n            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\n            for (let j = 0; j < segmentSize; j++) {\n                plaintext[i + j] ^= xorSegment[j];\n            }\n            __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\n        }\n        return plaintext;\n    }\n}\n_CFB_iv = new WeakMap(), _CFB_shiftRegister = new WeakMap(), _CFB_instances = new WeakSet(), _CFB_shift = function _CFB_shift(data) {\n    const segmentSize = this.segmentSize / 8;\n    // Shift the register\n    __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").subarray(segmentSize));\n    __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(data.subarray(0, segmentSize), 16 - segmentSize);\n};\n//# sourceMappingURL=mode-cfb.js.map"]},"metadata":{},"sourceType":"module"}