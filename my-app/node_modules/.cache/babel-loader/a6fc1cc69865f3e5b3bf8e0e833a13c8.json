{"ast":null,"code":"/**\n *  ENS is a service which allows easy-to-remember names to map to\n *  network addresses.\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */\nimport { getAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { dnsEncode, namehash } from \"../hash/index.js\";\nimport { hexlify, isHexString, toBeHex, defineProperties, encodeBase58, assert, assertArgument, isError, FetchRequest } from \"../utils/index.js\";\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n  if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n    link = link.substring(12);\n  } else if (link.match(/^ipfs:\\/\\//i)) {\n    link = link.substring(7);\n  } else {\n    assertArgument(false, \"unsupported IPFS format\", \"link\", link);\n  }\n  return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\n;\n;\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */\nexport class MulticoinProviderPlugin {\n  /**\n   *  The name.\n   */\n  name;\n  /**\n   *  Creates a new **MulticoinProviderPluing** for %%name%%.\n   */\n  constructor(name) {\n    defineProperties(this, {\n      name\n    });\n  }\n  connect(proivder) {\n    return this;\n  }\n  /**\n   *  Returns ``true`` if %%coinType%% is supported by this plugin.\n   */\n  supportsCoinType(coinType) {\n    return false;\n  }\n  /**\n   *  Resovles to the encoded %%address%% for %%coinType%%.\n   */\n  async encodeAddress(coinType, address) {\n    throw new Error(\"unsupported coin\");\n  }\n  /**\n   *  Resovles to the decoded %%data%% for %%coinType%%.\n   */\n  async decodeAddress(coinType, data) {\n    throw new Error(\"unsupported coin\");\n  }\n}\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n/**\n *  A **BasicMulticoinProviderPlugin** provides service for common\n *  coin types, which do not require additional libraries to encode or\n *  decode.\n */\nexport class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n  /**\n   *  Creates a new **BasicMulticoinProviderPlugin**.\n   */\n  constructor() {\n    super(BasicMulticoinPluginId);\n  }\n}\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [new RegExp(\"^(https):/\\/(.*)$\", \"i\"), new RegExp(\"^(data):(.*)$\", \"i\"), matcherIpfs, new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\")];\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */\nexport class EnsResolver {\n  /**\n   *  The connected provider.\n   */\n  provider;\n  /**\n   *  The address of the resolver.\n   */\n  address;\n  /**\n   *  The name this resolver was resolved against.\n   */\n  name;\n  // For EIP-2544 names, the ancestor that provided the resolver\n  #supports2544;\n  #resolver;\n  constructor(provider, address, name) {\n    defineProperties(this, {\n      provider,\n      address,\n      name\n    });\n    this.#supports2544 = null;\n    this.#resolver = new Contract(address, [\"function supportsInterface(bytes4) view returns (bool)\", \"function resolve(bytes, bytes) view returns (bytes)\", \"function addr(bytes32) view returns (address)\", \"function addr(bytes32, uint) view returns (bytes)\", \"function text(bytes32, string) view returns (string)\", \"function contenthash(bytes32) view returns (bytes)\"], provider);\n  }\n  /**\n   *  Resolves to true if the resolver supports wildcard resolution.\n   */\n  async supportsWildcard() {\n    if (this.#supports2544 == null) {\n      this.#supports2544 = (async () => {\n        try {\n          return await this.#resolver.supportsInterface(\"0x9061b923\");\n        } catch (error) {\n          // Wildcard resolvers must understand supportsInterface\n          // and return true.\n          if (isError(error, \"CALL_EXCEPTION\")) {\n            return false;\n          }\n          // Let future attempts try again...\n          this.#supports2544 = null;\n          throw error;\n        }\n      })();\n    }\n    return await this.#supports2544;\n  }\n  async #fetch(funcName, params) {\n    params = (params || []).slice();\n    const iface = this.#resolver.interface;\n    // The first parameters is always the nodehash\n    params.unshift(namehash(this.name));\n    let fragment = null;\n    if (await this.supportsWildcard()) {\n      fragment = iface.getFunction(funcName);\n      assert(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n        info: {\n          funcName\n        }\n      });\n      params = [dnsEncode(this.name), iface.encodeFunctionData(fragment, params)];\n      funcName = \"resolve(bytes,bytes)\";\n    }\n    params.push({\n      enableCcipRead: true\n    });\n    try {\n      const result = await this.#resolver[funcName](...params);\n      if (fragment) {\n        return iface.decodeFunctionResult(fragment, result)[0];\n      }\n      return result;\n    } catch (error) {\n      if (!isError(error, \"CALL_EXCEPTION\")) {\n        throw error;\n      }\n    }\n    return null;\n  }\n  /**\n   *  Resolves to the address for %%coinType%% or null if the\n   *  provided %%coinType%% has not been configured.\n   */\n  async getAddress(coinType) {\n    if (coinType == null) {\n      coinType = 60;\n    }\n    if (coinType === 60) {\n      try {\n        const result = await this.#fetch(\"addr(bytes32)\");\n        // No address\n        if (result == null || result === ZeroAddress) {\n          return null;\n        }\n        return result;\n      } catch (error) {\n        if (isError(error, \"CALL_EXCEPTION\")) {\n          return null;\n        }\n        throw error;\n      }\n    }\n    // Try decoding its EVM canonical chain as an EVM chain address first\n    if (coinType >= 0 && coinType < 0x80000000) {\n      let ethCoinType = coinType + 0x80000000;\n      const data = await this.#fetch(\"addr(bytes32,uint)\", [ethCoinType]);\n      if (isHexString(data, 20)) {\n        return getAddress(data);\n      }\n    }\n    let coinPlugin = null;\n    for (const plugin of this.provider.plugins) {\n      if (!(plugin instanceof MulticoinProviderPlugin)) {\n        continue;\n      }\n      if (plugin.supportsCoinType(coinType)) {\n        coinPlugin = plugin;\n        break;\n      }\n    }\n    if (coinPlugin == null) {\n      return null;\n    }\n    // keccak256(\"addr(bytes32,uint256\")\n    const data = await this.#fetch(\"addr(bytes32,uint)\", [coinType]);\n    // No address\n    if (data == null || data === \"0x\") {\n      return null;\n    }\n    // Compute the address\n    const address = await coinPlugin.decodeAddress(coinType, data);\n    if (address != null) {\n      return address;\n    }\n    assert(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\n      operation: `getAddress(${coinType})`,\n      info: {\n        coinType,\n        data\n      }\n    });\n  }\n  /**\n   *  Resolves to the EIP-634 text record for %%key%%, or ``null``\n   *  if unconfigured.\n   */\n  async getText(key) {\n    const data = await this.#fetch(\"text(bytes32,string)\", [key]);\n    if (data == null || data === \"0x\") {\n      return null;\n    }\n    return data;\n  }\n  /**\n   *  Rsolves to the content-hash or ``null`` if unconfigured.\n   */\n  async getContentHash() {\n    // keccak256(\"contenthash()\")\n    const data = await this.#fetch(\"contenthash(bytes32)\");\n    // No contenthash\n    if (data == null || data === \"0x\") {\n      return null;\n    }\n    // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n    const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n    if (ipfs) {\n      const scheme = ipfs[1] === \"e3010170\" ? \"ipfs\" : \"ipns\";\n      const length = parseInt(ipfs[4], 16);\n      if (ipfs[5].length === length * 2) {\n        return `${scheme}:/\\/${encodeBase58(\"0x\" + ipfs[2])}`;\n      }\n    }\n    // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n    const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n    if (swarm && swarm[1].length === 64) {\n      return `bzz:/\\/${swarm[1]}`;\n    }\n    assert(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\n      operation: \"getContentHash()\",\n      info: {\n        data\n      }\n    });\n  }\n  /**\n   *  Resolves to the avatar url or ``null`` if the avatar is either\n   *  unconfigured or incorrectly configured (e.g. references an NFT\n   *  not owned by the address).\n   *\n   *  If diagnosing issues with configurations, the [[_getAvatar]]\n   *  method may be useful.\n   */\n  async getAvatar() {\n    const avatar = await this._getAvatar();\n    return avatar.url;\n  }\n  /**\n   *  When resolving an avatar, there are many steps involved, such\n   *  fetching metadata and possibly validating ownership of an\n   *  NFT.\n   *\n   *  This method can be used to examine each step and the value it\n   *  was working from.\n   */\n  async _getAvatar() {\n    const linkage = [{\n      type: \"name\",\n      value: this.name\n    }];\n    try {\n      // test data for ricmoo.eth\n      //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n      const avatar = await this.getText(\"avatar\");\n      if (avatar == null) {\n        linkage.push({\n          type: \"!avatar\",\n          value: \"\"\n        });\n        return {\n          url: null,\n          linkage\n        };\n      }\n      linkage.push({\n        type: \"avatar\",\n        value: avatar\n      });\n      for (let i = 0; i < matchers.length; i++) {\n        const match = avatar.match(matchers[i]);\n        if (match == null) {\n          continue;\n        }\n        const scheme = match[1].toLowerCase();\n        switch (scheme) {\n          case \"https\":\n          case \"data\":\n            linkage.push({\n              type: \"url\",\n              value: avatar\n            });\n            return {\n              linkage,\n              url: avatar\n            };\n          case \"ipfs\":\n            {\n              const url = getIpfsLink(avatar);\n              linkage.push({\n                type: \"ipfs\",\n                value: avatar\n              });\n              linkage.push({\n                type: \"url\",\n                value: url\n              });\n              return {\n                linkage,\n                url\n              };\n            }\n          case \"erc721\":\n          case \"erc1155\":\n            {\n              // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n              const selector = scheme === \"erc721\" ? \"tokenURI(uint256)\" : \"uri(uint256)\";\n              linkage.push({\n                type: scheme,\n                value: avatar\n              });\n              // The owner of this name\n              const owner = await this.getAddress();\n              if (owner == null) {\n                linkage.push({\n                  type: \"!owner\",\n                  value: \"\"\n                });\n                return {\n                  url: null,\n                  linkage\n                };\n              }\n              const comps = (match[2] || \"\").split(\"/\");\n              if (comps.length !== 2) {\n                linkage.push({\n                  type: `!${scheme}caip`,\n                  value: match[2] || \"\"\n                });\n                return {\n                  url: null,\n                  linkage\n                };\n              }\n              const tokenId = comps[1];\n              const contract = new Contract(comps[0], [\n              // ERC-721\n              \"function tokenURI(uint) view returns (string)\", \"function ownerOf(uint) view returns (address)\",\n              // ERC-1155\n              \"function uri(uint) view returns (string)\", \"function balanceOf(address, uint256) view returns (uint)\"], this.provider);\n              // Check that this account owns the token\n              if (scheme === \"erc721\") {\n                const tokenOwner = await contract.ownerOf(tokenId);\n                if (owner !== tokenOwner) {\n                  linkage.push({\n                    type: \"!owner\",\n                    value: tokenOwner\n                  });\n                  return {\n                    url: null,\n                    linkage\n                  };\n                }\n                linkage.push({\n                  type: \"owner\",\n                  value: tokenOwner\n                });\n              } else if (scheme === \"erc1155\") {\n                const balance = await contract.balanceOf(owner, tokenId);\n                if (!balance) {\n                  linkage.push({\n                    type: \"!balance\",\n                    value: \"0\"\n                  });\n                  return {\n                    url: null,\n                    linkage\n                  };\n                }\n                linkage.push({\n                  type: \"balance\",\n                  value: balance.toString()\n                });\n              }\n              // Call the token contract for the metadata URL\n              let metadataUrl = await contract[selector](tokenId);\n              if (metadataUrl == null || metadataUrl === \"0x\") {\n                linkage.push({\n                  type: \"!metadata-url\",\n                  value: \"\"\n                });\n                return {\n                  url: null,\n                  linkage\n                };\n              }\n              linkage.push({\n                type: \"metadata-url-base\",\n                value: metadataUrl\n              });\n              // ERC-1155 allows a generic {id} in the URL\n              if (scheme === \"erc1155\") {\n                metadataUrl = metadataUrl.replace(\"{id}\", toBeHex(tokenId, 32).substring(2));\n                linkage.push({\n                  type: \"metadata-url-expanded\",\n                  value: metadataUrl\n                });\n              }\n              // Transform IPFS metadata links\n              if (metadataUrl.match(/^ipfs:/i)) {\n                metadataUrl = getIpfsLink(metadataUrl);\n              }\n              linkage.push({\n                type: \"metadata-url\",\n                value: metadataUrl\n              });\n              // Get the token metadata\n              let metadata = {};\n              const response = await new FetchRequest(metadataUrl).send();\n              response.assertOk();\n              try {\n                metadata = response.bodyJson;\n              } catch (error) {\n                try {\n                  linkage.push({\n                    type: \"!metadata\",\n                    value: response.bodyText\n                  });\n                } catch (error) {\n                  const bytes = response.body;\n                  if (bytes) {\n                    linkage.push({\n                      type: \"!metadata\",\n                      value: hexlify(bytes)\n                    });\n                  }\n                  return {\n                    url: null,\n                    linkage\n                  };\n                }\n                return {\n                  url: null,\n                  linkage\n                };\n              }\n              if (!metadata) {\n                linkage.push({\n                  type: \"!metadata\",\n                  value: \"\"\n                });\n                return {\n                  url: null,\n                  linkage\n                };\n              }\n              linkage.push({\n                type: \"metadata\",\n                value: JSON.stringify(metadata)\n              });\n              // Pull the image URL out\n              let imageUrl = metadata.image;\n              if (typeof imageUrl !== \"string\") {\n                linkage.push({\n                  type: \"!imageUrl\",\n                  value: \"\"\n                });\n                return {\n                  url: null,\n                  linkage\n                };\n              }\n              if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                // Allow\n              } else {\n                // Transform IPFS link to gateway\n                const ipfs = imageUrl.match(matcherIpfs);\n                if (ipfs == null) {\n                  linkage.push({\n                    type: \"!imageUrl-ipfs\",\n                    value: imageUrl\n                  });\n                  return {\n                    url: null,\n                    linkage\n                  };\n                }\n                linkage.push({\n                  type: \"imageUrl-ipfs\",\n                  value: imageUrl\n                });\n                imageUrl = getIpfsLink(imageUrl);\n              }\n              linkage.push({\n                type: \"url\",\n                value: imageUrl\n              });\n              return {\n                linkage,\n                url: imageUrl\n              };\n            }\n        }\n      }\n    } catch (error) {}\n    return {\n      linkage,\n      url: null\n    };\n  }\n  static async getEnsAddress(provider) {\n    const network = await provider.getNetwork();\n    const ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\");\n    // No ENS...\n    assert(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"getEnsAddress\",\n      info: {\n        network\n      }\n    });\n    return ensPlugin.address;\n  }\n  static async #getResolver(provider, name) {\n    const ensAddr = await EnsResolver.getEnsAddress(provider);\n    try {\n      const contract = new Contract(ensAddr, [\"function resolver(bytes32) view returns (address)\"], provider);\n      const addr = await contract.resolver(namehash(name), {\n        enableCcipRead: true\n      });\n      if (addr === ZeroAddress) {\n        return null;\n      }\n      return addr;\n    } catch (error) {\n      // ENS registry cannot throw errors on resolver(bytes32),\n      // so probably a link error\n      throw error;\n    }\n    return null;\n  }\n  /**\n   *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n   *  ``null`` if unconfigured.\n   */\n  static async fromName(provider, name) {\n    let currentName = name;\n    while (true) {\n      if (currentName === \"\" || currentName === \".\") {\n        return null;\n      }\n      // Optimization since the eth node cannot change and does\n      // not have a wildcard resolver\n      if (name !== \"eth\" && currentName === \"eth\") {\n        return null;\n      }\n      // Check the current node for a resolver\n      const addr = await EnsResolver.#getResolver(provider, currentName);\n      // Found a resolver!\n      if (addr != null) {\n        const resolver = new EnsResolver(provider, addr, name);\n        // Legacy resolver found, using EIP-2544 so it isn't safe to use\n        if (currentName !== name && !(await resolver.supportsWildcard())) {\n          return null;\n        }\n        return resolver;\n      }\n      // Get the parent node\n      currentName = currentName.split(\".\").slice(1).join(\".\");\n    }\n  }\n}","map":{"version":3,"sources":["../../src.ts/providers/ens-resolver.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n *  ENS is a service which allows easy-to-remember names to map to\n *  network addresses.\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */\nimport { getAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { dnsEncode, namehash } from \"../hash/index.js\";\nimport { hexlify, isHexString, toBeHex, defineProperties, encodeBase58, assert, assertArgument, isError, FetchRequest } from \"../utils/index.js\";\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    }\n    else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    }\n    else {\n        assertArgument(false, \"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\n;\n;\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */\nexport class MulticoinProviderPlugin {\n    /**\n     *  The name.\n     */\n    name;\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */\n    constructor(name) {\n        defineProperties(this, { name });\n    }\n    connect(proivder) {\n        return this;\n    }\n    /**\n     *  Returns ``true`` if %%coinType%% is supported by this plugin.\n     */\n    supportsCoinType(coinType) {\n        return false;\n    }\n    /**\n     *  Resovles to the encoded %%address%% for %%coinType%%.\n     */\n    async encodeAddress(coinType, address) {\n        throw new Error(\"unsupported coin\");\n    }\n    /**\n     *  Resovles to the decoded %%data%% for %%coinType%%.\n     */\n    async decodeAddress(coinType, data) {\n        throw new Error(\"unsupported coin\");\n    }\n}\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n/**\n *  A **BasicMulticoinProviderPlugin** provides service for common\n *  coin types, which do not require additional libraries to encode or\n *  decode.\n */\nexport class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n    /**\n     *  Creates a new **BasicMulticoinProviderPlugin**.\n     */\n    constructor() {\n        super(BasicMulticoinPluginId);\n    }\n}\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */\nexport class EnsResolver {\n    /**\n     *  The connected provider.\n     */\n    provider;\n    /**\n     *  The address of the resolver.\n     */\n    address;\n    /**\n     *  The name this resolver was resolved against.\n     */\n    name;\n    // For EIP-2544 names, the ancestor that provided the resolver\n    #supports2544;\n    #resolver;\n    constructor(provider, address, name) {\n        defineProperties(this, { provider, address, name });\n        this.#supports2544 = null;\n        this.#resolver = new Contract(address, [\n            \"function supportsInterface(bytes4) view returns (bool)\",\n            \"function resolve(bytes, bytes) view returns (bytes)\",\n            \"function addr(bytes32) view returns (address)\",\n            \"function addr(bytes32, uint) view returns (bytes)\",\n            \"function text(bytes32, string) view returns (string)\",\n            \"function contenthash(bytes32) view returns (bytes)\",\n        ], provider);\n    }\n    /**\n     *  Resolves to true if the resolver supports wildcard resolution.\n     */\n    async supportsWildcard() {\n        if (this.#supports2544 == null) {\n            this.#supports2544 = (async () => {\n                try {\n                    return await this.#resolver.supportsInterface(\"0x9061b923\");\n                }\n                catch (error) {\n                    // Wildcard resolvers must understand supportsInterface\n                    // and return true.\n                    if (isError(error, \"CALL_EXCEPTION\")) {\n                        return false;\n                    }\n                    // Let future attempts try again...\n                    this.#supports2544 = null;\n                    throw error;\n                }\n            })();\n        }\n        return await this.#supports2544;\n    }\n    async #fetch(funcName, params) {\n        params = (params || []).slice();\n        const iface = this.#resolver.interface;\n        // The first parameters is always the nodehash\n        params.unshift(namehash(this.name));\n        let fragment = null;\n        if (await this.supportsWildcard()) {\n            fragment = iface.getFunction(funcName);\n            assert(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n                info: { funcName }\n            });\n            params = [\n                dnsEncode(this.name),\n                iface.encodeFunctionData(fragment, params)\n            ];\n            funcName = \"resolve(bytes,bytes)\";\n        }\n        params.push({\n            enableCcipRead: true\n        });\n        try {\n            const result = await this.#resolver[funcName](...params);\n            if (fragment) {\n                return iface.decodeFunctionResult(fragment, result)[0];\n            }\n            return result;\n        }\n        catch (error) {\n            if (!isError(error, \"CALL_EXCEPTION\")) {\n                throw error;\n            }\n        }\n        return null;\n    }\n    /**\n     *  Resolves to the address for %%coinType%% or null if the\n     *  provided %%coinType%% has not been configured.\n     */\n    async getAddress(coinType) {\n        if (coinType == null) {\n            coinType = 60;\n        }\n        if (coinType === 60) {\n            try {\n                const result = await this.#fetch(\"addr(bytes32)\");\n                // No address\n                if (result == null || result === ZeroAddress) {\n                    return null;\n                }\n                return result;\n            }\n            catch (error) {\n                if (isError(error, \"CALL_EXCEPTION\")) {\n                    return null;\n                }\n                throw error;\n            }\n        }\n        // Try decoding its EVM canonical chain as an EVM chain address first\n        if (coinType >= 0 && coinType < 0x80000000) {\n            let ethCoinType = coinType + 0x80000000;\n            const data = await this.#fetch(\"addr(bytes32,uint)\", [ethCoinType]);\n            if (isHexString(data, 20)) {\n                return getAddress(data);\n            }\n        }\n        let coinPlugin = null;\n        for (const plugin of this.provider.plugins) {\n            if (!(plugin instanceof MulticoinProviderPlugin)) {\n                continue;\n            }\n            if (plugin.supportsCoinType(coinType)) {\n                coinPlugin = plugin;\n                break;\n            }\n        }\n        if (coinPlugin == null) {\n            return null;\n        }\n        // keccak256(\"addr(bytes32,uint256\")\n        const data = await this.#fetch(\"addr(bytes32,uint)\", [coinType]);\n        // No address\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // Compute the address\n        const address = await coinPlugin.decodeAddress(coinType, data);\n        if (address != null) {\n            return address;\n        }\n        assert(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\n            operation: `getAddress(${coinType})`,\n            info: { coinType, data }\n        });\n    }\n    /**\n     *  Resolves to the EIP-634 text record for %%key%%, or ``null``\n     *  if unconfigured.\n     */\n    async getText(key) {\n        const data = await this.#fetch(\"text(bytes32,string)\", [key]);\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        return data;\n    }\n    /**\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\n     */\n    async getContentHash() {\n        // keccak256(\"contenthash()\")\n        const data = await this.#fetch(\"contenthash(bytes32)\");\n        // No contenthash\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const scheme = (ipfs[1] === \"e3010170\") ? \"ipfs\" : \"ipns\";\n            const length = parseInt(ipfs[4], 16);\n            if (ipfs[5].length === length * 2) {\n                return `${scheme}:/\\/${encodeBase58(\"0x\" + ipfs[2])}`;\n            }\n        }\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n        if (swarm && swarm[1].length === 64) {\n            return `bzz:/\\/${swarm[1]}`;\n        }\n        assert(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\n            operation: \"getContentHash()\",\n            info: { data }\n        });\n    }\n    /**\n     *  Resolves to the avatar url or ``null`` if the avatar is either\n     *  unconfigured or incorrectly configured (e.g. references an NFT\n     *  not owned by the address).\n     *\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\n     *  method may be useful.\n     */\n    async getAvatar() {\n        const avatar = await this._getAvatar();\n        return avatar.url;\n    }\n    /**\n     *  When resolving an avatar, there are many steps involved, such\n     *  fetching metadata and possibly validating ownership of an\n     *  NFT.\n     *\n     *  This method can be used to examine each step and the value it\n     *  was working from.\n     */\n    async _getAvatar() {\n        const linkage = [{ type: \"name\", value: this.name }];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) {\n                linkage.push({ type: \"!avatar\", value: \"\" });\n                return { url: null, linkage };\n            }\n            linkage.push({ type: \"avatar\", value: avatar });\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) {\n                    continue;\n                }\n                const scheme = match[1].toLowerCase();\n                switch (scheme) {\n                    case \"https\":\n                    case \"data\":\n                        linkage.push({ type: \"url\", value: avatar });\n                        return { linkage, url: avatar };\n                    case \"ipfs\": {\n                        const url = getIpfsLink(avatar);\n                        linkage.push({ type: \"ipfs\", value: avatar });\n                        linkage.push({ type: \"url\", value: url });\n                        return { linkage, url };\n                    }\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"tokenURI(uint256)\" : \"uri(uint256)\";\n                        linkage.push({ type: scheme, value: avatar });\n                        // The owner of this name\n                        const owner = await this.getAddress();\n                        if (owner == null) {\n                            linkage.push({ type: \"!owner\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) {\n                            linkage.push({ type: `!${scheme}caip`, value: (match[2] || \"\") });\n                            return { url: null, linkage };\n                        }\n                        const tokenId = comps[1];\n                        const contract = new Contract(comps[0], [\n                            // ERC-721\n                            \"function tokenURI(uint) view returns (string)\",\n                            \"function ownerOf(uint) view returns (address)\",\n                            // ERC-1155\n                            \"function uri(uint) view returns (string)\",\n                            \"function balanceOf(address, uint256) view returns (uint)\"\n                        ], this.provider);\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            const tokenOwner = await contract.ownerOf(tokenId);\n                            if (owner !== tokenOwner) {\n                                linkage.push({ type: \"!owner\", value: tokenOwner });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"owner\", value: tokenOwner });\n                        }\n                        else if (scheme === \"erc1155\") {\n                            const balance = await contract.balanceOf(owner, tokenId);\n                            if (!balance) {\n                                linkage.push({ type: \"!balance\", value: \"0\" });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"balance\", value: balance.toString() });\n                        }\n                        // Call the token contract for the metadata URL\n                        let metadataUrl = await contract[selector](tokenId);\n                        if (metadataUrl == null || metadataUrl === \"0x\") {\n                            linkage.push({ type: \"!metadata-url\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        linkage.push({ type: \"metadata-url-base\", value: metadataUrl });\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", toBeHex(tokenId, 32).substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", value: metadataUrl });\n                        }\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n                        linkage.push({ type: \"metadata-url\", value: metadataUrl });\n                        // Get the token metadata\n                        let metadata = {};\n                        const response = await (new FetchRequest(metadataUrl)).send();\n                        response.assertOk();\n                        try {\n                            metadata = response.bodyJson;\n                        }\n                        catch (error) {\n                            try {\n                                linkage.push({ type: \"!metadata\", value: response.bodyText });\n                            }\n                            catch (error) {\n                                const bytes = response.body;\n                                if (bytes) {\n                                    linkage.push({ type: \"!metadata\", value: hexlify(bytes) });\n                                }\n                                return { url: null, linkage };\n                            }\n                            return { url: null, linkage };\n                        }\n                        if (!metadata) {\n                            linkage.push({ type: \"!metadata\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        linkage.push({ type: \"metadata\", value: JSON.stringify(metadata) });\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof (imageUrl) !== \"string\") {\n                            linkage.push({ type: \"!imageUrl\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        }\n                        else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) {\n                                linkage.push({ type: \"!imageUrl-ipfs\", value: imageUrl });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"imageUrl-ipfs\", value: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n                        linkage.push({ type: \"url\", value: imageUrl });\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        }\n        catch (error) { }\n        return { linkage, url: null };\n    }\n    static async getEnsAddress(provider) {\n        const network = await provider.getNetwork();\n        const ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\");\n        // No ENS...\n        assert(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getEnsAddress\", info: { network }\n        });\n        return ensPlugin.address;\n    }\n    static async #getResolver(provider, name) {\n        const ensAddr = await EnsResolver.getEnsAddress(provider);\n        try {\n            const contract = new Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], provider);\n            const addr = await contract.resolver(namehash(name), {\n                enableCcipRead: true\n            });\n            if (addr === ZeroAddress) {\n                return null;\n            }\n            return addr;\n        }\n        catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32),\n            // so probably a link error\n            throw error;\n        }\n        return null;\n    }\n    /**\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n     *  ``null`` if unconfigured.\n     */\n    static async fromName(provider, name) {\n        let currentName = name;\n        while (true) {\n            if (currentName === \"\" || currentName === \".\") {\n                return null;\n            }\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") {\n                return null;\n            }\n            // Check the current node for a resolver\n            const addr = await EnsResolver.#getResolver(provider, currentName);\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new EnsResolver(provider, addr, name);\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !(await resolver.supportsWildcard())) {\n                    return null;\n                }\n                return resolver;\n            }\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n    }\n}\n//# sourceMappingURL=ens-resolver.js.map"]},"metadata":{},"sourceType":"module"}