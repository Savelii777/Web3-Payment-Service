{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scryptAsync = exports.scrypt = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst sha256_js_1 = require(\"./sha256.js\");\nconst pbkdf2_js_1 = require(\"./pbkdf2.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// RFC 7914 Scrypt KDF\n// Left rotate for uint32\nconst rotl = (a, b) => a << b | a >>> 32 - b;\n// The main Scrypt loop: uses Salsa extensively.\n// Six versions of the function were tried, this is the fastest one.\n// prettier-ignore\nfunction XorAndSalsa(prev, pi, input, ii, out, oi) {\n  // Based on https://cr.yp.to/salsa20.html\n  // Xor blocks\n  let y00 = prev[pi++] ^ input[ii++],\n    y01 = prev[pi++] ^ input[ii++];\n  let y02 = prev[pi++] ^ input[ii++],\n    y03 = prev[pi++] ^ input[ii++];\n  let y04 = prev[pi++] ^ input[ii++],\n    y05 = prev[pi++] ^ input[ii++];\n  let y06 = prev[pi++] ^ input[ii++],\n    y07 = prev[pi++] ^ input[ii++];\n  let y08 = prev[pi++] ^ input[ii++],\n    y09 = prev[pi++] ^ input[ii++];\n  let y10 = prev[pi++] ^ input[ii++],\n    y11 = prev[pi++] ^ input[ii++];\n  let y12 = prev[pi++] ^ input[ii++],\n    y13 = prev[pi++] ^ input[ii++];\n  let y14 = prev[pi++] ^ input[ii++],\n    y15 = prev[pi++] ^ input[ii++];\n  // Save state to temporary variables (salsa)\n  let x00 = y00,\n    x01 = y01,\n    x02 = y02,\n    x03 = y03,\n    x04 = y04,\n    x05 = y05,\n    x06 = y06,\n    x07 = y07,\n    x08 = y08,\n    x09 = y09,\n    x10 = y10,\n    x11 = y11,\n    x12 = y12,\n    x13 = y13,\n    x14 = y14,\n    x15 = y15;\n  // Main loop (salsa)\n  for (let i = 0; i < 8; i += 2) {\n    x04 ^= rotl(x00 + x12 | 0, 7);\n    x08 ^= rotl(x04 + x00 | 0, 9);\n    x12 ^= rotl(x08 + x04 | 0, 13);\n    x00 ^= rotl(x12 + x08 | 0, 18);\n    x09 ^= rotl(x05 + x01 | 0, 7);\n    x13 ^= rotl(x09 + x05 | 0, 9);\n    x01 ^= rotl(x13 + x09 | 0, 13);\n    x05 ^= rotl(x01 + x13 | 0, 18);\n    x14 ^= rotl(x10 + x06 | 0, 7);\n    x02 ^= rotl(x14 + x10 | 0, 9);\n    x06 ^= rotl(x02 + x14 | 0, 13);\n    x10 ^= rotl(x06 + x02 | 0, 18);\n    x03 ^= rotl(x15 + x11 | 0, 7);\n    x07 ^= rotl(x03 + x15 | 0, 9);\n    x11 ^= rotl(x07 + x03 | 0, 13);\n    x15 ^= rotl(x11 + x07 | 0, 18);\n    x01 ^= rotl(x00 + x03 | 0, 7);\n    x02 ^= rotl(x01 + x00 | 0, 9);\n    x03 ^= rotl(x02 + x01 | 0, 13);\n    x00 ^= rotl(x03 + x02 | 0, 18);\n    x06 ^= rotl(x05 + x04 | 0, 7);\n    x07 ^= rotl(x06 + x05 | 0, 9);\n    x04 ^= rotl(x07 + x06 | 0, 13);\n    x05 ^= rotl(x04 + x07 | 0, 18);\n    x11 ^= rotl(x10 + x09 | 0, 7);\n    x08 ^= rotl(x11 + x10 | 0, 9);\n    x09 ^= rotl(x08 + x11 | 0, 13);\n    x10 ^= rotl(x09 + x08 | 0, 18);\n    x12 ^= rotl(x15 + x14 | 0, 7);\n    x13 ^= rotl(x12 + x15 | 0, 9);\n    x14 ^= rotl(x13 + x12 | 0, 13);\n    x15 ^= rotl(x14 + x13 | 0, 18);\n  }\n  // Write output (salsa)\n  out[oi++] = y00 + x00 | 0;\n  out[oi++] = y01 + x01 | 0;\n  out[oi++] = y02 + x02 | 0;\n  out[oi++] = y03 + x03 | 0;\n  out[oi++] = y04 + x04 | 0;\n  out[oi++] = y05 + x05 | 0;\n  out[oi++] = y06 + x06 | 0;\n  out[oi++] = y07 + x07 | 0;\n  out[oi++] = y08 + x08 | 0;\n  out[oi++] = y09 + x09 | 0;\n  out[oi++] = y10 + x10 | 0;\n  out[oi++] = y11 + x11 | 0;\n  out[oi++] = y12 + x12 | 0;\n  out[oi++] = y13 + x13 | 0;\n  out[oi++] = y14 + x14 | 0;\n  out[oi++] = y15 + x15 | 0;\n}\nfunction BlockMix(input, ii, out, oi, r) {\n  // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)\n  let head = oi + 0;\n  let tail = oi + 16 * r;\n  for (let i = 0; i < 16; i++) out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X ← B[2r−1]\n  for (let i = 0; i < r; i++, head += 16, ii += 16) {\n    // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1\n    XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])\n    if (i > 0) tail += 16; // First iteration overwrites tmp value in tail\n    XorAndSalsa(out, head, input, ii += 16, out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])\n  }\n}\n// Common prologue and epilogue for sync/async functions\nfunction scryptInit(password, salt, _opts) {\n  // Maxmem - 1GB+1KB by default\n  const opts = (0, utils_js_1.checkOpts)({\n    dkLen: 32,\n    asyncTick: 10,\n    maxmem: 1024 ** 3 + 1024\n  }, _opts);\n  const {\n    N,\n    r,\n    p,\n    dkLen,\n    asyncTick,\n    maxmem,\n    onProgress\n  } = opts;\n  (0, _assert_js_1.number)(N);\n  (0, _assert_js_1.number)(r);\n  (0, _assert_js_1.number)(p);\n  (0, _assert_js_1.number)(dkLen);\n  (0, _assert_js_1.number)(asyncTick);\n  (0, _assert_js_1.number)(maxmem);\n  if (onProgress !== undefined && typeof onProgress !== 'function') throw new Error('progressCb should be function');\n  const blockSize = 128 * r;\n  const blockSize32 = blockSize / 4;\n  if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {\n    // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function\n    // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.\n    throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');\n  }\n  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {\n    throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');\n  }\n  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {\n    throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');\n  }\n  const memUsed = blockSize * (N + p);\n  if (memUsed > maxmem) {\n    throw new Error(\"Scrypt: parameters too large, \".concat(memUsed, \" (128 * r * (N + p)) > \").concat(maxmem, \" (maxmem)\"));\n  }\n  // [B0...Bp−1] ← PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)\n  // Since it has only one iteration there is no reason to use async variant\n  const B = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, salt, {\n    c: 1,\n    dkLen: blockSize * p\n  });\n  const B32 = (0, utils_js_1.u32)(B);\n  // Re-used between parallel iterations. Array(iterations) of B\n  const V = (0, utils_js_1.u32)(new Uint8Array(blockSize * N));\n  const tmp = (0, utils_js_1.u32)(new Uint8Array(blockSize));\n  let blockMixCb = () => {};\n  if (onProgress) {\n    const totalBlockMix = 2 * N * p;\n    // Invoke callback if progress changes from 10.01 to 10.02\n    // Allows to draw smooth progress bar on up to 8K screen\n    const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);\n    let blockMixCnt = 0;\n    blockMixCb = () => {\n      blockMixCnt++;\n      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix)) onProgress(blockMixCnt / totalBlockMix);\n    };\n  }\n  return {\n    N,\n    r,\n    p,\n    dkLen,\n    blockSize32,\n    V,\n    B32,\n    B,\n    tmp,\n    blockMixCb,\n    asyncTick\n  };\n}\nfunction scryptOutput(password, dkLen, B, V, tmp) {\n  const res = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, B, {\n    c: 1,\n    dkLen\n  });\n  B.fill(0);\n  V.fill(0);\n  tmp.fill(0);\n  return res;\n}\n/**\n * Scrypt KDF from RFC 7914.\n * @param password - pass\n * @param salt - salt\n * @param opts - parameters\n * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)\n * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance\n * - `p` is parallelization factor (1 is common)\n * - `dkLen` is output key length in bytes e.g. 32.\n * - `asyncTick` - (default: 10) max time in ms for which async function can block execution\n * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt\n * - `onProgress` - callback function that would be executed for progress report\n * @returns Derived key\n */\nfunction scrypt(password, salt, opts) {\n  const {\n    N,\n    r,\n    p,\n    dkLen,\n    blockSize32,\n    V,\n    B32,\n    B,\n    tmp,\n    blockMixCb\n  } = scryptInit(password, salt, opts);\n  for (let pi = 0; pi < p; pi++) {\n    const Pi = blockSize32 * pi;\n    for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]; // V[0] = B[i]\n    for (let i = 0, pos = 0; i < N - 1; i++) {\n      BlockMix(V, pos, V, pos += blockSize32, r); // V[i] = BlockMix(V[i-1]);\n      blockMixCb();\n    }\n    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n    blockMixCb();\n    for (let i = 0; i < N; i++) {\n      // First u32 of the last 64-byte block (u32 is LE)\n      const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n      for (let k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n      BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n      blockMixCb();\n    }\n  }\n  return scryptOutput(password, dkLen, B, V, tmp);\n}\nexports.scrypt = scrypt;\n/**\n * Scrypt KDF from RFC 7914.\n */\nasync function scryptAsync(password, salt, opts) {\n  const {\n    N,\n    r,\n    p,\n    dkLen,\n    blockSize32,\n    V,\n    B32,\n    B,\n    tmp,\n    blockMixCb,\n    asyncTick\n  } = scryptInit(password, salt, opts);\n  for (let pi = 0; pi < p; pi++) {\n    const Pi = blockSize32 * pi;\n    for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]; // V[0] = B[i]\n    let pos = 0;\n    await (0, utils_js_1.asyncLoop)(N - 1, asyncTick, () => {\n      BlockMix(V, pos, V, pos += blockSize32, r); // V[i] = BlockMix(V[i-1]);\n      blockMixCb();\n    });\n    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n    blockMixCb();\n    await (0, utils_js_1.asyncLoop)(N, asyncTick, () => {\n      // First u32 of the last 64-byte block (u32 is LE)\n      const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n      for (let k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n      BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n      blockMixCb();\n    });\n  }\n  return scryptOutput(password, dkLen, B, V, tmp);\n}\nexports.scryptAsync = scryptAsync;","map":{"version":3,"sources":["src/scrypt.ts"],"names":[],"mappings":"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CAAC,EAAE,EAAE,CAAC;IAAE,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC;IAC9D,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAG,CAAC,CAAC;IAAE,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAG,CAAC,CAAC;IAC9D,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC;IAAE,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC;IAC9D,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAG,CAAC,CAAC;IAAE,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAG,CAAC,CAAC;IAC9D,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC;IAAE,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC;IAC9D,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAG,CAAC,CAAC;IAAE,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAG,CAAC,CAAC;IAC9D,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC;IAAE,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC;IAC9D,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAG,CAAC,CAAC;IAAE,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAG,CAAC,CAAC;IAC9D,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC;IAAE,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC;IAC9D,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAG,CAAC,CAAC;I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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scryptAsync = exports.scrypt = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst sha256_js_1 = require(\"./sha256.js\");\nconst pbkdf2_js_1 = require(\"./pbkdf2.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// RFC 7914 Scrypt KDF\n// Left rotate for uint32\nconst rotl = (a, b) => (a << b) | (a >>> (32 - b));\n// The main Scrypt loop: uses Salsa extensively.\n// Six versions of the function were tried, this is the fastest one.\n// prettier-ignore\nfunction XorAndSalsa(prev, pi, input, ii, out, oi) {\n    // Based on https://cr.yp.to/salsa20.html\n    // Xor blocks\n    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];\n    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];\n    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];\n    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];\n    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];\n    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];\n    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];\n    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];\n    // Save state to temporary variables (salsa)\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    // Main loop (salsa)\n    for (let i = 0; i < 8; i += 2) {\n        x04 ^= rotl(x00 + x12 | 0, 7);\n        x08 ^= rotl(x04 + x00 | 0, 9);\n        x12 ^= rotl(x08 + x04 | 0, 13);\n        x00 ^= rotl(x12 + x08 | 0, 18);\n        x09 ^= rotl(x05 + x01 | 0, 7);\n        x13 ^= rotl(x09 + x05 | 0, 9);\n        x01 ^= rotl(x13 + x09 | 0, 13);\n        x05 ^= rotl(x01 + x13 | 0, 18);\n        x14 ^= rotl(x10 + x06 | 0, 7);\n        x02 ^= rotl(x14 + x10 | 0, 9);\n        x06 ^= rotl(x02 + x14 | 0, 13);\n        x10 ^= rotl(x06 + x02 | 0, 18);\n        x03 ^= rotl(x15 + x11 | 0, 7);\n        x07 ^= rotl(x03 + x15 | 0, 9);\n        x11 ^= rotl(x07 + x03 | 0, 13);\n        x15 ^= rotl(x11 + x07 | 0, 18);\n        x01 ^= rotl(x00 + x03 | 0, 7);\n        x02 ^= rotl(x01 + x00 | 0, 9);\n        x03 ^= rotl(x02 + x01 | 0, 13);\n        x00 ^= rotl(x03 + x02 | 0, 18);\n        x06 ^= rotl(x05 + x04 | 0, 7);\n        x07 ^= rotl(x06 + x05 | 0, 9);\n        x04 ^= rotl(x07 + x06 | 0, 13);\n        x05 ^= rotl(x04 + x07 | 0, 18);\n        x11 ^= rotl(x10 + x09 | 0, 7);\n        x08 ^= rotl(x11 + x10 | 0, 9);\n        x09 ^= rotl(x08 + x11 | 0, 13);\n        x10 ^= rotl(x09 + x08 | 0, 18);\n        x12 ^= rotl(x15 + x14 | 0, 7);\n        x13 ^= rotl(x12 + x15 | 0, 9);\n        x14 ^= rotl(x13 + x12 | 0, 13);\n        x15 ^= rotl(x14 + x13 | 0, 18);\n    }\n    // Write output (salsa)\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\nfunction BlockMix(input, ii, out, oi, r) {\n    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)\n    let head = oi + 0;\n    let tail = oi + 16 * r;\n    for (let i = 0; i < 16; i++)\n        out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X ← B[2r−1]\n    for (let i = 0; i < r; i++, head += 16, ii += 16) {\n        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1\n        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])\n        if (i > 0)\n            tail += 16; // First iteration overwrites tmp value in tail\n        XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])\n    }\n}\n// Common prologue and epilogue for sync/async functions\nfunction scryptInit(password, salt, _opts) {\n    // Maxmem - 1GB+1KB by default\n    const opts = (0, utils_js_1.checkOpts)({\n        dkLen: 32,\n        asyncTick: 10,\n        maxmem: 1024 ** 3 + 1024,\n    }, _opts);\n    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;\n    (0, _assert_js_1.number)(N);\n    (0, _assert_js_1.number)(r);\n    (0, _assert_js_1.number)(p);\n    (0, _assert_js_1.number)(dkLen);\n    (0, _assert_js_1.number)(asyncTick);\n    (0, _assert_js_1.number)(maxmem);\n    if (onProgress !== undefined && typeof onProgress !== 'function')\n        throw new Error('progressCb should be function');\n    const blockSize = 128 * r;\n    const blockSize32 = blockSize / 4;\n    if (N <= 1 || (N & (N - 1)) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {\n        // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function\n        // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.\n        throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');\n    }\n    if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {\n        throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');\n    }\n    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {\n        throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');\n    }\n    const memUsed = blockSize * (N + p);\n    if (memUsed > maxmem) {\n        throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);\n    }\n    // [B0...Bp−1] ← PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)\n    // Since it has only one iteration there is no reason to use async variant\n    const B = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, salt, { c: 1, dkLen: blockSize * p });\n    const B32 = (0, utils_js_1.u32)(B);\n    // Re-used between parallel iterations. Array(iterations) of B\n    const V = (0, utils_js_1.u32)(new Uint8Array(blockSize * N));\n    const tmp = (0, utils_js_1.u32)(new Uint8Array(blockSize));\n    let blockMixCb = () => { };\n    if (onProgress) {\n        const totalBlockMix = 2 * N * p;\n        // Invoke callback if progress changes from 10.01 to 10.02\n        // Allows to draw smooth progress bar on up to 8K screen\n        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);\n        let blockMixCnt = 0;\n        blockMixCb = () => {\n            blockMixCnt++;\n            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))\n                onProgress(blockMixCnt / totalBlockMix);\n        };\n    }\n    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };\n}\nfunction scryptOutput(password, dkLen, B, V, tmp) {\n    const res = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, B, { c: 1, dkLen });\n    B.fill(0);\n    V.fill(0);\n    tmp.fill(0);\n    return res;\n}\n/**\n * Scrypt KDF from RFC 7914.\n * @param password - pass\n * @param salt - salt\n * @param opts - parameters\n * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)\n * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance\n * - `p` is parallelization factor (1 is common)\n * - `dkLen` is output key length in bytes e.g. 32.\n * - `asyncTick` - (default: 10) max time in ms for which async function can block execution\n * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt\n * - `onProgress` - callback function that would be executed for progress report\n * @returns Derived key\n */\nfunction scrypt(password, salt, opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        for (let i = 0, pos = 0; i < N - 1; i++) {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        }\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        for (let i = 0; i < N; i++) {\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++)\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        }\n    }\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\nexports.scrypt = scrypt;\n/**\n * Scrypt KDF from RFC 7914.\n */\nasync function scryptAsync(password, salt, opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        let pos = 0;\n        await (0, utils_js_1.asyncLoop)(N - 1, asyncTick, () => {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        });\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        await (0, utils_js_1.asyncLoop)(N, asyncTick, () => {\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++)\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        });\n    }\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\nexports.scryptAsync = scryptAsync;\n//# sourceMappingURL=scrypt.js.map"]},"metadata":{},"sourceType":"script"}