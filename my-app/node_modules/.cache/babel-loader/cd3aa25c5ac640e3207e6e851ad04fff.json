{"ast":null,"code":"/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */\nimport { assertPrivate, defineProperties } from \"../utils/index.js\";\nconst _gaurd = {};\nfunction n(value, width) {\n  let signed = false;\n  if (width < 0) {\n    signed = true;\n    width *= -1;\n  }\n  // @TODO: Check range is valid for value\n  return new Typed(_gaurd, `${signed ? \"\" : \"u\"}int${width}`, value, {\n    signed,\n    width\n  });\n}\nfunction b(value, size) {\n  // @TODO: Check range is valid for value\n  return new Typed(_gaurd, `bytes${size ? size : \"\"}`, value, {\n    size\n  });\n}\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */\nexport class Typed {\n  /**\n   *  The type, as a Solidity-compatible type.\n   */\n  type;\n  /**\n   *  The actual value.\n   */\n  value;\n  #options;\n  /**\n   *  @_ignore:\n   */\n  _typedSymbol;\n  /**\n   *  @_ignore:\n   */\n  constructor(gaurd, type, value, options) {\n    if (options == null) {\n      options = null;\n    }\n    assertPrivate(_gaurd, gaurd, \"Typed\");\n    defineProperties(this, {\n      _typedSymbol,\n      type,\n      value\n    });\n    this.#options = options;\n    // Check the value is valid\n    this.format();\n  }\n  /**\n   *  Format the type as a Human-Readable type.\n   */\n  format() {\n    if (this.type === \"array\") {\n      throw new Error(\"\");\n    } else if (this.type === \"dynamicArray\") {\n      throw new Error(\"\");\n    } else if (this.type === \"tuple\") {\n      return `tuple(${this.value.map(v => v.format()).join(\",\")})`;\n    }\n    return this.type;\n  }\n  /**\n   *  The default value returned by this type.\n   */\n  defaultValue() {\n    return 0;\n  }\n  /**\n   *  The minimum value for numeric types.\n   */\n  minValue() {\n    return 0;\n  }\n  /**\n   *  The maximum value for numeric types.\n   */\n  maxValue() {\n    return 0;\n  }\n  /**\n   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n   */\n  isBigInt() {\n    return !!this.type.match(/^u?int[0-9]+$/);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n   */\n  isData() {\n    return this.type.startsWith(\"bytes\");\n  }\n  /**\n   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n   */\n  isString() {\n    return this.type === \"string\";\n  }\n  /**\n   *  Returns the tuple name, if this is a tuple. Throws otherwise.\n   */\n  get tupleName() {\n    if (this.type !== \"tuple\") {\n      throw TypeError(\"not a tuple\");\n    }\n    return this.#options;\n  }\n  // Returns the length of this type as an array\n  // - `null` indicates the length is unforced, it could be dynamic\n  // - `-1` indicates the length is dynamic\n  // - any other value indicates it is a static array and is its length\n  /**\n   *  Returns the length of the array type or ``-1`` if it is dynamic.\n   *\n   *  Throws if the type is not an array.\n   */\n  get arrayLength() {\n    if (this.type !== \"array\") {\n      throw TypeError(\"not an array\");\n    }\n    if (this.#options === true) {\n      return -1;\n    }\n    if (this.#options === false) {\n      return this.value.length;\n    }\n    return null;\n  }\n  /**\n   *  Returns a new **Typed** of %%type%% with the %%value%%.\n   */\n  static from(type, value) {\n    return new Typed(_gaurd, type, value);\n  }\n  /**\n   *  Return a new ``uint8`` type for %%v%%.\n   */\n  static uint8(v) {\n    return n(v, 8);\n  }\n  /**\n   *  Return a new ``uint16`` type for %%v%%.\n   */\n  static uint16(v) {\n    return n(v, 16);\n  }\n  /**\n   *  Return a new ``uint24`` type for %%v%%.\n   */\n  static uint24(v) {\n    return n(v, 24);\n  }\n  /**\n   *  Return a new ``uint32`` type for %%v%%.\n   */\n  static uint32(v) {\n    return n(v, 32);\n  }\n  /**\n   *  Return a new ``uint40`` type for %%v%%.\n   */\n  static uint40(v) {\n    return n(v, 40);\n  }\n  /**\n   *  Return a new ``uint48`` type for %%v%%.\n   */\n  static uint48(v) {\n    return n(v, 48);\n  }\n  /**\n   *  Return a new ``uint56`` type for %%v%%.\n   */\n  static uint56(v) {\n    return n(v, 56);\n  }\n  /**\n   *  Return a new ``uint64`` type for %%v%%.\n   */\n  static uint64(v) {\n    return n(v, 64);\n  }\n  /**\n   *  Return a new ``uint72`` type for %%v%%.\n   */\n  static uint72(v) {\n    return n(v, 72);\n  }\n  /**\n   *  Return a new ``uint80`` type for %%v%%.\n   */\n  static uint80(v) {\n    return n(v, 80);\n  }\n  /**\n   *  Return a new ``uint88`` type for %%v%%.\n   */\n  static uint88(v) {\n    return n(v, 88);\n  }\n  /**\n   *  Return a new ``uint96`` type for %%v%%.\n   */\n  static uint96(v) {\n    return n(v, 96);\n  }\n  /**\n   *  Return a new ``uint104`` type for %%v%%.\n   */\n  static uint104(v) {\n    return n(v, 104);\n  }\n  /**\n   *  Return a new ``uint112`` type for %%v%%.\n   */\n  static uint112(v) {\n    return n(v, 112);\n  }\n  /**\n   *  Return a new ``uint120`` type for %%v%%.\n   */\n  static uint120(v) {\n    return n(v, 120);\n  }\n  /**\n   *  Return a new ``uint128`` type for %%v%%.\n   */\n  static uint128(v) {\n    return n(v, 128);\n  }\n  /**\n   *  Return a new ``uint136`` type for %%v%%.\n   */\n  static uint136(v) {\n    return n(v, 136);\n  }\n  /**\n   *  Return a new ``uint144`` type for %%v%%.\n   */\n  static uint144(v) {\n    return n(v, 144);\n  }\n  /**\n   *  Return a new ``uint152`` type for %%v%%.\n   */\n  static uint152(v) {\n    return n(v, 152);\n  }\n  /**\n   *  Return a new ``uint160`` type for %%v%%.\n   */\n  static uint160(v) {\n    return n(v, 160);\n  }\n  /**\n   *  Return a new ``uint168`` type for %%v%%.\n   */\n  static uint168(v) {\n    return n(v, 168);\n  }\n  /**\n   *  Return a new ``uint176`` type for %%v%%.\n   */\n  static uint176(v) {\n    return n(v, 176);\n  }\n  /**\n   *  Return a new ``uint184`` type for %%v%%.\n   */\n  static uint184(v) {\n    return n(v, 184);\n  }\n  /**\n   *  Return a new ``uint192`` type for %%v%%.\n   */\n  static uint192(v) {\n    return n(v, 192);\n  }\n  /**\n   *  Return a new ``uint200`` type for %%v%%.\n   */\n  static uint200(v) {\n    return n(v, 200);\n  }\n  /**\n   *  Return a new ``uint208`` type for %%v%%.\n   */\n  static uint208(v) {\n    return n(v, 208);\n  }\n  /**\n   *  Return a new ``uint216`` type for %%v%%.\n   */\n  static uint216(v) {\n    return n(v, 216);\n  }\n  /**\n   *  Return a new ``uint224`` type for %%v%%.\n   */\n  static uint224(v) {\n    return n(v, 224);\n  }\n  /**\n   *  Return a new ``uint232`` type for %%v%%.\n   */\n  static uint232(v) {\n    return n(v, 232);\n  }\n  /**\n   *  Return a new ``uint240`` type for %%v%%.\n   */\n  static uint240(v) {\n    return n(v, 240);\n  }\n  /**\n   *  Return a new ``uint248`` type for %%v%%.\n   */\n  static uint248(v) {\n    return n(v, 248);\n  }\n  /**\n   *  Return a new ``uint256`` type for %%v%%.\n   */\n  static uint256(v) {\n    return n(v, 256);\n  }\n  /**\n   *  Return a new ``uint256`` type for %%v%%.\n   */\n  static uint(v) {\n    return n(v, 256);\n  }\n  /**\n   *  Return a new ``int8`` type for %%v%%.\n   */\n  static int8(v) {\n    return n(v, -8);\n  }\n  /**\n   *  Return a new ``int16`` type for %%v%%.\n   */\n  static int16(v) {\n    return n(v, -16);\n  }\n  /**\n   *  Return a new ``int24`` type for %%v%%.\n   */\n  static int24(v) {\n    return n(v, -24);\n  }\n  /**\n   *  Return a new ``int32`` type for %%v%%.\n   */\n  static int32(v) {\n    return n(v, -32);\n  }\n  /**\n   *  Return a new ``int40`` type for %%v%%.\n   */\n  static int40(v) {\n    return n(v, -40);\n  }\n  /**\n   *  Return a new ``int48`` type for %%v%%.\n   */\n  static int48(v) {\n    return n(v, -48);\n  }\n  /**\n   *  Return a new ``int56`` type for %%v%%.\n   */\n  static int56(v) {\n    return n(v, -56);\n  }\n  /**\n   *  Return a new ``int64`` type for %%v%%.\n   */\n  static int64(v) {\n    return n(v, -64);\n  }\n  /**\n   *  Return a new ``int72`` type for %%v%%.\n   */\n  static int72(v) {\n    return n(v, -72);\n  }\n  /**\n   *  Return a new ``int80`` type for %%v%%.\n   */\n  static int80(v) {\n    return n(v, -80);\n  }\n  /**\n   *  Return a new ``int88`` type for %%v%%.\n   */\n  static int88(v) {\n    return n(v, -88);\n  }\n  /**\n   *  Return a new ``int96`` type for %%v%%.\n   */\n  static int96(v) {\n    return n(v, -96);\n  }\n  /**\n   *  Return a new ``int104`` type for %%v%%.\n   */\n  static int104(v) {\n    return n(v, -104);\n  }\n  /**\n   *  Return a new ``int112`` type for %%v%%.\n   */\n  static int112(v) {\n    return n(v, -112);\n  }\n  /**\n   *  Return a new ``int120`` type for %%v%%.\n   */\n  static int120(v) {\n    return n(v, -120);\n  }\n  /**\n   *  Return a new ``int128`` type for %%v%%.\n   */\n  static int128(v) {\n    return n(v, -128);\n  }\n  /**\n   *  Return a new ``int136`` type for %%v%%.\n   */\n  static int136(v) {\n    return n(v, -136);\n  }\n  /**\n   *  Return a new ``int144`` type for %%v%%.\n   */\n  static int144(v) {\n    return n(v, -144);\n  }\n  /**\n   *  Return a new ``int52`` type for %%v%%.\n   */\n  static int152(v) {\n    return n(v, -152);\n  }\n  /**\n   *  Return a new ``int160`` type for %%v%%.\n   */\n  static int160(v) {\n    return n(v, -160);\n  }\n  /**\n   *  Return a new ``int168`` type for %%v%%.\n   */\n  static int168(v) {\n    return n(v, -168);\n  }\n  /**\n   *  Return a new ``int176`` type for %%v%%.\n   */\n  static int176(v) {\n    return n(v, -176);\n  }\n  /**\n   *  Return a new ``int184`` type for %%v%%.\n   */\n  static int184(v) {\n    return n(v, -184);\n  }\n  /**\n   *  Return a new ``int92`` type for %%v%%.\n   */\n  static int192(v) {\n    return n(v, -192);\n  }\n  /**\n   *  Return a new ``int200`` type for %%v%%.\n   */\n  static int200(v) {\n    return n(v, -200);\n  }\n  /**\n   *  Return a new ``int208`` type for %%v%%.\n   */\n  static int208(v) {\n    return n(v, -208);\n  }\n  /**\n   *  Return a new ``int216`` type for %%v%%.\n   */\n  static int216(v) {\n    return n(v, -216);\n  }\n  /**\n   *  Return a new ``int224`` type for %%v%%.\n   */\n  static int224(v) {\n    return n(v, -224);\n  }\n  /**\n   *  Return a new ``int232`` type for %%v%%.\n   */\n  static int232(v) {\n    return n(v, -232);\n  }\n  /**\n   *  Return a new ``int240`` type for %%v%%.\n   */\n  static int240(v) {\n    return n(v, -240);\n  }\n  /**\n   *  Return a new ``int248`` type for %%v%%.\n   */\n  static int248(v) {\n    return n(v, -248);\n  }\n  /**\n   *  Return a new ``int256`` type for %%v%%.\n   */\n  static int256(v) {\n    return n(v, -256);\n  }\n  /**\n   *  Return a new ``int256`` type for %%v%%.\n   */\n  static int(v) {\n    return n(v, -256);\n  }\n  /**\n   *  Return a new ``bytes1`` type for %%v%%.\n   */\n  static bytes1(v) {\n    return b(v, 1);\n  }\n  /**\n   *  Return a new ``bytes2`` type for %%v%%.\n   */\n  static bytes2(v) {\n    return b(v, 2);\n  }\n  /**\n   *  Return a new ``bytes3`` type for %%v%%.\n   */\n  static bytes3(v) {\n    return b(v, 3);\n  }\n  /**\n   *  Return a new ``bytes4`` type for %%v%%.\n   */\n  static bytes4(v) {\n    return b(v, 4);\n  }\n  /**\n   *  Return a new ``bytes5`` type for %%v%%.\n   */\n  static bytes5(v) {\n    return b(v, 5);\n  }\n  /**\n   *  Return a new ``bytes6`` type for %%v%%.\n   */\n  static bytes6(v) {\n    return b(v, 6);\n  }\n  /**\n   *  Return a new ``bytes7`` type for %%v%%.\n   */\n  static bytes7(v) {\n    return b(v, 7);\n  }\n  /**\n   *  Return a new ``bytes8`` type for %%v%%.\n   */\n  static bytes8(v) {\n    return b(v, 8);\n  }\n  /**\n   *  Return a new ``bytes9`` type for %%v%%.\n   */\n  static bytes9(v) {\n    return b(v, 9);\n  }\n  /**\n   *  Return a new ``bytes10`` type for %%v%%.\n   */\n  static bytes10(v) {\n    return b(v, 10);\n  }\n  /**\n   *  Return a new ``bytes11`` type for %%v%%.\n   */\n  static bytes11(v) {\n    return b(v, 11);\n  }\n  /**\n   *  Return a new ``bytes12`` type for %%v%%.\n   */\n  static bytes12(v) {\n    return b(v, 12);\n  }\n  /**\n   *  Return a new ``bytes13`` type for %%v%%.\n   */\n  static bytes13(v) {\n    return b(v, 13);\n  }\n  /**\n   *  Return a new ``bytes14`` type for %%v%%.\n   */\n  static bytes14(v) {\n    return b(v, 14);\n  }\n  /**\n   *  Return a new ``bytes15`` type for %%v%%.\n   */\n  static bytes15(v) {\n    return b(v, 15);\n  }\n  /**\n   *  Return a new ``bytes16`` type for %%v%%.\n   */\n  static bytes16(v) {\n    return b(v, 16);\n  }\n  /**\n   *  Return a new ``bytes17`` type for %%v%%.\n   */\n  static bytes17(v) {\n    return b(v, 17);\n  }\n  /**\n   *  Return a new ``bytes18`` type for %%v%%.\n   */\n  static bytes18(v) {\n    return b(v, 18);\n  }\n  /**\n   *  Return a new ``bytes19`` type for %%v%%.\n   */\n  static bytes19(v) {\n    return b(v, 19);\n  }\n  /**\n   *  Return a new ``bytes20`` type for %%v%%.\n   */\n  static bytes20(v) {\n    return b(v, 20);\n  }\n  /**\n   *  Return a new ``bytes21`` type for %%v%%.\n   */\n  static bytes21(v) {\n    return b(v, 21);\n  }\n  /**\n   *  Return a new ``bytes22`` type for %%v%%.\n   */\n  static bytes22(v) {\n    return b(v, 22);\n  }\n  /**\n   *  Return a new ``bytes23`` type for %%v%%.\n   */\n  static bytes23(v) {\n    return b(v, 23);\n  }\n  /**\n   *  Return a new ``bytes24`` type for %%v%%.\n   */\n  static bytes24(v) {\n    return b(v, 24);\n  }\n  /**\n   *  Return a new ``bytes25`` type for %%v%%.\n   */\n  static bytes25(v) {\n    return b(v, 25);\n  }\n  /**\n   *  Return a new ``bytes26`` type for %%v%%.\n   */\n  static bytes26(v) {\n    return b(v, 26);\n  }\n  /**\n   *  Return a new ``bytes27`` type for %%v%%.\n   */\n  static bytes27(v) {\n    return b(v, 27);\n  }\n  /**\n   *  Return a new ``bytes28`` type for %%v%%.\n   */\n  static bytes28(v) {\n    return b(v, 28);\n  }\n  /**\n   *  Return a new ``bytes29`` type for %%v%%.\n   */\n  static bytes29(v) {\n    return b(v, 29);\n  }\n  /**\n   *  Return a new ``bytes30`` type for %%v%%.\n   */\n  static bytes30(v) {\n    return b(v, 30);\n  }\n  /**\n   *  Return a new ``bytes31`` type for %%v%%.\n   */\n  static bytes31(v) {\n    return b(v, 31);\n  }\n  /**\n   *  Return a new ``bytes32`` type for %%v%%.\n   */\n  static bytes32(v) {\n    return b(v, 32);\n  }\n  /**\n   *  Return a new ``address`` type for %%v%%.\n   */\n  static address(v) {\n    return new Typed(_gaurd, \"address\", v);\n  }\n  /**\n   *  Return a new ``bool`` type for %%v%%.\n   */\n  static bool(v) {\n    return new Typed(_gaurd, \"bool\", !!v);\n  }\n  /**\n   *  Return a new ``bytes`` type for %%v%%.\n   */\n  static bytes(v) {\n    return new Typed(_gaurd, \"bytes\", v);\n  }\n  /**\n   *  Return a new ``string`` type for %%v%%.\n   */\n  static string(v) {\n    return new Typed(_gaurd, \"string\", v);\n  }\n  /**\n   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n   */\n  static array(v, dynamic) {\n    throw new Error(\"not implemented yet\");\n    return new Typed(_gaurd, \"array\", v, dynamic);\n  }\n  /**\n   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n   */\n  static tuple(v, name) {\n    throw new Error(\"not implemented yet\");\n    return new Typed(_gaurd, \"tuple\", v, name);\n  }\n  /**\n   *  Return a new ``uint8`` type for %%v%%.\n   */\n  static overrides(v) {\n    return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\n  }\n  /**\n   *  Returns true only if %%value%% is a [[Typed]] instance.\n   */\n  static isTyped(value) {\n    return value && typeof value === \"object\" && \"_typedSymbol\" in value && value._typedSymbol === _typedSymbol;\n  }\n  /**\n   *  If the value is a [[Typed]] instance, validates the underlying value\n   *  and returns it, otherwise returns value directly.\n   *\n   *  This is useful for functions that with to accept either a [[Typed]]\n   *  object or values.\n   */\n  static dereference(value, type) {\n    if (Typed.isTyped(value)) {\n      if (value.type !== type) {\n        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);\n      }\n      return value.value;\n    }\n    return value;\n  }\n}","map":{"version":3,"sources":["../../src.ts/abi/typed.ts"],"names":[],"mappings":"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EvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAEvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAY,EAAA;IAAW,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EAGvD;;AAEG;EACH,OAAO,OAAO,CAAC,CAAuB,EAAA;IAAW,OAAO,IAAI,KAAK,CAAC,MAAM,EAAE,SAAS,EAAE,CAAC,CAAC;EAAE;EAEzF;;AAEG;EACH,OAAO,IAAI,CAAC,CAAM,EAAA;IAAW,OAAO,IAAI,KAAK,CAAC,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;EAAE;EAEpE;;AAEG;EACH,OAAO,KAAK,CAAC,CAAY,EAAA;IAAW,OAAO,IAAI,KAAK,CAAC,MAAM,EAAE,OAAO,EAAE,CAAC,CAAC;EAAE;EAE1E;;AAEG;EACH,OAAO,MAAM,CAAC,CAAS,EAAA;IAAW,OAAO,IAAI,KAAK,CAAC,MAAM,EAAE,QAAQ,EAAE,CAAC,CAAC;EAAE;EAGzE;;AAEG;EACH,OAAO,KAAK,CAAC,CAAqB,EAAE,OAAwB,EAAA;IACxD,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC;IACtC,OAAO,IAAI,KAAK,CAAC,MAAM,EAAE,OAAO,EAAE,CAAC,EAAE,OAAO,CAAC;EACjD;EAGA;;AAEG;EACH,OAAO,KAAK,CAAC,CAAmD,EAAE,IAAa,EAAA;IAC3E,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC;IACtC,OAAO,IAAI,KAAK,CAAC,MAAM,EAAE,OAAO,EAAE,CAAC,EAAE,IAAI,CAAC;EAC9C;EAGA;;AAEG;EACH,OAAO,SAAS,CAAC,CAAsB,EAAA;IACnC,OAAO,IAAI,KAAK,CAAC,MAAM,EAAE,WAAW,EAAE,MAAM,CAAC,MAAM,CAAC,CAAA,CAAG,EAAE,CAAC,CAAC,CAAC;EAChE;EAEA;;AAEG;EACH,OAAO,OAAO,CAAC,KAAU,EAAA;IACrB,OAAQ,KAAK,IACN,OAAO,KAAM,KAAK,QAAQ,IAC1B,cAAc,IAAI,KAAK,IACvB,KAAK,CAAC,YAAY,KAAK,YAAY;EAC9C;EAEA;;;;;;AAMG;EACH,OAAO,WAAW,CAAI,KAAgB,EAAE,IAAY,EAAA;IAChD,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;MACtB,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,EAAE;QACrB,MAAM,IAAI,KAAK,CAAC,0BAA2B,IAAK,SAAU,KAAK,CAAC,IAAK,EAAE,CAAC;MAC3E;MACD,OAAO,KAAK,CAAC,KAAK;IACrB;IACD,OAAO,KAAK;EAChB;AACH","sourceRoot":"","sourcesContent":["/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */\nimport { assertPrivate, defineProperties } from \"../utils/index.js\";\nconst _gaurd = {};\nfunction n(value, width) {\n    let signed = false;\n    if (width < 0) {\n        signed = true;\n        width *= -1;\n    }\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `${signed ? \"\" : \"u\"}int${width}`, value, { signed, width });\n}\nfunction b(value, size) {\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `bytes${(size) ? size : \"\"}`, value, { size });\n}\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */\nexport class Typed {\n    /**\n     *  The type, as a Solidity-compatible type.\n     */\n    type;\n    /**\n     *  The actual value.\n     */\n    value;\n    #options;\n    /**\n     *  @_ignore:\n     */\n    _typedSymbol;\n    /**\n     *  @_ignore:\n     */\n    constructor(gaurd, type, value, options) {\n        if (options == null) {\n            options = null;\n        }\n        assertPrivate(_gaurd, gaurd, \"Typed\");\n        defineProperties(this, { _typedSymbol, type, value });\n        this.#options = options;\n        // Check the value is valid\n        this.format();\n    }\n    /**\n     *  Format the type as a Human-Readable type.\n     */\n    format() {\n        if (this.type === \"array\") {\n            throw new Error(\"\");\n        }\n        else if (this.type === \"dynamicArray\") {\n            throw new Error(\"\");\n        }\n        else if (this.type === \"tuple\") {\n            return `tuple(${this.value.map((v) => v.format()).join(\",\")})`;\n        }\n        return this.type;\n    }\n    /**\n     *  The default value returned by this type.\n     */\n    defaultValue() {\n        return 0;\n    }\n    /**\n     *  The minimum value for numeric types.\n     */\n    minValue() {\n        return 0;\n    }\n    /**\n     *  The maximum value for numeric types.\n     */\n    maxValue() {\n        return 0;\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n     */\n    isBigInt() {\n        return !!(this.type.match(/^u?int[0-9]+$/));\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n     */\n    isData() {\n        return this.type.startsWith(\"bytes\");\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n     */\n    isString() {\n        return (this.type === \"string\");\n    }\n    /**\n     *  Returns the tuple name, if this is a tuple. Throws otherwise.\n     */\n    get tupleName() {\n        if (this.type !== \"tuple\") {\n            throw TypeError(\"not a tuple\");\n        }\n        return this.#options;\n    }\n    // Returns the length of this type as an array\n    // - `null` indicates the length is unforced, it could be dynamic\n    // - `-1` indicates the length is dynamic\n    // - any other value indicates it is a static array and is its length\n    /**\n     *  Returns the length of the array type or ``-1`` if it is dynamic.\n     *\n     *  Throws if the type is not an array.\n     */\n    get arrayLength() {\n        if (this.type !== \"array\") {\n            throw TypeError(\"not an array\");\n        }\n        if (this.#options === true) {\n            return -1;\n        }\n        if (this.#options === false) {\n            return (this.value).length;\n        }\n        return null;\n    }\n    /**\n     *  Returns a new **Typed** of %%type%% with the %%value%%.\n     */\n    static from(type, value) {\n        return new Typed(_gaurd, type, value);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */\n    static uint8(v) { return n(v, 8); }\n    /**\n     *  Return a new ``uint16`` type for %%v%%.\n     */\n    static uint16(v) { return n(v, 16); }\n    /**\n     *  Return a new ``uint24`` type for %%v%%.\n     */\n    static uint24(v) { return n(v, 24); }\n    /**\n     *  Return a new ``uint32`` type for %%v%%.\n     */\n    static uint32(v) { return n(v, 32); }\n    /**\n     *  Return a new ``uint40`` type for %%v%%.\n     */\n    static uint40(v) { return n(v, 40); }\n    /**\n     *  Return a new ``uint48`` type for %%v%%.\n     */\n    static uint48(v) { return n(v, 48); }\n    /**\n     *  Return a new ``uint56`` type for %%v%%.\n     */\n    static uint56(v) { return n(v, 56); }\n    /**\n     *  Return a new ``uint64`` type for %%v%%.\n     */\n    static uint64(v) { return n(v, 64); }\n    /**\n     *  Return a new ``uint72`` type for %%v%%.\n     */\n    static uint72(v) { return n(v, 72); }\n    /**\n     *  Return a new ``uint80`` type for %%v%%.\n     */\n    static uint80(v) { return n(v, 80); }\n    /**\n     *  Return a new ``uint88`` type for %%v%%.\n     */\n    static uint88(v) { return n(v, 88); }\n    /**\n     *  Return a new ``uint96`` type for %%v%%.\n     */\n    static uint96(v) { return n(v, 96); }\n    /**\n     *  Return a new ``uint104`` type for %%v%%.\n     */\n    static uint104(v) { return n(v, 104); }\n    /**\n     *  Return a new ``uint112`` type for %%v%%.\n     */\n    static uint112(v) { return n(v, 112); }\n    /**\n     *  Return a new ``uint120`` type for %%v%%.\n     */\n    static uint120(v) { return n(v, 120); }\n    /**\n     *  Return a new ``uint128`` type for %%v%%.\n     */\n    static uint128(v) { return n(v, 128); }\n    /**\n     *  Return a new ``uint136`` type for %%v%%.\n     */\n    static uint136(v) { return n(v, 136); }\n    /**\n     *  Return a new ``uint144`` type for %%v%%.\n     */\n    static uint144(v) { return n(v, 144); }\n    /**\n     *  Return a new ``uint152`` type for %%v%%.\n     */\n    static uint152(v) { return n(v, 152); }\n    /**\n     *  Return a new ``uint160`` type for %%v%%.\n     */\n    static uint160(v) { return n(v, 160); }\n    /**\n     *  Return a new ``uint168`` type for %%v%%.\n     */\n    static uint168(v) { return n(v, 168); }\n    /**\n     *  Return a new ``uint176`` type for %%v%%.\n     */\n    static uint176(v) { return n(v, 176); }\n    /**\n     *  Return a new ``uint184`` type for %%v%%.\n     */\n    static uint184(v) { return n(v, 184); }\n    /**\n     *  Return a new ``uint192`` type for %%v%%.\n     */\n    static uint192(v) { return n(v, 192); }\n    /**\n     *  Return a new ``uint200`` type for %%v%%.\n     */\n    static uint200(v) { return n(v, 200); }\n    /**\n     *  Return a new ``uint208`` type for %%v%%.\n     */\n    static uint208(v) { return n(v, 208); }\n    /**\n     *  Return a new ``uint216`` type for %%v%%.\n     */\n    static uint216(v) { return n(v, 216); }\n    /**\n     *  Return a new ``uint224`` type for %%v%%.\n     */\n    static uint224(v) { return n(v, 224); }\n    /**\n     *  Return a new ``uint232`` type for %%v%%.\n     */\n    static uint232(v) { return n(v, 232); }\n    /**\n     *  Return a new ``uint240`` type for %%v%%.\n     */\n    static uint240(v) { return n(v, 240); }\n    /**\n     *  Return a new ``uint248`` type for %%v%%.\n     */\n    static uint248(v) { return n(v, 248); }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */\n    static uint256(v) { return n(v, 256); }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */\n    static uint(v) { return n(v, 256); }\n    /**\n     *  Return a new ``int8`` type for %%v%%.\n     */\n    static int8(v) { return n(v, -8); }\n    /**\n     *  Return a new ``int16`` type for %%v%%.\n     */\n    static int16(v) { return n(v, -16); }\n    /**\n     *  Return a new ``int24`` type for %%v%%.\n     */\n    static int24(v) { return n(v, -24); }\n    /**\n     *  Return a new ``int32`` type for %%v%%.\n     */\n    static int32(v) { return n(v, -32); }\n    /**\n     *  Return a new ``int40`` type for %%v%%.\n     */\n    static int40(v) { return n(v, -40); }\n    /**\n     *  Return a new ``int48`` type for %%v%%.\n     */\n    static int48(v) { return n(v, -48); }\n    /**\n     *  Return a new ``int56`` type for %%v%%.\n     */\n    static int56(v) { return n(v, -56); }\n    /**\n     *  Return a new ``int64`` type for %%v%%.\n     */\n    static int64(v) { return n(v, -64); }\n    /**\n     *  Return a new ``int72`` type for %%v%%.\n     */\n    static int72(v) { return n(v, -72); }\n    /**\n     *  Return a new ``int80`` type for %%v%%.\n     */\n    static int80(v) { return n(v, -80); }\n    /**\n     *  Return a new ``int88`` type for %%v%%.\n     */\n    static int88(v) { return n(v, -88); }\n    /**\n     *  Return a new ``int96`` type for %%v%%.\n     */\n    static int96(v) { return n(v, -96); }\n    /**\n     *  Return a new ``int104`` type for %%v%%.\n     */\n    static int104(v) { return n(v, -104); }\n    /**\n     *  Return a new ``int112`` type for %%v%%.\n     */\n    static int112(v) { return n(v, -112); }\n    /**\n     *  Return a new ``int120`` type for %%v%%.\n     */\n    static int120(v) { return n(v, -120); }\n    /**\n     *  Return a new ``int128`` type for %%v%%.\n     */\n    static int128(v) { return n(v, -128); }\n    /**\n     *  Return a new ``int136`` type for %%v%%.\n     */\n    static int136(v) { return n(v, -136); }\n    /**\n     *  Return a new ``int144`` type for %%v%%.\n     */\n    static int144(v) { return n(v, -144); }\n    /**\n     *  Return a new ``int52`` type for %%v%%.\n     */\n    static int152(v) { return n(v, -152); }\n    /**\n     *  Return a new ``int160`` type for %%v%%.\n     */\n    static int160(v) { return n(v, -160); }\n    /**\n     *  Return a new ``int168`` type for %%v%%.\n     */\n    static int168(v) { return n(v, -168); }\n    /**\n     *  Return a new ``int176`` type for %%v%%.\n     */\n    static int176(v) { return n(v, -176); }\n    /**\n     *  Return a new ``int184`` type for %%v%%.\n     */\n    static int184(v) { return n(v, -184); }\n    /**\n     *  Return a new ``int92`` type for %%v%%.\n     */\n    static int192(v) { return n(v, -192); }\n    /**\n     *  Return a new ``int200`` type for %%v%%.\n     */\n    static int200(v) { return n(v, -200); }\n    /**\n     *  Return a new ``int208`` type for %%v%%.\n     */\n    static int208(v) { return n(v, -208); }\n    /**\n     *  Return a new ``int216`` type for %%v%%.\n     */\n    static int216(v) { return n(v, -216); }\n    /**\n     *  Return a new ``int224`` type for %%v%%.\n     */\n    static int224(v) { return n(v, -224); }\n    /**\n     *  Return a new ``int232`` type for %%v%%.\n     */\n    static int232(v) { return n(v, -232); }\n    /**\n     *  Return a new ``int240`` type for %%v%%.\n     */\n    static int240(v) { return n(v, -240); }\n    /**\n     *  Return a new ``int248`` type for %%v%%.\n     */\n    static int248(v) { return n(v, -248); }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */\n    static int256(v) { return n(v, -256); }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */\n    static int(v) { return n(v, -256); }\n    /**\n     *  Return a new ``bytes1`` type for %%v%%.\n     */\n    static bytes1(v) { return b(v, 1); }\n    /**\n     *  Return a new ``bytes2`` type for %%v%%.\n     */\n    static bytes2(v) { return b(v, 2); }\n    /**\n     *  Return a new ``bytes3`` type for %%v%%.\n     */\n    static bytes3(v) { return b(v, 3); }\n    /**\n     *  Return a new ``bytes4`` type for %%v%%.\n     */\n    static bytes4(v) { return b(v, 4); }\n    /**\n     *  Return a new ``bytes5`` type for %%v%%.\n     */\n    static bytes5(v) { return b(v, 5); }\n    /**\n     *  Return a new ``bytes6`` type for %%v%%.\n     */\n    static bytes6(v) { return b(v, 6); }\n    /**\n     *  Return a new ``bytes7`` type for %%v%%.\n     */\n    static bytes7(v) { return b(v, 7); }\n    /**\n     *  Return a new ``bytes8`` type for %%v%%.\n     */\n    static bytes8(v) { return b(v, 8); }\n    /**\n     *  Return a new ``bytes9`` type for %%v%%.\n     */\n    static bytes9(v) { return b(v, 9); }\n    /**\n     *  Return a new ``bytes10`` type for %%v%%.\n     */\n    static bytes10(v) { return b(v, 10); }\n    /**\n     *  Return a new ``bytes11`` type for %%v%%.\n     */\n    static bytes11(v) { return b(v, 11); }\n    /**\n     *  Return a new ``bytes12`` type for %%v%%.\n     */\n    static bytes12(v) { return b(v, 12); }\n    /**\n     *  Return a new ``bytes13`` type for %%v%%.\n     */\n    static bytes13(v) { return b(v, 13); }\n    /**\n     *  Return a new ``bytes14`` type for %%v%%.\n     */\n    static bytes14(v) { return b(v, 14); }\n    /**\n     *  Return a new ``bytes15`` type for %%v%%.\n     */\n    static bytes15(v) { return b(v, 15); }\n    /**\n     *  Return a new ``bytes16`` type for %%v%%.\n     */\n    static bytes16(v) { return b(v, 16); }\n    /**\n     *  Return a new ``bytes17`` type for %%v%%.\n     */\n    static bytes17(v) { return b(v, 17); }\n    /**\n     *  Return a new ``bytes18`` type for %%v%%.\n     */\n    static bytes18(v) { return b(v, 18); }\n    /**\n     *  Return a new ``bytes19`` type for %%v%%.\n     */\n    static bytes19(v) { return b(v, 19); }\n    /**\n     *  Return a new ``bytes20`` type for %%v%%.\n     */\n    static bytes20(v) { return b(v, 20); }\n    /**\n     *  Return a new ``bytes21`` type for %%v%%.\n     */\n    static bytes21(v) { return b(v, 21); }\n    /**\n     *  Return a new ``bytes22`` type for %%v%%.\n     */\n    static bytes22(v) { return b(v, 22); }\n    /**\n     *  Return a new ``bytes23`` type for %%v%%.\n     */\n    static bytes23(v) { return b(v, 23); }\n    /**\n     *  Return a new ``bytes24`` type for %%v%%.\n     */\n    static bytes24(v) { return b(v, 24); }\n    /**\n     *  Return a new ``bytes25`` type for %%v%%.\n     */\n    static bytes25(v) { return b(v, 25); }\n    /**\n     *  Return a new ``bytes26`` type for %%v%%.\n     */\n    static bytes26(v) { return b(v, 26); }\n    /**\n     *  Return a new ``bytes27`` type for %%v%%.\n     */\n    static bytes27(v) { return b(v, 27); }\n    /**\n     *  Return a new ``bytes28`` type for %%v%%.\n     */\n    static bytes28(v) { return b(v, 28); }\n    /**\n     *  Return a new ``bytes29`` type for %%v%%.\n     */\n    static bytes29(v) { return b(v, 29); }\n    /**\n     *  Return a new ``bytes30`` type for %%v%%.\n     */\n    static bytes30(v) { return b(v, 30); }\n    /**\n     *  Return a new ``bytes31`` type for %%v%%.\n     */\n    static bytes31(v) { return b(v, 31); }\n    /**\n     *  Return a new ``bytes32`` type for %%v%%.\n     */\n    static bytes32(v) { return b(v, 32); }\n    /**\n     *  Return a new ``address`` type for %%v%%.\n     */\n    static address(v) { return new Typed(_gaurd, \"address\", v); }\n    /**\n     *  Return a new ``bool`` type for %%v%%.\n     */\n    static bool(v) { return new Typed(_gaurd, \"bool\", !!v); }\n    /**\n     *  Return a new ``bytes`` type for %%v%%.\n     */\n    static bytes(v) { return new Typed(_gaurd, \"bytes\", v); }\n    /**\n     *  Return a new ``string`` type for %%v%%.\n     */\n    static string(v) { return new Typed(_gaurd, \"string\", v); }\n    /**\n     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n     */\n    static array(v, dynamic) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"array\", v, dynamic);\n    }\n    /**\n     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n     */\n    static tuple(v, name) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"tuple\", v, name);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */\n    static overrides(v) {\n        return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\n    }\n    /**\n     *  Returns true only if %%value%% is a [[Typed]] instance.\n     */\n    static isTyped(value) {\n        return (value\n            && typeof (value) === \"object\"\n            && \"_typedSymbol\" in value\n            && value._typedSymbol === _typedSymbol);\n    }\n    /**\n     *  If the value is a [[Typed]] instance, validates the underlying value\n     *  and returns it, otherwise returns value directly.\n     *\n     *  This is useful for functions that with to accept either a [[Typed]]\n     *  object or values.\n     */\n    static dereference(value, type) {\n        if (Typed.isTyped(value)) {\n            if (value.type !== type) {\n                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);\n            }\n            return value.value;\n        }\n        return value;\n    }\n}\n//# sourceMappingURL=typed.js.map"]},"metadata":{},"sourceType":"module"}