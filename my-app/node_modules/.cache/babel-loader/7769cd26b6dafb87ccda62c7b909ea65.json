{"ast":null,"code":"/**\n *  [[link-etherscan]] provides a third-party service for connecting to\n *  various blockchains over a combination of JSON-RPC and custom API\n *  endpoints.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Arbitrum (``arbitrum``)\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Polygon (``matic``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *\n *  @_subsection api/providers/thirdparty:Etherscan  [providers-etherscan]\n */\nimport { AbiCoder } from \"../abi/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { accessListify, Transaction } from \"../transaction/index.js\";\nimport { defineProperties, hexlify, toQuantity, FetchRequest, assert, assertArgument, isError,\n//    parseUnits,\ntoUtf8String } from \"../utils/index.js\";\nimport { AbstractProvider } from \"./abstract-provider.js\";\nimport { Network } from \"./network.js\";\nimport { NetworkPlugin } from \"./plugins-network.js\";\nimport { showThrottleMessage } from \"./community.js\";\nconst THROTTLE = 2000;\nfunction isPromise(value) {\n  return value && typeof value.then === \"function\";\n}\nconst EtherscanPluginId = \"org.ethers.plugins.provider.Etherscan\";\n/**\n *  A Network can include an **EtherscanPlugin** to provide\n *  a custom base URL.\n *\n *  @_docloc: api/providers/thirdparty:Etherscan\n */\nexport class EtherscanPlugin extends NetworkPlugin {\n  /**\n   *  The Etherscan API base URL.\n   */\n  baseUrl;\n  /**\n   *  Creates a new **EtherscanProvider** which will use\n   *  %%baseUrl%%.\n   */\n  constructor(baseUrl) {\n    super(EtherscanPluginId);\n    defineProperties(this, {\n      baseUrl\n    });\n  }\n  clone() {\n    return new EtherscanPlugin(this.baseUrl);\n  }\n}\nconst skipKeys = [\"enableCcipRead\"];\nlet nextId = 1;\n/**\n *  The **EtherscanBaseProvider** is the super-class of\n *  [[EtherscanProvider]], which should generally be used instead.\n *\n *  Since the **EtherscanProvider** includes additional code for\n *  [[Contract]] access, in //rare cases// that contracts are not\n *  used, this class can reduce code size.\n *\n *  @_docloc: api/providers/thirdparty:Etherscan\n */\nexport class EtherscanProvider extends AbstractProvider {\n  /**\n   *  The connected network.\n   */\n  network;\n  /**\n   *  The API key or null if using the community provided bandwidth.\n   */\n  apiKey;\n  #plugin;\n  /**\n   *  Creates a new **EtherscanBaseProvider**.\n   */\n  constructor(_network, _apiKey) {\n    const apiKey = _apiKey != null ? _apiKey : null;\n    super();\n    const network = Network.from(_network);\n    this.#plugin = network.getPlugin(EtherscanPluginId);\n    defineProperties(this, {\n      apiKey,\n      network\n    });\n    // Test that the network is supported by Etherscan\n    this.getBaseUrl();\n  }\n  /**\n   *  Returns the base URL.\n   *\n   *  If an [[EtherscanPlugin]] is configured on the\n   *  [[EtherscanBaseProvider_network]], returns the plugin's\n   *  baseUrl.\n   */\n  getBaseUrl() {\n    if (this.#plugin) {\n      return this.#plugin.baseUrl;\n    }\n    switch (this.network.name) {\n      case \"mainnet\":\n        return \"https:/\\/api.etherscan.io\";\n      case \"goerli\":\n        return \"https:/\\/api-goerli.etherscan.io\";\n      case \"sepolia\":\n        return \"https:/\\/api-sepolia.etherscan.io\";\n      case \"arbitrum\":\n        return \"https:/\\/api.arbiscan.io\";\n      case \"arbitrum-goerli\":\n        return \"https:/\\/api-goerli.arbiscan.io\";\n      case \"matic\":\n        return \"https:/\\/api.polygonscan.com\";\n      case \"matic-mumbai\":\n        return \"https:/\\/api-testnet.polygonscan.com\";\n      case \"optimism\":\n        return \"https:/\\/api-optimistic.etherscan.io\";\n      case \"optimism-goerli\":\n        return \"https:/\\/api-goerli-optimistic.etherscan.io\";\n      case \"bnb\":\n        return \"http:/\\/api.bscscan.com\";\n      case \"bnbt\":\n        return \"http:/\\/api-testnet.bscscan.com\";\n      default:\n    }\n    assertArgument(false, \"unsupported network\", \"network\", this.network);\n  }\n  /**\n   *  Returns the URL for the %%module%% and %%params%%.\n   */\n  getUrl(module, params) {\n    const query = Object.keys(params).reduce((accum, key) => {\n      const value = params[key];\n      if (value != null) {\n        accum += `&${key}=${value}`;\n      }\n      return accum;\n    }, \"\");\n    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : \"\";\n    return `${this.getBaseUrl()}/api?module=${module}${query}${apiKey}`;\n  }\n  /**\n   *  Returns the URL for using POST requests.\n   */\n  getPostUrl() {\n    return `${this.getBaseUrl()}/api`;\n  }\n  /**\n   *  Returns the parameters for using POST requests.\n   */\n  getPostData(module, params) {\n    params.module = module;\n    params.apikey = this.apiKey;\n    return params;\n  }\n  async detectNetwork() {\n    return this.network;\n  }\n  /**\n   *  Resolves to the result of calling %%module%% with %%params%%.\n   *\n   *  If %%post%%, the request is made as a POST request.\n   */\n  async fetch(module, params, post) {\n    const id = nextId++;\n    const url = post ? this.getPostUrl() : this.getUrl(module, params);\n    const payload = post ? this.getPostData(module, params) : null;\n    this.emit(\"debug\", {\n      action: \"sendRequest\",\n      id,\n      url,\n      payload: payload\n    });\n    const request = new FetchRequest(url);\n    request.setThrottleParams({\n      slotInterval: 1000\n    });\n    request.retryFunc = (req, resp, attempt) => {\n      if (this.isCommunityResource()) {\n        showThrottleMessage(\"Etherscan\");\n      }\n      return Promise.resolve(true);\n    };\n    request.processFunc = async (request, response) => {\n      const result = response.hasBody() ? JSON.parse(toUtf8String(response.body)) : {};\n      const throttle = (typeof result.result === \"string\" ? result.result : \"\").toLowerCase().indexOf(\"rate limit\") >= 0;\n      if (module === \"proxy\") {\n        // This JSON response indicates we are being throttled\n        if (result && result.status == 0 && result.message == \"NOTOK\" && throttle) {\n          this.emit(\"debug\", {\n            action: \"receiveError\",\n            id,\n            reason: \"proxy-NOTOK\",\n            error: result\n          });\n          response.throwThrottleError(result.result, THROTTLE);\n        }\n      } else {\n        if (throttle) {\n          this.emit(\"debug\", {\n            action: \"receiveError\",\n            id,\n            reason: \"null result\",\n            error: result.result\n          });\n          response.throwThrottleError(result.result, THROTTLE);\n        }\n      }\n      return response;\n    };\n    if (payload) {\n      request.setHeader(\"content-type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\n      request.body = Object.keys(payload).map(k => `${k}=${payload[k]}`).join(\"&\");\n    }\n    const response = await request.send();\n    try {\n      response.assertOk();\n    } catch (error) {\n      this.emit(\"debug\", {\n        action: \"receiveError\",\n        id,\n        error,\n        reason: \"assertOk\"\n      });\n      assert(false, \"response error\", \"SERVER_ERROR\", {\n        request,\n        response\n      });\n    }\n    if (!response.hasBody()) {\n      this.emit(\"debug\", {\n        action: \"receiveError\",\n        id,\n        error: \"missing body\",\n        reason: \"null body\"\n      });\n      assert(false, \"missing response\", \"SERVER_ERROR\", {\n        request,\n        response\n      });\n    }\n    const result = JSON.parse(toUtf8String(response.body));\n    if (module === \"proxy\") {\n      if (result.jsonrpc != \"2.0\") {\n        this.emit(\"debug\", {\n          action: \"receiveError\",\n          id,\n          result,\n          reason: \"invalid JSON-RPC\"\n        });\n        assert(false, \"invalid JSON-RPC response (missing jsonrpc='2.0')\", \"SERVER_ERROR\", {\n          request,\n          response,\n          info: {\n            result\n          }\n        });\n      }\n      if (result.error) {\n        this.emit(\"debug\", {\n          action: \"receiveError\",\n          id,\n          result,\n          reason: \"JSON-RPC error\"\n        });\n        assert(false, \"error response\", \"SERVER_ERROR\", {\n          request,\n          response,\n          info: {\n            result\n          }\n        });\n      }\n      this.emit(\"debug\", {\n        action: \"receiveRequest\",\n        id,\n        result\n      });\n      return result.result;\n    } else {\n      // getLogs, getHistory have weird success responses\n      if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        this.emit(\"debug\", {\n          action: \"receiveRequest\",\n          id,\n          result\n        });\n        return result.result;\n      }\n      if (result.status != 1 || typeof result.message === \"string\" && !result.message.match(/^OK/)) {\n        this.emit(\"debug\", {\n          action: \"receiveError\",\n          id,\n          result\n        });\n        assert(false, \"error response\", \"SERVER_ERROR\", {\n          request,\n          response,\n          info: {\n            result\n          }\n        });\n      }\n      this.emit(\"debug\", {\n        action: \"receiveRequest\",\n        id,\n        result\n      });\n      return result.result;\n    }\n  }\n  /**\n   *  Returns %%transaction%% normalized for the Etherscan API.\n   */\n  _getTransactionPostData(transaction) {\n    const result = {};\n    for (let key in transaction) {\n      if (skipKeys.indexOf(key) >= 0) {\n        continue;\n      }\n      if (transaction[key] == null) {\n        continue;\n      }\n      let value = transaction[key];\n      if (key === \"type\" && value === 0) {\n        continue;\n      }\n      if (key === \"blockTag\" && value === \"latest\") {\n        continue;\n      }\n      // Quantity-types require no leading zero, unless 0\n      if ({\n        type: true,\n        gasLimit: true,\n        gasPrice: true,\n        maxFeePerGs: true,\n        maxPriorityFeePerGas: true,\n        nonce: true,\n        value: true\n      }[key]) {\n        value = toQuantity(value);\n      } else if (key === \"accessList\") {\n        value = \"[\" + accessListify(value).map(set => {\n          return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\n        }).join(\",\") + \"]\";\n      } else {\n        value = hexlify(value);\n      }\n      result[key] = value;\n    }\n    return result;\n  }\n  /**\n   *  Throws the normalized Etherscan error.\n   */\n  _checkError(req, error, transaction) {\n    // Pull any message out if, possible\n    let message = \"\";\n    if (isError(error, \"SERVER_ERROR\")) {\n      // Check for an error emitted by a proxy call\n      try {\n        message = error.info.result.error.message;\n      } catch (e) {}\n      if (!message) {\n        try {\n          message = error.info.message;\n        } catch (e) {}\n      }\n    }\n    if (req.method === \"estimateGas\") {\n      if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {\n        assert(false, \"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n          transaction: req.transaction\n        });\n      }\n    }\n    if (req.method === \"call\" || req.method === \"estimateGas\") {\n      if (message.match(/execution reverted/i)) {\n        let data = \"\";\n        try {\n          data = error.info.result.error.data;\n        } catch (error) {}\n        const e = AbiCoder.getBuiltinCallException(req.method, req.transaction, data);\n        e.info = {\n          request: req,\n          error\n        };\n        throw e;\n      }\n    }\n    if (message) {\n      if (req.method === \"broadcastTransaction\") {\n        const transaction = Transaction.from(req.signedTransaction);\n        if (message.match(/replacement/i) && message.match(/underpriced/i)) {\n          assert(false, \"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n            transaction\n          });\n        }\n        if (message.match(/insufficient funds/)) {\n          assert(false, \"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n            transaction\n          });\n        }\n        if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n          assert(false, \"nonce has already been used\", \"NONCE_EXPIRED\", {\n            transaction\n          });\n        }\n      }\n    }\n    // Something we could not process\n    throw error;\n  }\n  async _detectNetwork() {\n    return this.network;\n  }\n  async _perform(req) {\n    switch (req.method) {\n      case \"chainId\":\n        return this.network.chainId;\n      case \"getBlockNumber\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_blockNumber\"\n        });\n      case \"getGasPrice\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_gasPrice\"\n        });\n      case \"getPriorityFee\":\n        // This is temporary until Etherscan completes support\n        if (this.network.name === \"mainnet\") {\n          return \"1000000000\";\n        } else if (this.network.name === \"optimism\") {\n          return \"1000000\";\n        } else {\n          throw new Error(\"fallback onto the AbstractProvider default\");\n        }\n      /* Working with Etherscan to get this added:\n      try {\n          const test = await this.fetch(\"proxy\", {\n              action: \"eth_maxPriorityFeePerGas\"\n          });\n          console.log(test);\n          return test;\n      } catch (e) {\n          console.log(\"DEBUG\", e);\n          throw e;\n      }\n      */\n      /* This might be safe; but due to rounding neither myself\n         or Etherscan are necessarily comfortable with this. :)\n      try {\n          const result = await this.fetch(\"gastracker\", { action: \"gasoracle\" });\n          console.log(result);\n          const gasPrice = parseUnits(result.SafeGasPrice, \"gwei\");\n          const baseFee = parseUnits(result.suggestBaseFee, \"gwei\");\n          const priorityFee = gasPrice - baseFee;\n          if (priorityFee < 0) { throw new Error(\"negative priority fee; defer to abstract provider default\"); }\n          return priorityFee;\n      } catch (error) {\n          console.log(\"DEBUG\", error);\n          throw error;\n      }\n      */\n      case \"getBalance\":\n        // Returns base-10 result\n        return this.fetch(\"account\", {\n          action: \"balance\",\n          address: req.address,\n          tag: req.blockTag\n        });\n      case \"getTransactionCount\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_getTransactionCount\",\n          address: req.address,\n          tag: req.blockTag\n        });\n      case \"getCode\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_getCode\",\n          address: req.address,\n          tag: req.blockTag\n        });\n      case \"getStorage\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_getStorageAt\",\n          address: req.address,\n          position: req.position,\n          tag: req.blockTag\n        });\n      case \"broadcastTransaction\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_sendRawTransaction\",\n          hex: req.signedTransaction\n        }, true).catch(error => {\n          return this._checkError(req, error, req.signedTransaction);\n        });\n      case \"getBlock\":\n        if (\"blockTag\" in req) {\n          return this.fetch(\"proxy\", {\n            action: \"eth_getBlockByNumber\",\n            tag: req.blockTag,\n            boolean: req.includeTransactions ? \"true\" : \"false\"\n          });\n        }\n        assert(false, \"getBlock by blockHash not supported by Etherscan\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"getBlock(blockHash)\"\n        });\n      case \"getTransaction\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_getTransactionByHash\",\n          txhash: req.hash\n        });\n      case \"getTransactionReceipt\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_getTransactionReceipt\",\n          txhash: req.hash\n        });\n      case \"call\":\n        {\n          if (req.blockTag !== \"latest\") {\n            throw new Error(\"EtherscanProvider does not support blockTag for call\");\n          }\n          const postData = this._getTransactionPostData(req.transaction);\n          postData.module = \"proxy\";\n          postData.action = \"eth_call\";\n          try {\n            return await this.fetch(\"proxy\", postData, true);\n          } catch (error) {\n            return this._checkError(req, error, req.transaction);\n          }\n        }\n      case \"estimateGas\":\n        {\n          const postData = this._getTransactionPostData(req.transaction);\n          postData.module = \"proxy\";\n          postData.action = \"eth_estimateGas\";\n          try {\n            return await this.fetch(\"proxy\", postData, true);\n          } catch (error) {\n            return this._checkError(req, error, req.transaction);\n          }\n        }\n      /*\n                  case \"getLogs\": {\n                      // Needs to complain if more than one address is passed in\n                      const args: Record<string, any> = { action: \"getLogs\" }\n      \n                      if (params.filter.fromBlock) {\n                          args.fromBlock = checkLogTag(params.filter.fromBlock);\n                      }\n      \n                      if (params.filter.toBlock) {\n                          args.toBlock = checkLogTag(params.filter.toBlock);\n                      }\n      \n                      if (params.filter.address) {\n                          args.address = params.filter.address;\n                      }\n      \n                      // @TODO: We can handle slightly more complicated logs using the logs API\n                      if (params.filter.topics && params.filter.topics.length > 0) {\n                          if (params.filter.topics.length > 1) {\n                              logger.throwError(\"unsupported topic count\", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                          }\n                          if (params.filter.topics.length === 1) {\n                              const topic0 = params.filter.topics[0];\n                              if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                                  logger.throwError(\"unsupported topic format\", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                              }\n                              args.topic0 = topic0;\n                          }\n                      }\n      \n                      const logs: Array<any> = await this.fetch(\"logs\", args);\n      \n                      // Cache txHash => blockHash\n                      let blocks: { [tag: string]: string } = {};\n      \n                      // Add any missing blockHash to the logs\n                      for (let i = 0; i < logs.length; i++) {\n                          const log = logs[i];\n                          if (log.blockHash != null) { continue; }\n                          if (blocks[log.blockNumber] == null) {\n                              const block = await this.getBlock(log.blockNumber);\n                              if (block) {\n                                  blocks[log.blockNumber] = block.hash;\n                              }\n                          }\n      \n                          log.blockHash = blocks[log.blockNumber];\n                      }\n      \n                      return logs;\n                  }\n      */\n      default:\n        break;\n    }\n    return super._perform(req);\n  }\n  async getNetwork() {\n    return this.network;\n  }\n  /**\n   *  Resolves to the current price of ether.\n   *\n   *  This returns ``0`` on any network other than ``mainnet``.\n   */\n  async getEtherPrice() {\n    if (this.network.name !== \"mainnet\") {\n      return 0.0;\n    }\n    return parseFloat((await this.fetch(\"stats\", {\n      action: \"ethprice\"\n    })).ethusd);\n  }\n  /**\n   *  Resolves to a [Contract]] for %%address%%, using the\n   *  Etherscan API to retreive the Contract ABI.\n   */\n  async getContract(_address) {\n    let address = this._getAddress(_address);\n    if (isPromise(address)) {\n      address = await address;\n    }\n    try {\n      const resp = await this.fetch(\"contract\", {\n        action: \"getabi\",\n        address\n      });\n      const abi = JSON.parse(resp);\n      return new Contract(address, abi, this);\n    } catch (error) {\n      return null;\n    }\n  }\n  isCommunityResource() {\n    return this.apiKey == null;\n  }\n}","map":{"version":3,"sources":["../../src.ts/providers/provider-etherscan.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n *  [[link-etherscan]] provides a third-party service for connecting to\n *  various blockchains over a combination of JSON-RPC and custom API\n *  endpoints.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Arbitrum (``arbitrum``)\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Polygon (``matic``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *\n *  @_subsection api/providers/thirdparty:Etherscan  [providers-etherscan]\n */\nimport { AbiCoder } from \"../abi/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { accessListify, Transaction } from \"../transaction/index.js\";\nimport { defineProperties, hexlify, toQuantity, FetchRequest, assert, assertArgument, isError, \n//    parseUnits,\ntoUtf8String } from \"../utils/index.js\";\nimport { AbstractProvider } from \"./abstract-provider.js\";\nimport { Network } from \"./network.js\";\nimport { NetworkPlugin } from \"./plugins-network.js\";\nimport { showThrottleMessage } from \"./community.js\";\nconst THROTTLE = 2000;\nfunction isPromise(value) {\n    return (value && typeof (value.then) === \"function\");\n}\nconst EtherscanPluginId = \"org.ethers.plugins.provider.Etherscan\";\n/**\n *  A Network can include an **EtherscanPlugin** to provide\n *  a custom base URL.\n *\n *  @_docloc: api/providers/thirdparty:Etherscan\n */\nexport class EtherscanPlugin extends NetworkPlugin {\n    /**\n     *  The Etherscan API base URL.\n     */\n    baseUrl;\n    /**\n     *  Creates a new **EtherscanProvider** which will use\n     *  %%baseUrl%%.\n     */\n    constructor(baseUrl) {\n        super(EtherscanPluginId);\n        defineProperties(this, { baseUrl });\n    }\n    clone() {\n        return new EtherscanPlugin(this.baseUrl);\n    }\n}\nconst skipKeys = [\"enableCcipRead\"];\nlet nextId = 1;\n/**\n *  The **EtherscanBaseProvider** is the super-class of\n *  [[EtherscanProvider]], which should generally be used instead.\n *\n *  Since the **EtherscanProvider** includes additional code for\n *  [[Contract]] access, in //rare cases// that contracts are not\n *  used, this class can reduce code size.\n *\n *  @_docloc: api/providers/thirdparty:Etherscan\n */\nexport class EtherscanProvider extends AbstractProvider {\n    /**\n     *  The connected network.\n     */\n    network;\n    /**\n     *  The API key or null if using the community provided bandwidth.\n     */\n    apiKey;\n    #plugin;\n    /**\n     *  Creates a new **EtherscanBaseProvider**.\n     */\n    constructor(_network, _apiKey) {\n        const apiKey = (_apiKey != null) ? _apiKey : null;\n        super();\n        const network = Network.from(_network);\n        this.#plugin = network.getPlugin(EtherscanPluginId);\n        defineProperties(this, { apiKey, network });\n        // Test that the network is supported by Etherscan\n        this.getBaseUrl();\n    }\n    /**\n     *  Returns the base URL.\n     *\n     *  If an [[EtherscanPlugin]] is configured on the\n     *  [[EtherscanBaseProvider_network]], returns the plugin's\n     *  baseUrl.\n     */\n    getBaseUrl() {\n        if (this.#plugin) {\n            return this.#plugin.baseUrl;\n        }\n        switch (this.network.name) {\n            case \"mainnet\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            case \"sepolia\":\n                return \"https:/\\/api-sepolia.etherscan.io\";\n            case \"arbitrum\":\n                return \"https:/\\/api.arbiscan.io\";\n            case \"arbitrum-goerli\":\n                return \"https:/\\/api-goerli.arbiscan.io\";\n            case \"matic\":\n                return \"https:/\\/api.polygonscan.com\";\n            case \"matic-mumbai\":\n                return \"https:/\\/api-testnet.polygonscan.com\";\n            case \"optimism\":\n                return \"https:/\\/api-optimistic.etherscan.io\";\n            case \"optimism-goerli\":\n                return \"https:/\\/api-goerli-optimistic.etherscan.io\";\n            case \"bnb\":\n                return \"http:/\\/api.bscscan.com\";\n            case \"bnbt\":\n                return \"http:/\\/api-testnet.bscscan.com\";\n            default:\n        }\n        assertArgument(false, \"unsupported network\", \"network\", this.network);\n    }\n    /**\n     *  Returns the URL for the %%module%% and %%params%%.\n     */\n    getUrl(module, params) {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${key}=${value}`;\n            }\n            return accum;\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${this.apiKey}` : \"\");\n        return `${this.getBaseUrl()}/api?module=${module}${query}${apiKey}`;\n    }\n    /**\n     *  Returns the URL for using POST requests.\n     */\n    getPostUrl() {\n        return `${this.getBaseUrl()}/api`;\n    }\n    /**\n     *  Returns the parameters for using POST requests.\n     */\n    getPostData(module, params) {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n    async detectNetwork() {\n        return this.network;\n    }\n    /**\n     *  Resolves to the result of calling %%module%% with %%params%%.\n     *\n     *  If %%post%%, the request is made as a POST request.\n     */\n    async fetch(module, params, post) {\n        const id = nextId++;\n        const url = (post ? this.getPostUrl() : this.getUrl(module, params));\n        const payload = (post ? this.getPostData(module, params) : null);\n        this.emit(\"debug\", { action: \"sendRequest\", id, url, payload: payload });\n        const request = new FetchRequest(url);\n        request.setThrottleParams({ slotInterval: 1000 });\n        request.retryFunc = (req, resp, attempt) => {\n            if (this.isCommunityResource()) {\n                showThrottleMessage(\"Etherscan\");\n            }\n            return Promise.resolve(true);\n        };\n        request.processFunc = async (request, response) => {\n            const result = response.hasBody() ? JSON.parse(toUtf8String(response.body)) : {};\n            const throttle = ((typeof (result.result) === \"string\") ? result.result : \"\").toLowerCase().indexOf(\"rate limit\") >= 0;\n            if (module === \"proxy\") {\n                // This JSON response indicates we are being throttled\n                if (result && result.status == 0 && result.message == \"NOTOK\" && throttle) {\n                    this.emit(\"debug\", { action: \"receiveError\", id, reason: \"proxy-NOTOK\", error: result });\n                    response.throwThrottleError(result.result, THROTTLE);\n                }\n            }\n            else {\n                if (throttle) {\n                    this.emit(\"debug\", { action: \"receiveError\", id, reason: \"null result\", error: result.result });\n                    response.throwThrottleError(result.result, THROTTLE);\n                }\n            }\n            return response;\n        };\n        if (payload) {\n            request.setHeader(\"content-type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\n            request.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join(\"&\");\n        }\n        const response = await request.send();\n        try {\n            response.assertOk();\n        }\n        catch (error) {\n            this.emit(\"debug\", { action: \"receiveError\", id, error, reason: \"assertOk\" });\n            assert(false, \"response error\", \"SERVER_ERROR\", { request, response });\n        }\n        if (!response.hasBody()) {\n            this.emit(\"debug\", { action: \"receiveError\", id, error: \"missing body\", reason: \"null body\" });\n            assert(false, \"missing response\", \"SERVER_ERROR\", { request, response });\n        }\n        const result = JSON.parse(toUtf8String(response.body));\n        if (module === \"proxy\") {\n            if (result.jsonrpc != \"2.0\") {\n                this.emit(\"debug\", { action: \"receiveError\", id, result, reason: \"invalid JSON-RPC\" });\n                assert(false, \"invalid JSON-RPC response (missing jsonrpc='2.0')\", \"SERVER_ERROR\", { request, response, info: { result } });\n            }\n            if (result.error) {\n                this.emit(\"debug\", { action: \"receiveError\", id, result, reason: \"JSON-RPC error\" });\n                assert(false, \"error response\", \"SERVER_ERROR\", { request, response, info: { result } });\n            }\n            this.emit(\"debug\", { action: \"receiveRequest\", id, result });\n            return result.result;\n        }\n        else {\n            // getLogs, getHistory have weird success responses\n            if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n                this.emit(\"debug\", { action: \"receiveRequest\", id, result });\n                return result.result;\n            }\n            if (result.status != 1 || (typeof (result.message) === \"string\" && !result.message.match(/^OK/))) {\n                this.emit(\"debug\", { action: \"receiveError\", id, result });\n                assert(false, \"error response\", \"SERVER_ERROR\", { request, response, info: { result } });\n            }\n            this.emit(\"debug\", { action: \"receiveRequest\", id, result });\n            return result.result;\n        }\n    }\n    /**\n     *  Returns %%transaction%% normalized for the Etherscan API.\n     */\n    _getTransactionPostData(transaction) {\n        const result = {};\n        for (let key in transaction) {\n            if (skipKeys.indexOf(key) >= 0) {\n                continue;\n            }\n            if (transaction[key] == null) {\n                continue;\n            }\n            let value = transaction[key];\n            if (key === \"type\" && value === 0) {\n                continue;\n            }\n            if (key === \"blockTag\" && value === \"latest\") {\n                continue;\n            }\n            // Quantity-types require no leading zero, unless 0\n            if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\n                value = toQuantity(value);\n            }\n            else if (key === \"accessList\") {\n                value = \"[\" + accessListify(value).map((set) => {\n                    return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\n                }).join(\",\") + \"]\";\n            }\n            else {\n                value = hexlify(value);\n            }\n            result[key] = value;\n        }\n        return result;\n    }\n    /**\n     *  Throws the normalized Etherscan error.\n     */\n    _checkError(req, error, transaction) {\n        // Pull any message out if, possible\n        let message = \"\";\n        if (isError(error, \"SERVER_ERROR\")) {\n            // Check for an error emitted by a proxy call\n            try {\n                message = error.info.result.error.message;\n            }\n            catch (e) { }\n            if (!message) {\n                try {\n                    message = error.info.message;\n                }\n                catch (e) { }\n            }\n        }\n        if (req.method === \"estimateGas\") {\n            if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {\n                assert(false, \"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: req.transaction\n                });\n            }\n        }\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            if (message.match(/execution reverted/i)) {\n                let data = \"\";\n                try {\n                    data = error.info.result.error.data;\n                }\n                catch (error) { }\n                const e = AbiCoder.getBuiltinCallException(req.method, req.transaction, data);\n                e.info = { request: req, error };\n                throw e;\n            }\n        }\n        if (message) {\n            if (req.method === \"broadcastTransaction\") {\n                const transaction = Transaction.from(req.signedTransaction);\n                if (message.match(/replacement/i) && message.match(/underpriced/i)) {\n                    assert(false, \"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n                        transaction\n                    });\n                }\n                if (message.match(/insufficient funds/)) {\n                    assert(false, \"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                        transaction\n                    });\n                }\n                if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n                    assert(false, \"nonce has already been used\", \"NONCE_EXPIRED\", {\n                        transaction\n                    });\n                }\n            }\n        }\n        // Something we could not process\n        throw error;\n    }\n    async _detectNetwork() {\n        return this.network;\n    }\n    async _perform(req) {\n        switch (req.method) {\n            case \"chainId\":\n                return this.network.chainId;\n            case \"getBlockNumber\":\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n            case \"getGasPrice\":\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n            case \"getPriorityFee\":\n                // This is temporary until Etherscan completes support\n                if (this.network.name === \"mainnet\") {\n                    return \"1000000000\";\n                }\n                else if (this.network.name === \"optimism\") {\n                    return \"1000000\";\n                }\n                else {\n                    throw new Error(\"fallback onto the AbstractProvider default\");\n                }\n            /* Working with Etherscan to get this added:\n            try {\n                const test = await this.fetch(\"proxy\", {\n                    action: \"eth_maxPriorityFeePerGas\"\n                });\n                console.log(test);\n                return test;\n            } catch (e) {\n                console.log(\"DEBUG\", e);\n                throw e;\n            }\n            */\n            /* This might be safe; but due to rounding neither myself\n               or Etherscan are necessarily comfortable with this. :)\n            try {\n                const result = await this.fetch(\"gastracker\", { action: \"gasoracle\" });\n                console.log(result);\n                const gasPrice = parseUnits(result.SafeGasPrice, \"gwei\");\n                const baseFee = parseUnits(result.suggestBaseFee, \"gwei\");\n                const priorityFee = gasPrice - baseFee;\n                if (priorityFee < 0) { throw new Error(\"negative priority fee; defer to abstract provider default\"); }\n                return priorityFee;\n            } catch (error) {\n                console.log(\"DEBUG\", error);\n                throw error;\n            }\n            */\n            case \"getBalance\":\n                // Returns base-10 result\n                return this.fetch(\"account\", {\n                    action: \"balance\",\n                    address: req.address,\n                    tag: req.blockTag\n                });\n            case \"getTransactionCount\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionCount\",\n                    address: req.address,\n                    tag: req.blockTag\n                });\n            case \"getCode\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getCode\",\n                    address: req.address,\n                    tag: req.blockTag\n                });\n            case \"getStorage\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getStorageAt\",\n                    address: req.address,\n                    position: req.position,\n                    tag: req.blockTag\n                });\n            case \"broadcastTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_sendRawTransaction\",\n                    hex: req.signedTransaction\n                }, true).catch((error) => {\n                    return this._checkError(req, error, req.signedTransaction);\n                });\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getBlockByNumber\",\n                        tag: req.blockTag,\n                        boolean: (req.includeTransactions ? \"true\" : \"false\")\n                    });\n                }\n                assert(false, \"getBlock by blockHash not supported by Etherscan\", \"UNSUPPORTED_OPERATION\", {\n                    operation: \"getBlock(blockHash)\"\n                });\n            case \"getTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionByHash\",\n                    txhash: req.hash\n                });\n            case \"getTransactionReceipt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionReceipt\",\n                    txhash: req.hash\n                });\n            case \"call\": {\n                if (req.blockTag !== \"latest\") {\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                }\n                const postData = this._getTransactionPostData(req.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_call\";\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                }\n                catch (error) {\n                    return this._checkError(req, error, req.transaction);\n                }\n            }\n            case \"estimateGas\": {\n                const postData = this._getTransactionPostData(req.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_estimateGas\";\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                }\n                catch (error) {\n                    return this._checkError(req, error, req.transaction);\n                }\n            }\n            /*\n                        case \"getLogs\": {\n                            // Needs to complain if more than one address is passed in\n                            const args: Record<string, any> = { action: \"getLogs\" }\n            \n                            if (params.filter.fromBlock) {\n                                args.fromBlock = checkLogTag(params.filter.fromBlock);\n                            }\n            \n                            if (params.filter.toBlock) {\n                                args.toBlock = checkLogTag(params.filter.toBlock);\n                            }\n            \n                            if (params.filter.address) {\n                                args.address = params.filter.address;\n                            }\n            \n                            // @TODO: We can handle slightly more complicated logs using the logs API\n                            if (params.filter.topics && params.filter.topics.length > 0) {\n                                if (params.filter.topics.length > 1) {\n                                    logger.throwError(\"unsupported topic count\", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                                }\n                                if (params.filter.topics.length === 1) {\n                                    const topic0 = params.filter.topics[0];\n                                    if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                                        logger.throwError(\"unsupported topic format\", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                                    }\n                                    args.topic0 = topic0;\n                                }\n                            }\n            \n                            const logs: Array<any> = await this.fetch(\"logs\", args);\n            \n                            // Cache txHash => blockHash\n                            let blocks: { [tag: string]: string } = {};\n            \n                            // Add any missing blockHash to the logs\n                            for (let i = 0; i < logs.length; i++) {\n                                const log = logs[i];\n                                if (log.blockHash != null) { continue; }\n                                if (blocks[log.blockNumber] == null) {\n                                    const block = await this.getBlock(log.blockNumber);\n                                    if (block) {\n                                        blocks[log.blockNumber] = block.hash;\n                                    }\n                                }\n            \n                                log.blockHash = blocks[log.blockNumber];\n                            }\n            \n                            return logs;\n                        }\n            */\n            default:\n                break;\n        }\n        return super._perform(req);\n    }\n    async getNetwork() {\n        return this.network;\n    }\n    /**\n     *  Resolves to the current price of ether.\n     *\n     *  This returns ``0`` on any network other than ``mainnet``.\n     */\n    async getEtherPrice() {\n        if (this.network.name !== \"mainnet\") {\n            return 0.0;\n        }\n        return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n    }\n    /**\n     *  Resolves to a [Contract]] for %%address%%, using the\n     *  Etherscan API to retreive the Contract ABI.\n     */\n    async getContract(_address) {\n        let address = this._getAddress(_address);\n        if (isPromise(address)) {\n            address = await address;\n        }\n        try {\n            const resp = await this.fetch(\"contract\", {\n                action: \"getabi\", address\n            });\n            const abi = JSON.parse(resp);\n            return new Contract(address, abi, this);\n        }\n        catch (error) {\n            return null;\n        }\n    }\n    isCommunityResource() {\n        return (this.apiKey == null);\n    }\n}\n//# sourceMappingURL=provider-etherscan.js.map"]},"metadata":{},"sourceType":"module"}