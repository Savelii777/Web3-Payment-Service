{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateMethodGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nlet _Symbol$iterator, _Symbol$iterator2;\n/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction that each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retrieve the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentication, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */\nimport { decodeBase64, encodeBase64 } from \"./base64.js\";\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { defineProperties } from \"./properties.js\";\nimport { toUtf8Bytes, toUtf8String } from \"./utf8.js\";\nimport { createGetUrl } from \"./geturl.js\";\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nlet defaultGetUrlFunc = createGetUrl();\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs:/\\/(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nlet locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url, signal) {\n  try {\n    const match = url.match(reData);\n    if (!match) {\n      throw new Error(\"invalid data\");\n    }\n    return new FetchResponse(200, \"OK\", {\n      \"content-type\": match[1] || \"text/plain\"\n    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));\n  } catch (error) {\n    return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url));\n  }\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */\nfunction getIpfsGatewayFunc(baseUrl) {\n  async function gatewayIpfs(url, signal) {\n    try {\n      const match = url.match(reIpfs);\n      if (!match) {\n        throw new Error(\"invalid link\");\n      }\n      return new FetchRequest(\"\".concat(baseUrl).concat(match[2]));\n    } catch (error) {\n      return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url));\n    }\n  }\n  return gatewayIpfs;\n}\nconst Gateways = {\n  \"data\": dataGatewayFunc,\n  \"ipfs\": getIpfsGatewayFunc(\"https:/\\/gateway.ipfs.io/ipfs/\")\n};\nconst fetchSignals = new WeakMap();\n/**\n *  @_ignore\n */\nvar _listeners = /*#__PURE__*/new WeakMap();\nvar _cancelled = /*#__PURE__*/new WeakMap();\nexport class FetchCancelSignal {\n  constructor(request) {\n    _classPrivateFieldInitSpec(this, _listeners, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _cancelled, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _listeners, []);\n    _classPrivateFieldSet(this, _cancelled, false);\n    fetchSignals.set(request, () => {\n      if (_classPrivateFieldGet(this, _cancelled)) {\n        return;\n      }\n      _classPrivateFieldSet(this, _cancelled, true);\n      for (const listener of _classPrivateFieldGet(this, _listeners)) {\n        setTimeout(() => {\n          listener();\n        }, 0);\n      }\n      _classPrivateFieldSet(this, _listeners, []);\n    });\n  }\n  addListener(listener) {\n    assert(!_classPrivateFieldGet(this, _cancelled), \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fetchCancelSignal.addCancelListener\"\n    });\n    _classPrivateFieldGet(this, _listeners).push(listener);\n  }\n  get cancelled() {\n    return _classPrivateFieldGet(this, _cancelled);\n  }\n  checkSignal() {\n    assert(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n  }\n}\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n  if (signal == null) {\n    throw new Error(\"missing signal; should not happen\");\n  }\n  signal.checkSignal();\n  return signal;\n}\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */\nvar _allowInsecure = /*#__PURE__*/new WeakMap();\nvar _gzip = /*#__PURE__*/new WeakMap();\nvar _headers = /*#__PURE__*/new WeakMap();\nvar _method = /*#__PURE__*/new WeakMap();\nvar _timeout = /*#__PURE__*/new WeakMap();\nvar _url = /*#__PURE__*/new WeakMap();\nvar _body = /*#__PURE__*/new WeakMap();\nvar _bodyType = /*#__PURE__*/new WeakMap();\nvar _creds = /*#__PURE__*/new WeakMap();\nvar _preflight = /*#__PURE__*/new WeakMap();\nvar _process = /*#__PURE__*/new WeakMap();\nvar _retry = /*#__PURE__*/new WeakMap();\nvar _signal = /*#__PURE__*/new WeakMap();\nvar _throttle = /*#__PURE__*/new WeakMap();\nvar _getUrlFunc = /*#__PURE__*/new WeakMap();\nvar _send = /*#__PURE__*/new WeakSet();\n_Symbol$iterator = Symbol.iterator;\nexport class FetchRequest {\n  // Hooks\n\n  /**\n   *  The fetch URL to request.\n   */\n  get url() {\n    return _classPrivateFieldGet(this, _url);\n  }\n  set url(url) {\n    _classPrivateFieldSet(this, _url, String(url));\n  }\n  /**\n   *  The fetch body, if any, to send as the request body. //(default: null)//\n   *\n   *  When setting a body, the intrinsic ``Content-Type`` is automatically\n   *  set and will be used if **not overridden** by setting a custom\n   *  header.\n   *\n   *  If %%body%% is null, the body is cleared (along with the\n   *  intrinsic ``Content-Type``).\n   *\n   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to\n   *  ``text/plain``.\n   *\n   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to\n   *  ``application/octet-stream``.\n   *\n   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is\n   *  set to ``application/json``.\n   */\n  get body() {\n    if (_classPrivateFieldGet(this, _body) == null) {\n      return null;\n    }\n    return new Uint8Array(_classPrivateFieldGet(this, _body));\n  }\n  set body(body) {\n    if (body == null) {\n      _classPrivateFieldSet(this, _body, undefined);\n      _classPrivateFieldSet(this, _bodyType, undefined);\n    } else if (typeof body === \"string\") {\n      _classPrivateFieldSet(this, _body, toUtf8Bytes(body));\n      _classPrivateFieldSet(this, _bodyType, \"text/plain\");\n    } else if (body instanceof Uint8Array) {\n      _classPrivateFieldSet(this, _body, body);\n      _classPrivateFieldSet(this, _bodyType, \"application/octet-stream\");\n    } else if (typeof body === \"object\") {\n      _classPrivateFieldSet(this, _body, toUtf8Bytes(JSON.stringify(body)));\n      _classPrivateFieldSet(this, _bodyType, \"application/json\");\n    } else {\n      throw new Error(\"invalid body\");\n    }\n  }\n  /**\n   *  Returns true if the request has a body.\n   */\n  hasBody() {\n    return _classPrivateFieldGet(this, _body) != null;\n  }\n  /**\n   *  The HTTP method to use when requesting the URI. If no method\n   *  has been explicitly set, then ``GET`` is used if the body is\n   *  null and ``POST`` otherwise.\n   */\n  get method() {\n    if (_classPrivateFieldGet(this, _method)) {\n      return _classPrivateFieldGet(this, _method);\n    }\n    if (this.hasBody()) {\n      return \"POST\";\n    }\n    return \"GET\";\n  }\n  set method(method) {\n    if (method == null) {\n      method = \"\";\n    }\n    _classPrivateFieldSet(this, _method, String(method).toUpperCase());\n  }\n  /**\n   *  The headers that will be used when requesting the URI. All\n   *  keys are lower-case.\n   *\n   *  This object is a copy, so any changes will **NOT** be reflected\n   *  in the ``FetchRequest``.\n   *\n   *  To set a header entry, use the ``setHeader`` method.\n   */\n  get headers() {\n    const headers = Object.assign({}, _classPrivateFieldGet(this, _headers));\n    if (_classPrivateFieldGet(this, _creds)) {\n      headers[\"authorization\"] = \"Basic \".concat(encodeBase64(toUtf8Bytes(_classPrivateFieldGet(this, _creds))));\n    }\n    ;\n    if (this.allowGzip) {\n      headers[\"accept-encoding\"] = \"gzip\";\n    }\n    if (headers[\"content-type\"] == null && _classPrivateFieldGet(this, _bodyType)) {\n      headers[\"content-type\"] = _classPrivateFieldGet(this, _bodyType);\n    }\n    if (this.body) {\n      headers[\"content-length\"] = String(this.body.length);\n    }\n    return headers;\n  }\n  /**\n   *  Get the header for %%key%%, ignoring case.\n   */\n  getHeader(key) {\n    return this.headers[key.toLowerCase()];\n  }\n  /**\n   *  Set the header for %%key%% to %%value%%. All values are coerced\n   *  to a string.\n   */\n  setHeader(key, value) {\n    _classPrivateFieldGet(this, _headers)[String(key).toLowerCase()] = String(value);\n  }\n  /**\n   *  Clear all headers, resetting all intrinsic headers.\n   */\n  clearHeaders() {\n    _classPrivateFieldSet(this, _headers, {});\n  }\n  [_Symbol$iterator]() {\n    const headers = this.headers;\n    const keys = Object.keys(headers);\n    let index = 0;\n    return {\n      next: () => {\n        if (index < keys.length) {\n          const key = keys[index++];\n          return {\n            value: [key, headers[key]],\n            done: false\n          };\n        }\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  /**\n   *  The value that will be sent for the ``Authorization`` header.\n   *\n   *  To set the credentials, use the ``setCredentials`` method.\n   */\n  get credentials() {\n    return _classPrivateFieldGet(this, _creds) || null;\n  }\n  /**\n   *  Sets an ``Authorization`` for %%username%% with %%password%%.\n   */\n  setCredentials(username, password) {\n    assertArgument(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n    _classPrivateFieldSet(this, _creds, \"\".concat(username, \":\").concat(password));\n  }\n  /**\n   *  Enable and request gzip-encoded responses. The response will\n   *  automatically be decompressed. //(default: true)//\n   */\n  get allowGzip() {\n    return _classPrivateFieldGet(this, _gzip);\n  }\n  set allowGzip(value) {\n    _classPrivateFieldSet(this, _gzip, !!value);\n  }\n  /**\n   *  Allow ``Authentication`` credentials to be sent over insecure\n   *  channels. //(default: false)//\n   */\n  get allowInsecureAuthentication() {\n    return !!_classPrivateFieldGet(this, _allowInsecure);\n  }\n  set allowInsecureAuthentication(value) {\n    _classPrivateFieldSet(this, _allowInsecure, !!value);\n  }\n  /**\n   *  The timeout (in milliseconds) to wait for a complete response.\n   *  //(default: 5 minutes)//\n   */\n  get timeout() {\n    return _classPrivateFieldGet(this, _timeout);\n  }\n  set timeout(timeout) {\n    assertArgument(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n    _classPrivateFieldSet(this, _timeout, timeout);\n  }\n  /**\n   *  This function is called prior to each request, for example\n   *  during a redirection or retry in case of server throttling.\n   *\n   *  This offers an opportunity to populate headers or update\n   *  content before sending a request.\n   */\n  get preflightFunc() {\n    return _classPrivateFieldGet(this, _preflight) || null;\n  }\n  set preflightFunc(preflight) {\n    _classPrivateFieldSet(this, _preflight, preflight);\n  }\n  /**\n   *  This function is called after each response, offering an\n   *  opportunity to provide client-level throttling or updating\n   *  response data.\n   *\n   *  Any error thrown in this causes the ``send()`` to throw.\n   *\n   *  To schedule a retry attempt (assuming the maximum retry limit\n   *  has not been reached), use [[response.throwThrottleError]].\n   */\n  get processFunc() {\n    return _classPrivateFieldGet(this, _process) || null;\n  }\n  set processFunc(process) {\n    _classPrivateFieldSet(this, _process, process);\n  }\n  /**\n   *  This function is called on each retry attempt.\n   */\n  get retryFunc() {\n    return _classPrivateFieldGet(this, _retry) || null;\n  }\n  set retryFunc(retry) {\n    _classPrivateFieldSet(this, _retry, retry);\n  }\n  /**\n   *  This function is called to fetch content from HTTP and\n   *  HTTPS URLs and is platform specific (e.g. nodejs vs\n   *  browsers).\n   *\n   *  This is by default the currently registered global getUrl\n   *  function, which can be changed using [[registerGetUrl]].\n   *  If this has been set, setting is to ``null`` will cause\n   *  this FetchRequest (and any future clones) to revert back to\n   *  using the currently registered global getUrl function.\n   *\n   *  Setting this is generally not necessary, but may be useful\n   *  for developers that wish to intercept requests or to\n   *  configurege a proxy or other agent.\n   */\n  get getUrlFunc() {\n    return _classPrivateFieldGet(this, _getUrlFunc) || defaultGetUrlFunc;\n  }\n  set getUrlFunc(value) {\n    _classPrivateFieldSet(this, _getUrlFunc, value);\n  }\n  /**\n   *  Create a new FetchRequest instance with default values.\n   *\n   *  Once created, each property may be set before issuing a\n   *  ``.send()`` to make the request.\n   */\n  constructor(url) {\n    _classPrivateMethodInitSpec(this, _send);\n    _classPrivateFieldInitSpec(this, _allowInsecure, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _gzip, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _headers, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _method, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _timeout, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _url, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _body, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _bodyType, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _creds, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _preflight, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _process, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _retry, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _signal, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _throttle, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _getUrlFunc, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _url, String(url));\n    _classPrivateFieldSet(this, _allowInsecure, false);\n    _classPrivateFieldSet(this, _gzip, true);\n    _classPrivateFieldSet(this, _headers, {});\n    _classPrivateFieldSet(this, _method, \"\");\n    _classPrivateFieldSet(this, _timeout, 300000);\n    _classPrivateFieldSet(this, _throttle, {\n      slotInterval: SLOT_INTERVAL,\n      maxAttempts: MAX_ATTEMPTS\n    });\n    _classPrivateFieldSet(this, _getUrlFunc, null);\n  }\n  toString() {\n    return \"<FetchRequest method=\".concat(JSON.stringify(this.method), \" url=\").concat(JSON.stringify(this.url), \" headers=\").concat(JSON.stringify(this.headers), \" body=\").concat(_classPrivateFieldGet(this, _body) ? hexlify(_classPrivateFieldGet(this, _body)) : \"null\", \">\");\n  }\n  /**\n   *  Update the throttle parameters used to determine maximum\n   *  attempts and exponential-backoff properties.\n   */\n  setThrottleParams(params) {\n    if (params.slotInterval != null) {\n      _classPrivateFieldGet(this, _throttle).slotInterval = params.slotInterval;\n    }\n    if (params.maxAttempts != null) {\n      _classPrivateFieldGet(this, _throttle).maxAttempts = params.maxAttempts;\n    }\n  }\n  /**\n   *  Resolves to the response by sending the request.\n   */\n  send() {\n    assert(_classPrivateFieldGet(this, _signal) == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fetchRequest.send\"\n    });\n    _classPrivateFieldSet(this, _signal, new FetchCancelSignal(this));\n    return _classPrivateMethodGet(this, _send, _send2).call(this, 0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n  }\n  /**\n   *  Cancels the inflight response, causing a ``CANCELLED``\n   *  error to be rejected from the [[send]].\n   */\n  cancel() {\n    assert(_classPrivateFieldGet(this, _signal) != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fetchRequest.cancel\"\n    });\n    const signal = fetchSignals.get(this);\n    if (!signal) {\n      throw new Error(\"missing signal; should not happen\");\n    }\n    signal();\n  }\n  /**\n   *  Returns a new [[FetchRequest]] that represents the redirection\n   *  to %%location%%.\n   */\n  redirect(location) {\n    // Redirection; for now we only support absolute locations\n    const current = this.url.split(\":\")[0].toLowerCase();\n    const target = location.split(\":\")[0].toLowerCase();\n    // Don't allow redirecting:\n    // - non-GET requests\n    // - downgrading the security (e.g. https => http)\n    // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n    assert(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), \"unsupported redirect\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"redirect(\".concat(this.method, \" \").concat(JSON.stringify(this.url), \" => \").concat(JSON.stringify(location), \")\")\n    });\n    // Create a copy of this request, with a new URL\n    const req = new FetchRequest(location);\n    req.method = \"GET\";\n    req.allowGzip = this.allowGzip;\n    req.timeout = this.timeout;\n    _classPrivateFieldSet(req, _headers, Object.assign({}, _classPrivateFieldGet(this, _headers)));\n    if (_classPrivateFieldGet(this, _body)) {\n      _classPrivateFieldSet(req, _body, new Uint8Array(_classPrivateFieldGet(this, _body)));\n    }\n    _classPrivateFieldSet(req, _bodyType, _classPrivateFieldGet(this, _bodyType));\n    // Do not forward credentials unless on the same domain; only absolute\n    //req.allowInsecure = false;\n    // paths are currently supported; may want a way to specify to forward?\n    //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n    return req;\n  }\n  /**\n   *  Create a new copy of this request.\n   */\n  clone() {\n    const clone = new FetchRequest(this.url);\n    // Preserve \"default method\" (i.e. null)\n    _classPrivateFieldSet(clone, _method, _classPrivateFieldGet(this, _method));\n    // Preserve \"default body\" with type, copying the Uint8Array is present\n    if (_classPrivateFieldGet(this, _body)) {\n      _classPrivateFieldSet(clone, _body, _classPrivateFieldGet(this, _body));\n    }\n    _classPrivateFieldSet(clone, _bodyType, _classPrivateFieldGet(this, _bodyType));\n    // Preserve \"default headers\"\n    _classPrivateFieldSet(clone, _headers, Object.assign({}, _classPrivateFieldGet(this, _headers)));\n    // Credentials is readonly, so we copy internally\n    _classPrivateFieldSet(clone, _creds, _classPrivateFieldGet(this, _creds));\n    if (this.allowGzip) {\n      clone.allowGzip = true;\n    }\n    clone.timeout = this.timeout;\n    if (this.allowInsecureAuthentication) {\n      clone.allowInsecureAuthentication = true;\n    }\n    _classPrivateFieldSet(clone, _preflight, _classPrivateFieldGet(this, _preflight));\n    _classPrivateFieldSet(clone, _process, _classPrivateFieldGet(this, _process));\n    _classPrivateFieldSet(clone, _retry, _classPrivateFieldGet(this, _retry));\n    _classPrivateFieldSet(clone, _getUrlFunc, _classPrivateFieldGet(this, _getUrlFunc));\n    return clone;\n  }\n  /**\n   *  Locks all static configuration for gateways and FetchGetUrlFunc\n   *  registration.\n   */\n  static lockConfig() {\n    locked = true;\n  }\n  /**\n   *  Get the current Gateway function for %%scheme%%.\n   */\n  static getGateway(scheme) {\n    return Gateways[scheme.toLowerCase()] || null;\n  }\n  /**\n   *  Use the %%func%% when fetching URIs using %%scheme%%.\n   *\n   *  This method affects all requests globally.\n   *\n   *  If [[lockConfig]] has been called, no change is made and this\n   *  throws.\n   */\n  static registerGateway(scheme, func) {\n    scheme = scheme.toLowerCase();\n    if (scheme === \"http\" || scheme === \"https\") {\n      throw new Error(\"cannot intercept \".concat(scheme, \"; use registerGetUrl\"));\n    }\n    if (locked) {\n      throw new Error(\"gateways locked\");\n    }\n    Gateways[scheme] = func;\n  }\n  /**\n   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n   *\n   *  This method affects all requests globally.\n   *\n   *  If [[lockConfig]] has been called, no change is made and this\n   *  throws.\n   */\n  static registerGetUrl(getUrl) {\n    if (locked) {\n      throw new Error(\"gateways locked\");\n    }\n    defaultGetUrlFunc = getUrl;\n  }\n  /**\n   *  Creates a getUrl function that fetches content from HTTP and\n   *  HTTPS URLs.\n   *\n   *  The available %%options%% are dependent on the platform\n   *  implementation of the default getUrl function.\n   *\n   *  This is not generally something that is needed, but is useful\n   *  when trying to customize simple behaviour when fetching HTTP\n   *  content.\n   */\n  static createGetUrlFunc(options) {\n    return createGetUrl(options);\n  }\n  /**\n   *  Creates a function that can \"fetch\" data URIs.\n   *\n   *  Note that this is automatically done internally to support\n   *  data URIs, so it is not necessary to register it.\n   *\n   *  This is not generally something that is needed, but may\n   *  be useful in a wrapper to perfom custom data URI functionality.\n   */\n  static createDataGateway() {\n    return dataGatewayFunc;\n  }\n  /**\n   *  Creates a function that will fetch IPFS (unvalidated) from\n   *  a custom gateway baseUrl.\n   *\n   *  The default IPFS gateway used internally is\n   *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n   */\n  static createIpfsGatewayFunc(baseUrl) {\n    return getIpfsGatewayFunc(baseUrl);\n  }\n}\nasync function _send2(attempt, expires, delay, _request, _response) {\n  if (attempt >= _classPrivateFieldGet(this, _throttle).maxAttempts) {\n    return _response.makeServerError(\"exceeded maximum retry limit\");\n  }\n  assert(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n    operation: \"request.send\",\n    reason: \"timeout\",\n    request: _request\n  });\n  if (delay > 0) {\n    await wait(delay);\n  }\n  let req = this.clone();\n  const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n  // Process any Gateways\n  if (scheme in Gateways) {\n    const result = await Gateways[scheme](req.url, checkSignal(_classPrivateFieldGet(_request, _signal)));\n    if (result instanceof FetchResponse) {\n      let response = result;\n      if (this.processFunc) {\n        checkSignal(_classPrivateFieldGet(_request, _signal));\n        try {\n          response = await this.processFunc(req, response);\n        } catch (error) {\n          // Something went wrong during processing; throw a 5xx server error\n          if (error.throttle == null || typeof error.stall !== \"number\") {\n            response.makeServerError(\"error in post-processing function\", error).assertOk();\n          }\n          // Ignore throttling\n        }\n      }\n      return response;\n    }\n    req = result;\n  }\n  // We have a preflight function; update the request\n  if (this.preflightFunc) {\n    req = await this.preflightFunc(req);\n  }\n  const resp = await this.getUrlFunc(req, checkSignal(_classPrivateFieldGet(_request, _signal)));\n  let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n  if (response.statusCode === 301 || response.statusCode === 302) {\n    // Redirect\n    try {\n      var _req$redirect;\n      const location = response.headers.location || \"\";\n      return _classPrivateMethodGet(_req$redirect = req.redirect(location), _send, _send2).call(_req$redirect, attempt + 1, expires, 0, _request, response);\n    } catch (error) {}\n    // Things won't get any better on another attempt; abort\n    return response;\n  } else if (response.statusCode === 429) {\n    // Throttle\n    if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {\n      var _req$clone;\n      const retryAfter = response.headers[\"retry-after\"];\n      let delay = _classPrivateFieldGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n      if (typeof retryAfter === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n        delay = parseInt(retryAfter);\n      }\n      return _classPrivateMethodGet(_req$clone = req.clone(), _send, _send2).call(_req$clone, attempt + 1, expires, delay, _request, response);\n    }\n  }\n  if (this.processFunc) {\n    checkSignal(_classPrivateFieldGet(_request, _signal));\n    try {\n      response = await this.processFunc(req, response);\n    } catch (error) {\n      var _req$clone2;\n      // Something went wrong during processing; throw a 5xx server error\n      if (error.throttle == null || typeof error.stall !== \"number\") {\n        response.makeServerError(\"error in post-processing function\", error).assertOk();\n      }\n      // Throttle\n      let delay = _classPrivateFieldGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n      ;\n      if (error.stall >= 0) {\n        delay = error.stall;\n      }\n      return _classPrivateMethodGet(_req$clone2 = req.clone(), _send, _send2).call(_req$clone2, attempt + 1, expires, delay, _request, response);\n    }\n  }\n  return response;\n}\n;\n/**\n *  The response for a FetchRequest.\n */\nvar _statusCode = /*#__PURE__*/new WeakMap();\nvar _statusMessage = /*#__PURE__*/new WeakMap();\nvar _headers2 = /*#__PURE__*/new WeakMap();\nvar _body2 = /*#__PURE__*/new WeakMap();\nvar _request2 = /*#__PURE__*/new WeakMap();\nvar _error = /*#__PURE__*/new WeakMap();\n_Symbol$iterator2 = Symbol.iterator;\nexport class FetchResponse {\n  toString() {\n    return \"<FetchResponse status=\".concat(this.statusCode, \" body=\").concat(_classPrivateFieldGet(this, _body2) ? hexlify(_classPrivateFieldGet(this, _body2)) : \"null\", \">\");\n  }\n  /**\n   *  The response status code.\n   */\n  get statusCode() {\n    return _classPrivateFieldGet(this, _statusCode);\n  }\n  /**\n   *  The response status message.\n   */\n  get statusMessage() {\n    return _classPrivateFieldGet(this, _statusMessage);\n  }\n  /**\n   *  The response headers. All keys are lower-case.\n   */\n  get headers() {\n    return Object.assign({}, _classPrivateFieldGet(this, _headers2));\n  }\n  /**\n   *  The response body, or ``null`` if there was no body.\n   */\n  get body() {\n    return _classPrivateFieldGet(this, _body2) == null ? null : new Uint8Array(_classPrivateFieldGet(this, _body2));\n  }\n  /**\n   *  The response body as a UTF-8 encoded string, or the empty\n   *  string (i.e. ``\"\"``) if there was no body.\n   *\n   *  An error is thrown if the body is invalid UTF-8 data.\n   */\n  get bodyText() {\n    try {\n      return _classPrivateFieldGet(this, _body2) == null ? \"\" : toUtf8String(_classPrivateFieldGet(this, _body2));\n    } catch (error) {\n      assert(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"bodyText\",\n        info: {\n          response: this\n        }\n      });\n    }\n  }\n  /**\n   *  The response body, decoded as JSON.\n   *\n   *  An error is thrown if the body is invalid JSON-encoded data\n   *  or if there was no body.\n   */\n  get bodyJson() {\n    try {\n      return JSON.parse(this.bodyText);\n    } catch (error) {\n      assert(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"bodyJson\",\n        info: {\n          response: this\n        }\n      });\n    }\n  }\n  [_Symbol$iterator2]() {\n    const headers = this.headers;\n    const keys = Object.keys(headers);\n    let index = 0;\n    return {\n      next: () => {\n        if (index < keys.length) {\n          const key = keys[index++];\n          return {\n            value: [key, headers[key]],\n            done: false\n          };\n        }\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  constructor(statusCode, statusMessage, headers, body, request) {\n    _classPrivateFieldInitSpec(this, _statusCode, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _statusMessage, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _headers2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _body2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _request2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _error, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _statusCode, statusCode);\n    _classPrivateFieldSet(this, _statusMessage, statusMessage);\n    _classPrivateFieldSet(this, _headers2, Object.keys(headers).reduce((accum, k) => {\n      accum[k.toLowerCase()] = String(headers[k]);\n      return accum;\n    }, {}));\n    _classPrivateFieldSet(this, _body2, body == null ? null : new Uint8Array(body));\n    _classPrivateFieldSet(this, _request2, request || null);\n    _classPrivateFieldSet(this, _error, {\n      message: \"\"\n    });\n  }\n  /**\n   *  Return a Response with matching headers and body, but with\n   *  an error status code (i.e. 599) and %%message%% with an\n   *  optional %%error%%.\n   */\n  makeServerError(message, error) {\n    let statusMessage;\n    if (!message) {\n      message = \"\".concat(this.statusCode, \" \").concat(this.statusMessage);\n      statusMessage = \"CLIENT ESCALATED SERVER ERROR (\".concat(message, \")\");\n    } else {\n      statusMessage = \"CLIENT ESCALATED SERVER ERROR (\".concat(this.statusCode, \" \").concat(this.statusMessage, \"; \").concat(message, \")\");\n    }\n    const response = new FetchResponse(599, statusMessage, this.headers, this.body, _classPrivateFieldGet(this, _request2) || undefined);\n    _classPrivateFieldSet(response, _error, {\n      message,\n      error\n    });\n    return response;\n  }\n  /**\n   *  If called within a [request.processFunc](FetchRequest-processFunc)\n   *  call, causes the request to retry as if throttled for %%stall%%\n   *  milliseconds.\n   */\n  throwThrottleError(message, stall) {\n    if (stall == null) {\n      stall = -1;\n    } else {\n      assertArgument(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n    }\n    const error = new Error(message || \"throttling requests\");\n    defineProperties(error, {\n      stall,\n      throttle: true\n    });\n    throw error;\n  }\n  /**\n   *  Get the header value for %%key%%, ignoring case.\n   */\n  getHeader(key) {\n    return this.headers[key.toLowerCase()];\n  }\n  /**\n   *  Returns true if the response has a body.\n   */\n  hasBody() {\n    return _classPrivateFieldGet(this, _body2) != null;\n  }\n  /**\n   *  The request made for this response.\n   */\n  get request() {\n    return _classPrivateFieldGet(this, _request2);\n  }\n  /**\n   *  Returns true if this response was a success statusCode.\n   */\n  ok() {\n    return _classPrivateFieldGet(this, _error).message === \"\" && this.statusCode >= 200 && this.statusCode < 300;\n  }\n  /**\n   *  Throws a ``SERVER_ERROR`` if this response is not ok.\n   */\n  assertOk() {\n    if (this.ok()) {\n      return;\n    }\n    let {\n      message,\n      error\n    } = _classPrivateFieldGet(this, _error);\n    if (message === \"\") {\n      message = \"server response \".concat(this.statusCode, \" \").concat(this.statusMessage);\n    }\n    assert(false, message, \"SERVER_ERROR\", {\n      request: this.request || \"unknown request\",\n      response: this,\n      error\n    });\n  }\n}\nfunction getTime() {\n  return new Date().getTime();\n}\nfunction unpercent(value) {\n  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n    return String.fromCharCode(parseInt(code, 16));\n  }));\n}\nfunction wait(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay));\n}","map":{"version":3,"sources":["../../src.ts/utils/fetch.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction that each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retrieve the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentication, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */\nimport { decodeBase64, encodeBase64 } from \"./base64.js\";\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { defineProperties } from \"./properties.js\";\nimport { toUtf8Bytes, toUtf8String } from \"./utf8.js\";\nimport { createGetUrl } from \"./geturl.js\";\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nlet defaultGetUrlFunc = createGetUrl();\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs:/\\/(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nlet locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url, signal) {\n    try {\n        const match = url.match(reData);\n        if (!match) {\n            throw new Error(\"invalid data\");\n        }\n        return new FetchResponse(200, \"OK\", {\n            \"content-type\": (match[1] || \"text/plain\"),\n        }, (match[2] ? decodeBase64(match[3]) : unpercent(match[3])));\n    }\n    catch (error) {\n        return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url));\n    }\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */\nfunction getIpfsGatewayFunc(baseUrl) {\n    async function gatewayIpfs(url, signal) {\n        try {\n            const match = url.match(reIpfs);\n            if (!match) {\n                throw new Error(\"invalid link\");\n            }\n            return new FetchRequest(`${baseUrl}${match[2]}`);\n        }\n        catch (error) {\n            return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url));\n        }\n    }\n    return gatewayIpfs;\n}\nconst Gateways = {\n    \"data\": dataGatewayFunc,\n    \"ipfs\": getIpfsGatewayFunc(\"https:/\\/gateway.ipfs.io/ipfs/\")\n};\nconst fetchSignals = new WeakMap();\n/**\n *  @_ignore\n */\nexport class FetchCancelSignal {\n    #listeners;\n    #cancelled;\n    constructor(request) {\n        this.#listeners = [];\n        this.#cancelled = false;\n        fetchSignals.set(request, () => {\n            if (this.#cancelled) {\n                return;\n            }\n            this.#cancelled = true;\n            for (const listener of this.#listeners) {\n                setTimeout(() => { listener(); }, 0);\n            }\n            this.#listeners = [];\n        });\n    }\n    addListener(listener) {\n        assert(!this.#cancelled, \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchCancelSignal.addCancelListener\"\n        });\n        this.#listeners.push(listener);\n    }\n    get cancelled() { return this.#cancelled; }\n    checkSignal() {\n        assert(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n    }\n}\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n    if (signal == null) {\n        throw new Error(\"missing signal; should not happen\");\n    }\n    signal.checkSignal();\n    return signal;\n}\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */\nexport class FetchRequest {\n    #allowInsecure;\n    #gzip;\n    #headers;\n    #method;\n    #timeout;\n    #url;\n    #body;\n    #bodyType;\n    #creds;\n    // Hooks\n    #preflight;\n    #process;\n    #retry;\n    #signal;\n    #throttle;\n    #getUrlFunc;\n    /**\n     *  The fetch URL to request.\n     */\n    get url() { return this.#url; }\n    set url(url) {\n        this.#url = String(url);\n    }\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``).\n     *\n     *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrinsic ``Content-Type`` is\n     *  set to ``application/json``.\n     */\n    get body() {\n        if (this.#body == null) {\n            return null;\n        }\n        return new Uint8Array(this.#body);\n    }\n    set body(body) {\n        if (body == null) {\n            this.#body = undefined;\n            this.#bodyType = undefined;\n        }\n        else if (typeof (body) === \"string\") {\n            this.#body = toUtf8Bytes(body);\n            this.#bodyType = \"text/plain\";\n        }\n        else if (body instanceof Uint8Array) {\n            this.#body = body;\n            this.#bodyType = \"application/octet-stream\";\n        }\n        else if (typeof (body) === \"object\") {\n            this.#body = toUtf8Bytes(JSON.stringify(body));\n            this.#bodyType = \"application/json\";\n        }\n        else {\n            throw new Error(\"invalid body\");\n        }\n    }\n    /**\n     *  Returns true if the request has a body.\n     */\n    hasBody() {\n        return (this.#body != null);\n    }\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */\n    get method() {\n        if (this.#method) {\n            return this.#method;\n        }\n        if (this.hasBody()) {\n            return \"POST\";\n        }\n        return \"GET\";\n    }\n    set method(method) {\n        if (method == null) {\n            method = \"\";\n        }\n        this.#method = String(method).toUpperCase();\n    }\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any changes will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */\n    get headers() {\n        const headers = Object.assign({}, this.#headers);\n        if (this.#creds) {\n            headers[\"authorization\"] = `Basic ${encodeBase64(toUtf8Bytes(this.#creds))}`;\n        }\n        ;\n        if (this.allowGzip) {\n            headers[\"accept-encoding\"] = \"gzip\";\n        }\n        if (headers[\"content-type\"] == null && this.#bodyType) {\n            headers[\"content-type\"] = this.#bodyType;\n        }\n        if (this.body) {\n            headers[\"content-length\"] = String(this.body.length);\n        }\n        return headers;\n    }\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */\n    getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */\n    setHeader(key, value) {\n        this.#headers[String(key).toLowerCase()] = String(value);\n    }\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */\n    clearHeaders() {\n        this.#headers = {};\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: () => {\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [key, headers[key]], done: false\n                    };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */\n    get credentials() {\n        return this.#creds || null;\n    }\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */\n    setCredentials(username, password) {\n        assertArgument(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n        this.#creds = `${username}:${password}`;\n    }\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */\n    get allowGzip() {\n        return this.#gzip;\n    }\n    set allowGzip(value) {\n        this.#gzip = !!value;\n    }\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */\n    get allowInsecureAuthentication() {\n        return !!this.#allowInsecure;\n    }\n    set allowInsecureAuthentication(value) {\n        this.#allowInsecure = !!value;\n    }\n    /**\n     *  The timeout (in milliseconds) to wait for a complete response.\n     *  //(default: 5 minutes)//\n     */\n    get timeout() { return this.#timeout; }\n    set timeout(timeout) {\n        assertArgument(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n        this.#timeout = timeout;\n    }\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */\n    get preflightFunc() {\n        return this.#preflight || null;\n    }\n    set preflightFunc(preflight) {\n        this.#preflight = preflight;\n    }\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */\n    get processFunc() {\n        return this.#process || null;\n    }\n    set processFunc(process) {\n        this.#process = process;\n    }\n    /**\n     *  This function is called on each retry attempt.\n     */\n    get retryFunc() {\n        return this.#retry || null;\n    }\n    set retryFunc(retry) {\n        this.#retry = retry;\n    }\n    /**\n     *  This function is called to fetch content from HTTP and\n     *  HTTPS URLs and is platform specific (e.g. nodejs vs\n     *  browsers).\n     *\n     *  This is by default the currently registered global getUrl\n     *  function, which can be changed using [[registerGetUrl]].\n     *  If this has been set, setting is to ``null`` will cause\n     *  this FetchRequest (and any future clones) to revert back to\n     *  using the currently registered global getUrl function.\n     *\n     *  Setting this is generally not necessary, but may be useful\n     *  for developers that wish to intercept requests or to\n     *  configurege a proxy or other agent.\n     */\n    get getUrlFunc() {\n        return this.#getUrlFunc || defaultGetUrlFunc;\n    }\n    set getUrlFunc(value) {\n        this.#getUrlFunc = value;\n    }\n    /**\n     *  Create a new FetchRequest instance with default values.\n     *\n     *  Once created, each property may be set before issuing a\n     *  ``.send()`` to make the request.\n     */\n    constructor(url) {\n        this.#url = String(url);\n        this.#allowInsecure = false;\n        this.#gzip = true;\n        this.#headers = {};\n        this.#method = \"\";\n        this.#timeout = 300000;\n        this.#throttle = {\n            slotInterval: SLOT_INTERVAL,\n            maxAttempts: MAX_ATTEMPTS\n        };\n        this.#getUrlFunc = null;\n    }\n    toString() {\n        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */\n    setThrottleParams(params) {\n        if (params.slotInterval != null) {\n            this.#throttle.slotInterval = params.slotInterval;\n        }\n        if (params.maxAttempts != null) {\n            this.#throttle.maxAttempts = params.maxAttempts;\n        }\n    }\n    async #send(attempt, expires, delay, _request, _response) {\n        if (attempt >= this.#throttle.maxAttempts) {\n            return _response.makeServerError(\"exceeded maximum retry limit\");\n        }\n        assert(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n            operation: \"request.send\", reason: \"timeout\", request: _request\n        });\n        if (delay > 0) {\n            await wait(delay);\n        }\n        let req = this.clone();\n        const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n        // Process any Gateways\n        if (scheme in Gateways) {\n            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));\n            if (result instanceof FetchResponse) {\n                let response = result;\n                if (this.processFunc) {\n                    checkSignal(_request.#signal);\n                    try {\n                        response = await this.processFunc(req, response);\n                    }\n                    catch (error) {\n                        // Something went wrong during processing; throw a 5xx server error\n                        if (error.throttle == null || typeof (error.stall) !== \"number\") {\n                            response.makeServerError(\"error in post-processing function\", error).assertOk();\n                        }\n                        // Ignore throttling\n                    }\n                }\n                return response;\n            }\n            req = result;\n        }\n        // We have a preflight function; update the request\n        if (this.preflightFunc) {\n            req = await this.preflightFunc(req);\n        }\n        const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));\n        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n        if (response.statusCode === 301 || response.statusCode === 302) {\n            // Redirect\n            try {\n                const location = response.headers.location || \"\";\n                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);\n            }\n            catch (error) { }\n            // Things won't get any better on another attempt; abort\n            return response;\n        }\n        else if (response.statusCode === 429) {\n            // Throttle\n            if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {\n                const retryAfter = response.headers[\"retry-after\"];\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                if (typeof (retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                    delay = parseInt(retryAfter);\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        if (this.processFunc) {\n            checkSignal(_request.#signal);\n            try {\n                response = await this.processFunc(req, response);\n            }\n            catch (error) {\n                // Something went wrong during processing; throw a 5xx server error\n                if (error.throttle == null || typeof (error.stall) !== \"number\") {\n                    response.makeServerError(\"error in post-processing function\", error).assertOk();\n                }\n                // Throttle\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                ;\n                if (error.stall >= 0) {\n                    delay = error.stall;\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        return response;\n    }\n    /**\n     *  Resolves to the response by sending the request.\n     */\n    send() {\n        assert(this.#signal == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.send\" });\n        this.#signal = new FetchCancelSignal(this);\n        return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n    }\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */\n    cancel() {\n        assert(this.#signal != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.cancel\" });\n        const signal = fetchSignals.get(this);\n        if (!signal) {\n            throw new Error(\"missing signal; should not happen\");\n        }\n        signal();\n    }\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */\n    redirect(location) {\n        // Redirection; for now we only support absolute locations\n        const current = this.url.split(\":\")[0].toLowerCase();\n        const target = location.split(\":\")[0].toLowerCase();\n        // Don't allow redirecting:\n        // - non-GET requests\n        // - downgrading the security (e.g. https => http)\n        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n        assert(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), `unsupported redirect`, \"UNSUPPORTED_OPERATION\", {\n            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`\n        });\n        // Create a copy of this request, with a new URL\n        const req = new FetchRequest(location);\n        req.method = \"GET\";\n        req.allowGzip = this.allowGzip;\n        req.timeout = this.timeout;\n        req.#headers = Object.assign({}, this.#headers);\n        if (this.#body) {\n            req.#body = new Uint8Array(this.#body);\n        }\n        req.#bodyType = this.#bodyType;\n        // Do not forward credentials unless on the same domain; only absolute\n        //req.allowInsecure = false;\n        // paths are currently supported; may want a way to specify to forward?\n        //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n        return req;\n    }\n    /**\n     *  Create a new copy of this request.\n     */\n    clone() {\n        const clone = new FetchRequest(this.url);\n        // Preserve \"default method\" (i.e. null)\n        clone.#method = this.#method;\n        // Preserve \"default body\" with type, copying the Uint8Array is present\n        if (this.#body) {\n            clone.#body = this.#body;\n        }\n        clone.#bodyType = this.#bodyType;\n        // Preserve \"default headers\"\n        clone.#headers = Object.assign({}, this.#headers);\n        // Credentials is readonly, so we copy internally\n        clone.#creds = this.#creds;\n        if (this.allowGzip) {\n            clone.allowGzip = true;\n        }\n        clone.timeout = this.timeout;\n        if (this.allowInsecureAuthentication) {\n            clone.allowInsecureAuthentication = true;\n        }\n        clone.#preflight = this.#preflight;\n        clone.#process = this.#process;\n        clone.#retry = this.#retry;\n        clone.#getUrlFunc = this.#getUrlFunc;\n        return clone;\n    }\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */\n    static lockConfig() {\n        locked = true;\n    }\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */\n    static getGateway(scheme) {\n        return Gateways[scheme.toLowerCase()] || null;\n    }\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n    static registerGateway(scheme, func) {\n        scheme = scheme.toLowerCase();\n        if (scheme === \"http\" || scheme === \"https\") {\n            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);\n        }\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        Gateways[scheme] = func;\n    }\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n    static registerGetUrl(getUrl) {\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        defaultGetUrlFunc = getUrl;\n    }\n    /**\n     *  Creates a getUrl function that fetches content from HTTP and\n     *  HTTPS URLs.\n     *\n     *  The available %%options%% are dependent on the platform\n     *  implementation of the default getUrl function.\n     *\n     *  This is not generally something that is needed, but is useful\n     *  when trying to customize simple behaviour when fetching HTTP\n     *  content.\n     */\n    static createGetUrlFunc(options) {\n        return createGetUrl(options);\n    }\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */\n    static createDataGateway() {\n        return dataGatewayFunc;\n    }\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */\n    static createIpfsGatewayFunc(baseUrl) {\n        return getIpfsGatewayFunc(baseUrl);\n    }\n}\n;\n/**\n *  The response for a FetchRequest.\n */\nexport class FetchResponse {\n    #statusCode;\n    #statusMessage;\n    #headers;\n    #body;\n    #request;\n    #error;\n    toString() {\n        return `<FetchResponse status=${this.statusCode} body=${this.#body ? hexlify(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  The response status code.\n     */\n    get statusCode() { return this.#statusCode; }\n    /**\n     *  The response status message.\n     */\n    get statusMessage() { return this.#statusMessage; }\n    /**\n     *  The response headers. All keys are lower-case.\n     */\n    get headers() { return Object.assign({}, this.#headers); }\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */\n    get body() {\n        return (this.#body == null) ? null : new Uint8Array(this.#body);\n    }\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */\n    get bodyText() {\n        try {\n            return (this.#body == null) ? \"\" : toUtf8String(this.#body);\n        }\n        catch (error) {\n            assert(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyText\", info: { response: this }\n            });\n        }\n    }\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */\n    get bodyJson() {\n        try {\n            return JSON.parse(this.bodyText);\n        }\n        catch (error) {\n            assert(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyJson\", info: { response: this }\n            });\n        }\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: () => {\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [key, headers[key]], done: false\n                    };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    constructor(statusCode, statusMessage, headers, body, request) {\n        this.#statusCode = statusCode;\n        this.#statusMessage = statusMessage;\n        this.#headers = Object.keys(headers).reduce((accum, k) => {\n            accum[k.toLowerCase()] = String(headers[k]);\n            return accum;\n        }, {});\n        this.#body = ((body == null) ? null : new Uint8Array(body));\n        this.#request = (request || null);\n        this.#error = { message: \"\" };\n    }\n    /**\n     *  Return a Response with matching headers and body, but with\n     *  an error status code (i.e. 599) and %%message%% with an\n     *  optional %%error%%.\n     */\n    makeServerError(message, error) {\n        let statusMessage;\n        if (!message) {\n            message = `${this.statusCode} ${this.statusMessage}`;\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;\n        }\n        else {\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;\n        }\n        const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);\n        response.#error = { message, error };\n        return response;\n    }\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */\n    throwThrottleError(message, stall) {\n        if (stall == null) {\n            stall = -1;\n        }\n        else {\n            assertArgument(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n        }\n        const error = new Error(message || \"throttling requests\");\n        defineProperties(error, { stall, throttle: true });\n        throw error;\n    }\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */\n    getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Returns true if the response has a body.\n     */\n    hasBody() {\n        return (this.#body != null);\n    }\n    /**\n     *  The request made for this response.\n     */\n    get request() { return this.#request; }\n    /**\n     *  Returns true if this response was a success statusCode.\n     */\n    ok() {\n        return (this.#error.message === \"\" && this.statusCode >= 200 && this.statusCode < 300);\n    }\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */\n    assertOk() {\n        if (this.ok()) {\n            return;\n        }\n        let { message, error } = this.#error;\n        if (message === \"\") {\n            message = `server response ${this.statusCode} ${this.statusMessage}`;\n        }\n        assert(false, message, \"SERVER_ERROR\", {\n            request: (this.request || \"unknown request\"), response: this, error\n        });\n    }\n}\nfunction getTime() { return (new Date()).getTime(); }\nfunction unpercent(value) {\n    return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\nfunction wait(delay) {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n}\n//# sourceMappingURL=fetch.js.map"]},"metadata":{},"sourceType":"module"}