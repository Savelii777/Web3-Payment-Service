{"ast":null,"code":"/**\n *  @_ignore\n */\nimport { getBytesCopy, assertArgument, toUtf8Bytes } from \"../utils/index.js\";\nexport function looseArrayify(hexString) {\n  if (typeof hexString === \"string\" && !hexString.startsWith(\"0x\")) {\n    hexString = \"0x\" + hexString;\n  }\n  return getBytesCopy(hexString);\n}\nexport function zpad(value, length) {\n  value = String(value);\n  while (value.length < length) {\n    value = '0' + value;\n  }\n  return value;\n}\nexport function getPassword(password) {\n  if (typeof password === 'string') {\n    return toUtf8Bytes(password, \"NFKC\");\n  }\n  return getBytesCopy(password);\n}\nexport function spelunk(object, _path) {\n  const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);\n  assertArgument(match != null, \"invalid path\", \"path\", _path);\n  const path = match[1];\n  const type = match[3];\n  const reqd = match[4] === \"!\";\n  let cur = object;\n  for (const comp of path.toLowerCase().split('.')) {\n    // Search for a child object with a case-insensitive matching key\n    if (Array.isArray(cur)) {\n      if (!comp.match(/^[0-9]+$/)) {\n        break;\n      }\n      cur = cur[parseInt(comp)];\n    } else if (typeof cur === \"object\") {\n      let found = null;\n      for (const key in cur) {\n        if (key.toLowerCase() === comp) {\n          found = cur[key];\n          break;\n        }\n      }\n      cur = found;\n    } else {\n      cur = null;\n    }\n    if (cur == null) {\n      break;\n    }\n  }\n  assertArgument(!reqd || cur != null, \"missing required value\", \"path\", path);\n  if (type && cur != null) {\n    if (type === \"int\") {\n      if (typeof cur === \"string\" && cur.match(/^-?[0-9]+$/)) {\n        return parseInt(cur);\n      } else if (Number.isSafeInteger(cur)) {\n        return cur;\n      }\n    }\n    if (type === \"number\") {\n      if (typeof cur === \"string\" && cur.match(/^-?[0-9.]*$/)) {\n        return parseFloat(cur);\n      }\n    }\n    if (type === \"data\") {\n      if (typeof cur === \"string\") {\n        return looseArrayify(cur);\n      }\n    }\n    if (type === \"array\" && Array.isArray(cur)) {\n      return cur;\n    }\n    if (type === typeof cur) {\n      return cur;\n    }\n    assertArgument(false, \"wrong type found for \".concat(type, \" \"), \"path\", path);\n  }\n  return cur;\n}\n/*\nexport function follow(object: any, path: string): null | string {\n    let currentChild = object;\n\n    for (const comp of path.toLowerCase().split('/')) {\n\n        // Search for a child object with a case-insensitive matching key\n        let matchingChild = null;\n        for (const key in currentChild) {\n             if (key.toLowerCase() === comp) {\n                 matchingChild = currentChild[key];\n                 break;\n             }\n        }\n\n        if (matchingChild === null) { return null; }\n\n        currentChild = matchingChild;\n    }\n\n    return currentChild;\n}\n\n// \"path/to/something:type!\"\nexport function followRequired(data: any, path: string): string {\n    const value = follow(data, path);\n    if (value != null) { return value; }\n    return logger.throwArgumentError(\"invalid value\", `data:${ path }`,\n    JSON.stringify(data));\n}\n*/\n// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n/*\nexport function uuidV4(randomBytes: BytesLike): string {\n    const bytes = getBytes(randomBytes, \"randomBytes\");\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    const value = hexlify(bytes);\n\n    return [\n       value.substring(2, 10),\n       value.substring(10, 14),\n       value.substring(14, 18),\n       value.substring(18, 22),\n       value.substring(22, 34),\n    ].join(\"-\");\n}\n*/","map":{"version":3,"sources":["../../src.ts/wallet/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n *  @_ignore\n */\nimport { getBytesCopy, assertArgument, toUtf8Bytes } from \"../utils/index.js\";\nexport function looseArrayify(hexString) {\n    if (typeof (hexString) === \"string\" && !hexString.startsWith(\"0x\")) {\n        hexString = \"0x\" + hexString;\n    }\n    return getBytesCopy(hexString);\n}\nexport function zpad(value, length) {\n    value = String(value);\n    while (value.length < length) {\n        value = '0' + value;\n    }\n    return value;\n}\nexport function getPassword(password) {\n    if (typeof (password) === 'string') {\n        return toUtf8Bytes(password, \"NFKC\");\n    }\n    return getBytesCopy(password);\n}\nexport function spelunk(object, _path) {\n    const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);\n    assertArgument(match != null, \"invalid path\", \"path\", _path);\n    const path = match[1];\n    const type = match[3];\n    const reqd = (match[4] === \"!\");\n    let cur = object;\n    for (const comp of path.toLowerCase().split('.')) {\n        // Search for a child object with a case-insensitive matching key\n        if (Array.isArray(cur)) {\n            if (!comp.match(/^[0-9]+$/)) {\n                break;\n            }\n            cur = cur[parseInt(comp)];\n        }\n        else if (typeof (cur) === \"object\") {\n            let found = null;\n            for (const key in cur) {\n                if (key.toLowerCase() === comp) {\n                    found = cur[key];\n                    break;\n                }\n            }\n            cur = found;\n        }\n        else {\n            cur = null;\n        }\n        if (cur == null) {\n            break;\n        }\n    }\n    assertArgument(!reqd || cur != null, \"missing required value\", \"path\", path);\n    if (type && cur != null) {\n        if (type === \"int\") {\n            if (typeof (cur) === \"string\" && cur.match(/^-?[0-9]+$/)) {\n                return parseInt(cur);\n            }\n            else if (Number.isSafeInteger(cur)) {\n                return cur;\n            }\n        }\n        if (type === \"number\") {\n            if (typeof (cur) === \"string\" && cur.match(/^-?[0-9.]*$/)) {\n                return parseFloat(cur);\n            }\n        }\n        if (type === \"data\") {\n            if (typeof (cur) === \"string\") {\n                return looseArrayify(cur);\n            }\n        }\n        if (type === \"array\" && Array.isArray(cur)) {\n            return cur;\n        }\n        if (type === typeof (cur)) {\n            return cur;\n        }\n        assertArgument(false, `wrong type found for ${type} `, \"path\", path);\n    }\n    return cur;\n}\n/*\nexport function follow(object: any, path: string): null | string {\n    let currentChild = object;\n\n    for (const comp of path.toLowerCase().split('/')) {\n\n        // Search for a child object with a case-insensitive matching key\n        let matchingChild = null;\n        for (const key in currentChild) {\n             if (key.toLowerCase() === comp) {\n                 matchingChild = currentChild[key];\n                 break;\n             }\n        }\n\n        if (matchingChild === null) { return null; }\n\n        currentChild = matchingChild;\n    }\n\n    return currentChild;\n}\n\n// \"path/to/something:type!\"\nexport function followRequired(data: any, path: string): string {\n    const value = follow(data, path);\n    if (value != null) { return value; }\n    return logger.throwArgumentError(\"invalid value\", `data:${ path }`,\n    JSON.stringify(data));\n}\n*/\n// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n/*\nexport function uuidV4(randomBytes: BytesLike): string {\n    const bytes = getBytes(randomBytes, \"randomBytes\");\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    const value = hexlify(bytes);\n\n    return [\n       value.substring(2, 10),\n       value.substring(10, 14),\n       value.substring(14, 18),\n       value.substring(18, 22),\n       value.substring(22, 34),\n    ].join(\"-\");\n}\n*/\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}