{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _defineProperty from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateMethodGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldSet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _classPrivateFieldGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\nimport { getAddress } from \"../address/index.js\";\nimport { keccak256 } from \"../crypto/index.js\";\nimport { recoverAddress } from \"../transaction/index.js\";\nimport { concat, defineProperties, getBigInt, getBytes, hexlify, isHexString, mask, toBeHex, toQuantity, toTwos, zeroPadValue, assertArgument } from \"../utils/index.js\";\nimport { id } from \"./id.js\";\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n  const bytes = getBytes(value);\n  const padOffset = bytes.length % 32;\n  if (padOffset) {\n    return concat([bytes, padding.slice(padOffset)]);\n  }\n  return hexlify(bytes);\n}\nconst hexTrue = toBeHex(BN_1, 32);\nconst hexFalse = toBeHex(BN_0, 32);\nconst domainFieldTypes = {\n  name: \"string\",\n  version: \"string\",\n  chainId: \"uint256\",\n  verifyingContract: \"address\",\n  salt: \"bytes32\"\n};\nconst domainFieldNames = [\"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"];\nfunction checkString(key) {\n  return function (value) {\n    assertArgument(typeof value === \"string\", \"invalid domain value for \".concat(JSON.stringify(key)), \"domain.\".concat(key), value);\n    return value;\n  };\n}\nconst domainChecks = {\n  name: checkString(\"name\"),\n  version: checkString(\"version\"),\n  chainId: function (_value) {\n    const value = getBigInt(_value, \"domain.chainId\");\n    assertArgument(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n    if (Number.isSafeInteger(value)) {\n      return Number(value);\n    }\n    return toQuantity(value);\n  },\n  verifyingContract: function (value) {\n    try {\n      return getAddress(value).toLowerCase();\n    } catch (error) {}\n    assertArgument(false, \"invalid domain value \\\"verifyingContract\\\"\", \"domain.verifyingContract\", value);\n  },\n  salt: function (value) {\n    const bytes = getBytes(value, \"domain.salt\");\n    assertArgument(bytes.length === 32, \"invalid domain value \\\"salt\\\"\", \"domain.salt\", value);\n    return hexlify(bytes);\n  }\n};\nfunction getBaseEncoder(type) {\n  // intXX and uintXX\n  {\n    const match = type.match(/^(u?)int(\\d*)$/);\n    if (match) {\n      const signed = match[1] === \"\";\n      const width = parseInt(match[2] || \"256\");\n      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), \"invalid numeric width\", \"type\", type);\n      const boundsUpper = mask(BN_MAX_UINT256, signed ? width - 1 : width);\n      const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;\n      return function (_value) {\n        const value = getBigInt(_value, \"value\");\n        assertArgument(value >= boundsLower && value <= boundsUpper, \"value out-of-bounds for \".concat(type), \"value\", value);\n        return toBeHex(signed ? toTwos(value, 256) : value, 32);\n      };\n    }\n  }\n  // bytesXX\n  {\n    const match = type.match(/^bytes(\\d+)$/);\n    if (match) {\n      const width = parseInt(match[1]);\n      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n      return function (value) {\n        const bytes = getBytes(value);\n        assertArgument(bytes.length === width, \"invalid length for \".concat(type), \"value\", value);\n        return hexPadRight(value);\n      };\n    }\n  }\n  switch (type) {\n    case \"address\":\n      return function (value) {\n        return zeroPadValue(getAddress(value), 32);\n      };\n    case \"bool\":\n      return function (value) {\n        return !value ? hexFalse : hexTrue;\n      };\n    case \"bytes\":\n      return function (value) {\n        return keccak256(value);\n      };\n    case \"string\":\n      return function (value) {\n        return id(value);\n      };\n  }\n  return null;\n}\nfunction encodeType(name, fields) {\n  return \"\".concat(name, \"(\").concat(fields.map(_ref => {\n    let {\n      name,\n      type\n    } = _ref;\n    return type + \" \" + name;\n  }).join(\",\"), \")\");\n}\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */\nvar _types = /*#__PURE__*/new WeakMap();\nvar _fullTypes = /*#__PURE__*/new WeakMap();\nvar _encoderCache = /*#__PURE__*/new WeakMap();\nvar _getEncoder = /*#__PURE__*/new WeakSet();\nexport class TypedDataEncoder {\n  /**\n   *  The primary type for the structured [[types]].\n   *\n   *  This is derived automatically from the [[types]], since no\n   *  recursion is possible, once the DAG for the types is consturcted\n   *  internally, the primary type must be the only remaining type with\n   *  no parent nodes.\n   */\n\n  /**\n   *  The types.\n   */\n  get types() {\n    return JSON.parse(_classPrivateFieldGet(this, _types));\n  }\n  /**\n   *  Create a new **TypedDataEncoder** for %%types%%.\n   *\n   *  This performs all necessary checking that types are valid and\n   *  do not violate the [[link-eip-712]] structural constraints as\n   *  well as computes the [[primaryType]].\n   */\n  constructor(types) {\n    _classPrivateMethodInitSpec(this, _getEncoder);\n    _defineProperty(this, \"primaryType\", void 0);\n    _classPrivateFieldInitSpec(this, _types, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _fullTypes, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _encoderCache, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _types, JSON.stringify(types));\n    _classPrivateFieldSet(this, _fullTypes, new Map());\n    _classPrivateFieldSet(this, _encoderCache, new Map());\n    // Link struct types to their direct child structs\n    const links = new Map();\n    // Link structs to structs which contain them as a child\n    const parents = new Map();\n    // Link all subtypes within a given struct\n    const subtypes = new Map();\n    Object.keys(types).forEach(type => {\n      links.set(type, new Set());\n      parents.set(type, []);\n      subtypes.set(type, new Set());\n    });\n    for (const name in types) {\n      const uniqueNames = new Set();\n      for (const field of types[name]) {\n        // Check each field has a unique name\n        assertArgument(!uniqueNames.has(field.name), \"duplicate variable name \".concat(JSON.stringify(field.name), \" in \").concat(JSON.stringify(name)), \"types\", types);\n        uniqueNames.add(field.name);\n        // Get the base type (drop any array specifiers)\n        const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1] || null;\n        assertArgument(baseType !== name, \"circular type reference to \".concat(JSON.stringify(baseType)), \"types\", types);\n        // Is this a base encoding type?\n        const encoder = getBaseEncoder(baseType);\n        if (encoder) {\n          continue;\n        }\n        assertArgument(parents.has(baseType), \"unknown type \".concat(JSON.stringify(baseType)), \"types\", types);\n        // Add linkage\n        parents.get(baseType).push(name);\n        links.get(name).add(baseType);\n      }\n    }\n    // Deduce the primary type\n    const primaryTypes = Array.from(parents.keys()).filter(n => parents.get(n).length === 0);\n    assertArgument(primaryTypes.length !== 0, \"missing primary type\", \"types\", types);\n    assertArgument(primaryTypes.length === 1, \"ambiguous primary types or unused types: \".concat(primaryTypes.map(t => JSON.stringify(t)).join(\", \")), \"types\", types);\n    defineProperties(this, {\n      primaryType: primaryTypes[0]\n    });\n    // Check for circular type references\n    function checkCircular(type, found) {\n      assertArgument(!found.has(type), \"circular type reference to \".concat(JSON.stringify(type)), \"types\", types);\n      found.add(type);\n      for (const child of links.get(type)) {\n        if (!parents.has(child)) {\n          continue;\n        }\n        // Recursively check children\n        checkCircular(child, found);\n        // Mark all ancestors as having this decendant\n        for (const subtype of found) {\n          subtypes.get(subtype).add(child);\n        }\n      }\n      found.delete(type);\n    }\n    checkCircular(this.primaryType, new Set());\n    // Compute each fully describe type\n    for (const [name, set] of subtypes) {\n      const st = Array.from(set);\n      st.sort();\n      _classPrivateFieldGet(this, _fullTypes).set(name, encodeType(name, types[name]) + st.map(t => encodeType(t, types[t])).join(\"\"));\n    }\n  }\n  /**\n   *  Returnthe encoder for the specific %%type%%.\n   */\n  getEncoder(type) {\n    let encoder = _classPrivateFieldGet(this, _encoderCache).get(type);\n    if (!encoder) {\n      encoder = _classPrivateMethodGet(this, _getEncoder, _getEncoder2).call(this, type);\n      _classPrivateFieldGet(this, _encoderCache).set(type, encoder);\n    }\n    return encoder;\n  }\n  /**\n   *  Return the full type for %%name%%.\n   */\n  encodeType(name) {\n    const result = _classPrivateFieldGet(this, _fullTypes).get(name);\n    assertArgument(result, \"unknown type: \".concat(JSON.stringify(name)), \"name\", name);\n    return result;\n  }\n  /**\n   *  Return the encoded %%value%% for the %%type%%.\n   */\n  encodeData(type, value) {\n    return this.getEncoder(type)(value);\n  }\n  /**\n   *  Returns the hash of %%value%% for the type of %%name%%.\n   */\n  hashStruct(name, value) {\n    return keccak256(this.encodeData(name, value));\n  }\n  /**\n   *  Return the fulled encoded %%value%% for the [[types]].\n   */\n  encode(value) {\n    return this.encodeData(this.primaryType, value);\n  }\n  /**\n   *  Return the hash of the fully encoded %%value%% for the [[types]].\n   */\n  hash(value) {\n    return this.hashStruct(this.primaryType, value);\n  }\n  /**\n   *  @_ignore:\n   */\n  _visit(type, value, callback) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n      const encoder = getBaseEncoder(type);\n      if (encoder) {\n        return callback(type, value);\n      }\n    }\n    // Array\n    const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n    if (match) {\n      assertArgument(!match[3] || parseInt(match[3]) === value.length, \"array length mismatch; expected length \".concat(parseInt(match[3])), \"value\", value);\n      return value.map(v => this._visit(match[1], v, callback));\n    }\n    // Struct\n    const fields = this.types[type];\n    if (fields) {\n      return fields.reduce((accum, _ref2) => {\n        let {\n          name,\n          type\n        } = _ref2;\n        accum[name] = this._visit(type, value[name], callback);\n        return accum;\n      }, {});\n    }\n    assertArgument(false, \"unknown type: \".concat(type), \"type\", type);\n  }\n  /**\n   *  Call %%calback%% for each value in %%value%%, passing the type and\n   *  component within %%value%%.\n   *\n   *  This is useful for replacing addresses or other transformation that\n   *  may be desired on each component, based on its type.\n   */\n  visit(value, callback) {\n    return this._visit(this.primaryType, value, callback);\n  }\n  /**\n   *  Create a new **TypedDataEncoder** for %%types%%.\n   */\n  static from(types) {\n    return new TypedDataEncoder(types);\n  }\n  /**\n   *  Return the primary type for %%types%%.\n   */\n  static getPrimaryType(types) {\n    return TypedDataEncoder.from(types).primaryType;\n  }\n  /**\n   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n   */\n  static hashStruct(name, types, value) {\n    return TypedDataEncoder.from(types).hashStruct(name, value);\n  }\n  /**\n   *  Return the domain hash for %%domain%%.\n   */\n  static hashDomain(domain) {\n    const domainFields = [];\n    for (const name in domain) {\n      if (domain[name] == null) {\n        continue;\n      }\n      const type = domainFieldTypes[name];\n      assertArgument(type, \"invalid typed-data domain key: \".concat(JSON.stringify(name)), \"domain\", domain);\n      domainFields.push({\n        name,\n        type\n      });\n    }\n    domainFields.sort((a, b) => {\n      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n    });\n    return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n      EIP712Domain: domainFields\n    }, domain);\n  }\n  /**\n   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n   */\n  static encode(domain, types, value) {\n    return concat([\"0x1901\", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);\n  }\n  /**\n   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n   */\n  static hash(domain, types, value) {\n    return keccak256(TypedDataEncoder.encode(domain, types, value));\n  }\n  // Replaces all address types with ENS names with their looked up address\n  /**\n   * Resolves to the value from resolving all addresses in %%value%% for\n   * %%types%% and the %%domain%%.\n   */\n  static async resolveNames(domain, types, value, resolveName) {\n    // Make a copy to isolate it from the object passed in\n    domain = Object.assign({}, domain);\n    // Allow passing null to ignore value\n    for (const key in domain) {\n      if (domain[key] == null) {\n        delete domain[key];\n      }\n    }\n    // Look up all ENS names\n    const ensCache = {};\n    // Do we need to look up the domain's verifyingContract?\n    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n      ensCache[domain.verifyingContract] = \"0x\";\n    }\n    // We are going to use the encoder to visit all the base values\n    const encoder = TypedDataEncoder.from(types);\n    // Get a list of all the addresses\n    encoder.visit(value, (type, value) => {\n      if (type === \"address\" && !isHexString(value, 20)) {\n        ensCache[value] = \"0x\";\n      }\n      return value;\n    });\n    // Lookup each name\n    for (const name in ensCache) {\n      ensCache[name] = await resolveName(name);\n    }\n    // Replace the domain verifyingContract if needed\n    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n      domain.verifyingContract = ensCache[domain.verifyingContract];\n    }\n    // Replace all ENS names with their address\n    value = encoder.visit(value, (type, value) => {\n      if (type === \"address\" && ensCache[value]) {\n        return ensCache[value];\n      }\n      return value;\n    });\n    return {\n      domain,\n      value\n    };\n  }\n  /**\n   *  Returns the JSON-encoded payload expected by nodes which implement\n   *  the JSON-RPC [[link-eip-712]] method.\n   */\n  static getPayload(domain, types, value) {\n    // Validate the domain fields\n    TypedDataEncoder.hashDomain(domain);\n    // Derive the EIP712Domain Struct reference type\n    const domainValues = {};\n    const domainTypes = [];\n    domainFieldNames.forEach(name => {\n      const value = domain[name];\n      if (value == null) {\n        return;\n      }\n      domainValues[name] = domainChecks[name](value);\n      domainTypes.push({\n        name,\n        type: domainFieldTypes[name]\n      });\n    });\n    const encoder = TypedDataEncoder.from(types);\n    const typesWithDomain = Object.assign({}, types);\n    assertArgument(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n    typesWithDomain.EIP712Domain = domainTypes;\n    // Validate the data structures and types\n    encoder.encode(value);\n    return {\n      types: typesWithDomain,\n      domain: domainValues,\n      primaryType: encoder.primaryType,\n      message: encoder.visit(value, (type, value) => {\n        // bytes\n        if (type.match(/^bytes(\\d*)/)) {\n          return hexlify(getBytes(value));\n        }\n        // uint or int\n        if (type.match(/^u?int/)) {\n          return getBigInt(value).toString();\n        }\n        switch (type) {\n          case \"address\":\n            return value.toLowerCase();\n          case \"bool\":\n            return !!value;\n          case \"string\":\n            assertArgument(typeof value === \"string\", \"invalid string\", \"value\", value);\n            return value;\n        }\n        assertArgument(false, \"unsupported type\", \"type\", type);\n      })\n    };\n  }\n}\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */\nfunction _getEncoder2(type) {\n  // Basic encoder type (address, bool, uint256, etc)\n  {\n    const encoder = getBaseEncoder(type);\n    if (encoder) {\n      return encoder;\n    }\n  }\n  // Array\n  const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n  if (match) {\n    const subtype = match[1];\n    const subEncoder = this.getEncoder(subtype);\n    return value => {\n      assertArgument(!match[3] || parseInt(match[3]) === value.length, \"array length mismatch; expected length \".concat(parseInt(match[3])), \"value\", value);\n      let result = value.map(subEncoder);\n      if (_classPrivateFieldGet(this, _fullTypes).has(subtype)) {\n        result = result.map(keccak256);\n      }\n      return keccak256(concat(result));\n    };\n  }\n  // Struct\n  const fields = this.types[type];\n  if (fields) {\n    const encodedType = id(_classPrivateFieldGet(this, _fullTypes).get(type));\n    return value => {\n      const values = fields.map(_ref3 => {\n        let {\n          name,\n          type\n        } = _ref3;\n        const result = this.getEncoder(type)(value[name]);\n        if (_classPrivateFieldGet(this, _fullTypes).has(type)) {\n          return keccak256(result);\n        }\n        return result;\n      });\n      values.unshift(encodedType);\n      return concat(values);\n    };\n  }\n  assertArgument(false, \"unknown type: \".concat(type), \"type\", type);\n}\nexport function verifyTypedData(domain, types, value, signature) {\n  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);\n}","map":{"version":3,"sources":["../../src.ts/hash/typed-data.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\nimport { getAddress } from \"../address/index.js\";\nimport { keccak256 } from \"../crypto/index.js\";\nimport { recoverAddress } from \"../transaction/index.js\";\nimport { concat, defineProperties, getBigInt, getBytes, hexlify, isHexString, mask, toBeHex, toQuantity, toTwos, zeroPadValue, assertArgument } from \"../utils/index.js\";\nimport { id } from \"./id.js\";\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n    const bytes = getBytes(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return concat([bytes, padding.slice(padOffset)]);\n    }\n    return hexlify(bytes);\n}\nconst hexTrue = toBeHex(BN_1, 32);\nconst hexFalse = toBeHex(BN_0, 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        assertArgument(typeof (value) === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (_value) {\n        const value = getBigInt(_value, \"domain.chainId\");\n        assertArgument(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n        if (Number.isSafeInteger(value)) {\n            return Number(value);\n        }\n        return toQuantity(value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return getAddress(value).toLowerCase();\n        }\n        catch (error) { }\n        assertArgument(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        const bytes = getBytes(value, \"domain.salt\");\n        assertArgument(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n        return hexlify(bytes);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n            const width = parseInt(match[2] || \"256\");\n            assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), \"invalid numeric width\", \"type\", type);\n            const boundsUpper = mask(BN_MAX_UINT256, signed ? (width - 1) : width);\n            const boundsLower = signed ? ((boundsUpper + BN_1) * BN__1) : BN_0;\n            return function (_value) {\n                const value = getBigInt(_value, \"value\");\n                assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\n                return toBeHex(signed ? toTwos(value, 256) : value, 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            assertArgument(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n            return function (value) {\n                const bytes = getBytes(value);\n                assertArgument(bytes.length === width, `invalid length for ${type}`, \"value\", value);\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return zeroPadValue(getAddress(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return keccak256(value);\n        };\n        case \"string\": return function (value) {\n            return id(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\n}\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */\nexport class TypedDataEncoder {\n    /**\n     *  The primary type for the structured [[types]].\n     *\n     *  This is derived automatically from the [[types]], since no\n     *  recursion is possible, once the DAG for the types is consturcted\n     *  internally, the primary type must be the only remaining type with\n     *  no parent nodes.\n     */\n    primaryType;\n    #types;\n    /**\n     *  The types.\n     */\n    get types() {\n        return JSON.parse(this.#types);\n    }\n    #fullTypes;\n    #encoderCache;\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     *\n     *  This performs all necessary checking that types are valid and\n     *  do not violate the [[link-eip-712]] structural constraints as\n     *  well as computes the [[primaryType]].\n     */\n    constructor(types) {\n        this.#types = JSON.stringify(types);\n        this.#fullTypes = new Map();\n        this.#encoderCache = new Map();\n        // Link struct types to their direct child structs\n        const links = new Map();\n        // Link structs to structs which contain them as a child\n        const parents = new Map();\n        // Link all subtypes within a given struct\n        const subtypes = new Map();\n        Object.keys(types).forEach((type) => {\n            links.set(type, new Set());\n            parents.set(type, []);\n            subtypes.set(type, new Set());\n        });\n        for (const name in types) {\n            const uniqueNames = new Set();\n            for (const field of types[name]) {\n                // Check each field has a unique name\n                assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                uniqueNames.add(field.name);\n                // Get the base type (drop any array specifiers)\n                const baseType = (field.type.match(/^([^\\x5b]*)(\\x5b|$)/))[1] || null;\n                assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    continue;\n                }\n                assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                // Add linkage\n                parents.get(baseType).push(name);\n                links.get(name).add(baseType);\n            }\n        }\n        // Deduce the primary type\n        const primaryTypes = Array.from(parents.keys()).filter((n) => (parents.get(n).length === 0));\n        assertArgument(primaryTypes.length !== 0, \"missing primary type\", \"types\", types);\n        assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", types);\n        defineProperties(this, { primaryType: primaryTypes[0] });\n        // Check for circular type references\n        function checkCircular(type, found) {\n            assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            found.add(type);\n            for (const child of links.get(type)) {\n                if (!parents.has(child)) {\n                    continue;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                for (const subtype of found) {\n                    subtypes.get(subtype).add(child);\n                }\n            }\n            found.delete(type);\n        }\n        checkCircular(this.primaryType, new Set());\n        // Compute each fully describe type\n        for (const [name, set] of subtypes) {\n            const st = Array.from(set);\n            st.sort();\n            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\"));\n        }\n    }\n    /**\n     *  Returnthe encoder for the specific %%type%%.\n     */\n    getEncoder(type) {\n        let encoder = this.#encoderCache.get(type);\n        if (!encoder) {\n            encoder = this.#getEncoder(type);\n            this.#encoderCache.set(type, encoder);\n        }\n        return encoder;\n    }\n    #getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            return (value) => {\n                assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, \"value\", value);\n                let result = value.map(subEncoder);\n                if (this.#fullTypes.has(subtype)) {\n                    result = result.map(keccak256);\n                }\n                return keccak256(concat(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this.#fullTypes.get(type));\n            return (value) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this.#fullTypes.has(type)) {\n                        return keccak256(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return concat(values);\n            };\n        }\n        assertArgument(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Return the full type for %%name%%.\n     */\n    encodeType(name) {\n        const result = this.#fullTypes.get(name);\n        assertArgument(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        return result;\n    }\n    /**\n     *  Return the encoded %%value%% for the %%type%%.\n     */\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    /**\n     *  Returns the hash of %%value%% for the type of %%name%%.\n     */\n    hashStruct(name, value) {\n        return keccak256(this.encodeData(name, value));\n    }\n    /**\n     *  Return the fulled encoded %%value%% for the [[types]].\n     */\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    /**\n     *  Return the hash of the fully encoded %%value%% for the [[types]].\n     */\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    /**\n     *  @_ignore:\n     */\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, \"value\", value);\n            return value.map((v) => this._visit(match[1], v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        assertArgument(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Call %%calback%% for each value in %%value%%, passing the type and\n     *  component within %%value%%.\n     *\n     *  This is useful for replacing addresses or other transformation that\n     *  may be desired on each component, based on its type.\n     */\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     */\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    /**\n     *  Return the primary type for %%types%%.\n     */\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    /**\n     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n     */\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    /**\n     *  Return the domain hash for %%domain%%.\n     */\n    static hashDomain(domain) {\n        const domainFields = [];\n        for (const name in domain) {\n            if (domain[name] == null) {\n                continue;\n            }\n            const type = domainFieldTypes[name];\n            assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            domainFields.push({ name, type });\n        }\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n    /**\n     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */\n    static encode(domain, types, value) {\n        return concat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    /**\n     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */\n    static hash(domain, types, value) {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    /**\n     * Resolves to the value from resolving all addresses in %%value%% for\n     * %%types%% and the %%domain%%.\n     */\n    static async resolveNames(domain, types, value, resolveName) {\n        // Make a copy to isolate it from the object passed in\n        domain = Object.assign({}, domain);\n        // Allow passing null to ignore value\n        for (const key in domain) {\n            if (domain[key] == null) {\n                delete domain[key];\n            }\n        }\n        // Look up all ENS names\n        const ensCache = {};\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n        // Get a list of all the addresses\n        encoder.visit(value, (type, value) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type, value) => {\n            if (type === \"address\" && ensCache[value]) {\n                return ensCache[value];\n            }\n            return value;\n        });\n        return { domain, value };\n    }\n    /**\n     *  Returns the JSON-encoded payload expected by nodes which implement\n     *  the JSON-RPC [[link-eip-712]] method.\n     */\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = Object.assign({}, types);\n        assertArgument(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        typesWithDomain.EIP712Domain = domainTypes;\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(getBytes(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return getBigInt(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        assertArgument(typeof (value) === \"string\", \"invalid string\", \"value\", value);\n                        return value;\n                }\n                assertArgument(false, \"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */\nexport function verifyTypedData(domain, types, value, signature) {\n    return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);\n}\n//# sourceMappingURL=typed-data.js.map"]},"metadata":{},"sourceType":"module"}