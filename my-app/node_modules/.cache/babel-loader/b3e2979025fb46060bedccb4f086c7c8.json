{"ast":null,"code":"//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { getBytes } from \"./data.js\";\nfunction hexlifyByte(value) {\n  let result = value.toString(16);\n  while (result.length < 2) {\n    result = \"0\" + result;\n  }\n  return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n  let result = 0;\n  for (let i = 0; i < length; i++) {\n    result = result * 256 + data[offset + i];\n  }\n  return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n  const result = [];\n  while (childOffset < offset + 1 + length) {\n    const decoded = _decode(data, childOffset);\n    result.push(decoded.result);\n    childOffset += decoded.consumed;\n    assert(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n      buffer: data,\n      length,\n      offset\n    });\n  }\n  return {\n    consumed: 1 + length,\n    result: result\n  };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n  assert(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n    buffer: data,\n    length: 0,\n    offset: 1\n  });\n  const checkOffset = offset => {\n    assert(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n      buffer: data,\n      length: data.length,\n      offset\n    });\n  };\n  // Array with extra length prefix\n  if (data[offset] >= 0xf8) {\n    const lengthLength = data[offset] - 0xf7;\n    checkOffset(offset + 1 + lengthLength);\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n    checkOffset(offset + 1 + lengthLength + length);\n    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n  } else if (data[offset] >= 0xc0) {\n    const length = data[offset] - 0xc0;\n    checkOffset(offset + 1 + length);\n    return _decodeChildren(data, offset, offset + 1, length);\n  } else if (data[offset] >= 0xb8) {\n    const lengthLength = data[offset] - 0xb7;\n    checkOffset(offset + 1 + lengthLength);\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n    checkOffset(offset + 1 + lengthLength + length);\n    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n    return {\n      consumed: 1 + lengthLength + length,\n      result: result\n    };\n  } else if (data[offset] >= 0x80) {\n    const length = data[offset] - 0x80;\n    checkOffset(offset + 1 + length);\n    const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n    return {\n      consumed: 1 + length,\n      result: result\n    };\n  }\n  return {\n    consumed: 1,\n    result: hexlifyByte(data[offset])\n  };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */\nexport function decodeRlp(_data) {\n  const data = getBytes(_data, \"data\");\n  const decoded = _decode(data, 0);\n  assertArgument(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n  return decoded.result;\n}","map":{"version":3,"sources":["../../src.ts/utils/rlp-decode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { getBytes } from \"./data.js\";\nfunction hexlifyByte(value) {\n    let result = value.toString(16);\n    while (result.length < 2) {\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        assert(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length, offset\n        });\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    assert(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n        buffer: data, length: 0, offset: 1\n    });\n    const checkOffset = (offset) => {\n        assert(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length: data.length, offset\n        });\n    };\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        checkOffset(offset + 1 + length);\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        checkOffset(offset + 1 + length);\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: hexlifyByte(data[offset]) };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */\nexport function decodeRlp(_data) {\n    const data = getBytes(_data, \"data\");\n    const decoded = _decode(data, 0);\n    assertArgument(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n}\n//# sourceMappingURL=rlp-decode.js.map"]},"metadata":{},"sourceType":"module"}