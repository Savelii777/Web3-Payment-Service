{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _defineProperty from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateMethodGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\n/**\n *  A **FallbackProvider** providers resiliance, security and performatnce\n *  in a way that is customizable and configurable.\n *\n *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]\n */\nimport { assert, assertArgument, getBigInt, getNumber, isError } from \"../utils/index.js\";\nimport { AbstractProvider } from \"./abstract-provider.js\";\nimport { Network } from \"./network.js\";\nconst BN_1 = BigInt(\"1\");\nconst BN_2 = BigInt(\"2\");\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const tmp = array[i];\n    array[i] = array[j];\n    array[j] = tmp;\n  }\n}\nfunction stall(duration) {\n  return new Promise(resolve => {\n    setTimeout(resolve, duration);\n  });\n}\nfunction getTime() {\n  return new Date().getTime();\n}\nfunction stringify(value) {\n  return JSON.stringify(value, (key, value) => {\n    if (typeof value === \"bigint\") {\n      return {\n        type: \"bigint\",\n        value: value.toString()\n      };\n    }\n    return value;\n  });\n}\n;\nconst defaultConfig = {\n  stallTimeout: 400,\n  priority: 1,\n  weight: 1\n};\nconst defaultState = {\n  blockNumber: -2,\n  requests: 0,\n  lateResponses: 0,\n  errorResponses: 0,\n  outOfSync: -1,\n  unsupportedEvents: 0,\n  rollingDuration: 0,\n  score: 0,\n  _network: null,\n  _updateNumber: null,\n  _totalTime: 0,\n  _lastFatalError: null,\n  _lastFatalErrorTimestamp: 0\n};\nasync function waitForSync(config, blockNumber) {\n  while (config.blockNumber < 0 || config.blockNumber < blockNumber) {\n    if (!config._updateNumber) {\n      config._updateNumber = (async () => {\n        try {\n          const blockNumber = await config.provider.getBlockNumber();\n          if (blockNumber > config.blockNumber) {\n            config.blockNumber = blockNumber;\n          }\n        } catch (error) {\n          config.blockNumber = -2;\n          config._lastFatalError = error;\n          config._lastFatalErrorTimestamp = getTime();\n        }\n        config._updateNumber = null;\n      })();\n    }\n    await config._updateNumber;\n    config.outOfSync++;\n    if (config._lastFatalError) {\n      break;\n    }\n  }\n}\nfunction _normalize(value) {\n  if (value == null) {\n    return \"null\";\n  }\n  if (Array.isArray(value)) {\n    return \"[\" + value.map(_normalize).join(\",\") + \"]\";\n  }\n  if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\n    return _normalize(value.toJSON());\n  }\n  switch (typeof value) {\n    case \"boolean\":\n    case \"symbol\":\n      return value.toString();\n    case \"bigint\":\n    case \"number\":\n      return BigInt(value).toString();\n    case \"string\":\n      return JSON.stringify(value);\n    case \"object\":\n      {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map(k => \"\".concat(JSON.stringify(k), \":\").concat(_normalize(value[k]))).join(\",\") + \"}\";\n      }\n  }\n  console.log(\"Could not serialize\", value);\n  throw new Error(\"Hmm...\");\n}\nfunction normalizeResult(value) {\n  if (\"error\" in value) {\n    const error = value.error;\n    return {\n      tag: _normalize(error),\n      value: error\n    };\n  }\n  const result = value.result;\n  return {\n    tag: _normalize(result),\n    value: result\n  };\n}\n// This strategy picks the highest weight result, as long as the weight is\n// equal to or greater than quorum\nfunction checkQuorum(quorum, results) {\n  const tally = new Map();\n  for (const {\n    value,\n    tag,\n    weight\n  } of results) {\n    const t = tally.get(tag) || {\n      value,\n      weight: 0\n    };\n    t.weight += weight;\n    tally.set(tag, t);\n  }\n  let best = null;\n  for (const r of tally.values()) {\n    if (r.weight >= quorum && (!best || r.weight > best.weight)) {\n      best = r;\n    }\n  }\n  if (best) {\n    return best.value;\n  }\n  return undefined;\n}\nfunction getMedian(quorum, results) {\n  let resultWeight = 0;\n  const errorMap = new Map();\n  let bestError = null;\n  const values = [];\n  for (const {\n    value,\n    tag,\n    weight\n  } of results) {\n    if (value instanceof Error) {\n      const e = errorMap.get(tag) || {\n        value,\n        weight: 0\n      };\n      e.weight += weight;\n      errorMap.set(tag, e);\n      if (bestError == null || e.weight > bestError.weight) {\n        bestError = e;\n      }\n    } else {\n      values.push(BigInt(value));\n      resultWeight += weight;\n    }\n  }\n  if (resultWeight < quorum) {\n    // We have quorum for an error\n    if (bestError && bestError.weight >= quorum) {\n      return bestError.value;\n    }\n    // We do not have quorum for a result\n    return undefined;\n  }\n  // Get the sorted values\n  values.sort((a, b) => a < b ? -1 : b > a ? 1 : 0);\n  const mid = Math.floor(values.length / 2);\n  // Odd-length; take the middle value\n  if (values.length % 2) {\n    return values[mid];\n  }\n  // Even length; take the ceiling of the mean of the center two values\n  return (values[mid - 1] + values[mid] + BN_1) / BN_2;\n}\nfunction getAnyResult(quorum, results) {\n  // If any value or error meets quorum, that is our preferred result\n  const result = checkQuorum(quorum, results);\n  if (result !== undefined) {\n    return result;\n  }\n  // Otherwise, do we have any result?\n  for (const r of results) {\n    if (r.value) {\n      return r.value;\n    }\n  }\n  // Nope!\n  return undefined;\n}\nfunction getFuzzyMode(quorum, results) {\n  if (quorum === 1) {\n    return getNumber(getMedian(quorum, results), \"%internal\");\n  }\n  const tally = new Map();\n  const add = (result, weight) => {\n    const t = tally.get(result) || {\n      result,\n      weight: 0\n    };\n    t.weight += weight;\n    tally.set(result, t);\n  };\n  for (const {\n    weight,\n    value\n  } of results) {\n    const r = getNumber(value);\n    add(r - 1, weight);\n    add(r, weight);\n    add(r + 1, weight);\n  }\n  let bestWeight = 0;\n  let bestResult = undefined;\n  for (const {\n    weight,\n    result\n  } of tally.values()) {\n    // Use this result, if this result meets quorum and has either:\n    // - a better weight\n    // - or equal weight, but the result is larger\n    if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result > bestResult)) {\n      bestWeight = weight;\n      bestResult = result;\n    }\n  }\n  return bestResult;\n}\n/**\n *  A **FallbackProvider** manages several [[Providers]] providing\n *  resiliance by switching between slow or misbehaving nodes, security\n *  by requiring multiple backends to aggree and performance by allowing\n *  faster backends to respond earlier.\n *\n */\nvar _configs = /*#__PURE__*/new WeakMap();\nvar _height = /*#__PURE__*/new WeakMap();\nvar _initialSyncPromise = /*#__PURE__*/new WeakMap();\nvar _getNextConfig = /*#__PURE__*/new WeakSet();\nvar _addRunner = /*#__PURE__*/new WeakSet();\nvar _initialSync = /*#__PURE__*/new WeakSet();\nvar _checkQuorum = /*#__PURE__*/new WeakSet();\nvar _waitForQuorum = /*#__PURE__*/new WeakSet();\nexport class FallbackProvider extends AbstractProvider {\n  /**\n   *  The number of backends that must agree on a value before it is\n   *  accpeted.\n   */\n\n  /**\n   *  @_ignore:\n   */\n\n  /**\n   *  @_ignore:\n   */\n\n  /**\n   *  Creates a new **FallbackProvider** with %%providers%% connected to\n   *  %%network%%.\n   *\n   *  If a [[Provider]] is included in %%providers%%, defaults are used\n   *  for the configuration.\n   */\n  constructor(providers, _network, options) {\n    super(_network, options);\n    _classPrivateMethodInitSpec(this, _waitForQuorum);\n    _classPrivateMethodInitSpec(this, _checkQuorum);\n    _classPrivateMethodInitSpec(this, _initialSync);\n    _classPrivateMethodInitSpec(this, _addRunner);\n    _classPrivateMethodInitSpec(this, _getNextConfig);\n    _defineProperty(this, \"quorum\", void 0);\n    _defineProperty(this, \"eventQuorum\", void 0);\n    _defineProperty(this, \"eventWorkers\", void 0);\n    _classPrivateFieldInitSpec(this, _configs, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _height, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _initialSyncPromise, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _configs, providers.map(p => {\n      if (p instanceof AbstractProvider) {\n        return Object.assign({\n          provider: p\n        }, defaultConfig, defaultState);\n      } else {\n        return Object.assign({}, defaultConfig, p, defaultState);\n      }\n    }));\n    _classPrivateFieldSet(this, _height, -2);\n    _classPrivateFieldSet(this, _initialSyncPromise, null);\n    if (options && options.quorum != null) {\n      this.quorum = options.quorum;\n    } else {\n      this.quorum = Math.ceil(_classPrivateFieldGet(this, _configs).reduce((accum, config) => {\n        accum += config.weight;\n        return accum;\n      }, 0) / 2);\n    }\n    this.eventQuorum = 1;\n    this.eventWorkers = 1;\n    assertArgument(this.quorum <= _classPrivateFieldGet(this, _configs).reduce((a, c) => a + c.weight, 0), \"quorum exceed provider wieght\", \"quorum\", this.quorum);\n  }\n  get providerConfigs() {\n    return _classPrivateFieldGet(this, _configs).map(c => {\n      const result = Object.assign({}, c);\n      for (const key in result) {\n        if (key[0] === \"_\") {\n          delete result[key];\n        }\n      }\n      return result;\n    });\n  }\n  async _detectNetwork() {\n    return Network.from(getBigInt(await this._perform({\n      method: \"chainId\"\n    })));\n  }\n  // @TODO: Add support to select providers to be the event subscriber\n  //_getSubscriber(sub: Subscription): Subscriber {\n  //    throw new Error(\"@TODO\");\n  //}\n  /**\n   *  Transforms a %%req%% into the correct method call on %%provider%%.\n   */\n  async _translatePerform(provider, req) {\n    switch (req.method) {\n      case \"broadcastTransaction\":\n        return await provider.broadcastTransaction(req.signedTransaction);\n      case \"call\":\n        return await provider.call(Object.assign({}, req.transaction, {\n          blockTag: req.blockTag\n        }));\n      case \"chainId\":\n        return (await provider.getNetwork()).chainId;\n      case \"estimateGas\":\n        return await provider.estimateGas(req.transaction);\n      case \"getBalance\":\n        return await provider.getBalance(req.address, req.blockTag);\n      case \"getBlock\":\n        {\n          const block = \"blockHash\" in req ? req.blockHash : req.blockTag;\n          return await provider.getBlock(block, req.includeTransactions);\n        }\n      case \"getBlockNumber\":\n        return await provider.getBlockNumber();\n      case \"getCode\":\n        return await provider.getCode(req.address, req.blockTag);\n      case \"getGasPrice\":\n        return (await provider.getFeeData()).gasPrice;\n      case \"getPriorityFee\":\n        return (await provider.getFeeData()).maxPriorityFeePerGas;\n      case \"getLogs\":\n        return await provider.getLogs(req.filter);\n      case \"getStorage\":\n        return await provider.getStorage(req.address, req.position, req.blockTag);\n      case \"getTransaction\":\n        return await provider.getTransaction(req.hash);\n      case \"getTransactionCount\":\n        return await provider.getTransactionCount(req.address, req.blockTag);\n      case \"getTransactionReceipt\":\n        return await provider.getTransactionReceipt(req.hash);\n      case \"getTransactionResult\":\n        return await provider.getTransactionResult(req.hash);\n    }\n  }\n  // Grab the next (random) config that is not already part of\n  // the running set\n\n  // Adds a new runner (if available) to running.\n\n  // Initializes the blockNumber and network for each runner and\n  // blocks until initialized\n\n  async _perform(req) {\n    // Broadcasting a transaction is rare (ish) and already incurs\n    // a cost on the user, so spamming is safe-ish. Just send it to\n    // every backend.\n    if (req.method === \"broadcastTransaction\") {\n      // Once any broadcast provides a positive result, use it. No\n      // need to wait for anyone else\n      const results = _classPrivateFieldGet(this, _configs).map(c => null);\n      const broadcasts = _classPrivateFieldGet(this, _configs).map(async (_ref, index) => {\n        let {\n          provider,\n          weight\n        } = _ref;\n        try {\n          const result = await provider._perform(req);\n          results[index] = Object.assign(normalizeResult({\n            result\n          }), {\n            weight\n          });\n        } catch (error) {\n          results[index] = Object.assign(normalizeResult({\n            error\n          }), {\n            weight\n          });\n        }\n      });\n      // As each promise finishes...\n      while (true) {\n        // Check for a valid broadcast result\n        const done = results.filter(r => r != null);\n        for (const {\n          value\n        } of done) {\n          if (!(value instanceof Error)) {\n            return value;\n          }\n        }\n        // Check for a legit broadcast error (one which we cannot\n        // recover from; some nodes may return the following red\n        // herring events:\n        // - alredy seend (UNKNOWN_ERROR)\n        // - NONCE_EXPIRED\n        // - REPLACEMENT_UNDERPRICED\n        const result = checkQuorum(this.quorum, results.filter(r => r != null));\n        if (isError(result, \"INSUFFICIENT_FUNDS\")) {\n          throw result;\n        }\n        // Kick off the next provider (if any)\n        const waiting = broadcasts.filter((b, i) => results[i] == null);\n        if (waiting.length === 0) {\n          break;\n        }\n        await Promise.race(waiting);\n      }\n      // Use standard quorum results; any result was returned above,\n      // so this will find any error that met quorum if any\n      const result = getAnyResult(this.quorum, results);\n      assert(result !== undefined, \"problem multi-broadcasting\", \"SERVER_ERROR\", {\n        request: \"%sub-requests\",\n        info: {\n          request: req,\n          results: results.map(stringify)\n        }\n      });\n      if (result instanceof Error) {\n        throw result;\n      }\n      return result;\n    }\n    await _classPrivateMethodGet(this, _initialSync, _initialSync2).call(this);\n    // Bootstrap enough runners to meet quorum\n    const running = new Set();\n    let inflightQuorum = 0;\n    while (true) {\n      const runner = _classPrivateMethodGet(this, _addRunner, _addRunner2).call(this, running, req);\n      if (runner == null) {\n        break;\n      }\n      inflightQuorum += runner.config.weight;\n      if (inflightQuorum >= this.quorum) {\n        break;\n      }\n    }\n    const result = await _classPrivateMethodGet(this, _waitForQuorum, _waitForQuorum2).call(this, running, req);\n    // Track requests sent to a provider that are still\n    // outstanding after quorum has been otherwise found\n    for (const runner of running) {\n      if (runner.perform && runner.result == null) {\n        runner.config.lateResponses++;\n      }\n    }\n    return result;\n  }\n  async destroy() {\n    for (const {\n      provider\n    } of _classPrivateFieldGet(this, _configs)) {\n      provider.destroy();\n    }\n    super.destroy();\n  }\n}\nfunction _getNextConfig2(running) {\n  // @TODO: Maybe do a check here to favour (heavily) providers that\n  //        do not require waitForSync and disfavour providers that\n  //        seem down-ish or are behaving slowly\n  const configs = Array.from(running).map(r => r.config);\n  // Shuffle the states, sorted by priority\n  const allConfigs = _classPrivateFieldGet(this, _configs).slice();\n  shuffle(allConfigs);\n  allConfigs.sort((a, b) => a.priority - b.priority);\n  for (const config of allConfigs) {\n    if (config._lastFatalError) {\n      continue;\n    }\n    if (configs.indexOf(config) === -1) {\n      return config;\n    }\n  }\n  return null;\n}\nfunction _addRunner2(running, req) {\n  const config = _classPrivateMethodGet(this, _getNextConfig, _getNextConfig2).call(this, running);\n  // No runners available\n  if (config == null) {\n    return null;\n  }\n  // Create a new runner\n  const runner = {\n    config,\n    result: null,\n    didBump: false,\n    perform: null,\n    staller: null\n  };\n  const now = getTime();\n  // Start performing this operation\n  runner.perform = (async () => {\n    try {\n      config.requests++;\n      const result = await this._translatePerform(config.provider, req);\n      runner.result = {\n        result\n      };\n    } catch (error) {\n      config.errorResponses++;\n      runner.result = {\n        error\n      };\n    }\n    const dt = getTime() - now;\n    config._totalTime += dt;\n    config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;\n    runner.perform = null;\n  })();\n  // Start a staller; when this times out, it's time to force\n  // kicking off another runner because we are taking too long\n  runner.staller = (async () => {\n    await stall(config.stallTimeout);\n    runner.staller = null;\n  })();\n  running.add(runner);\n  return runner;\n}\nasync function _initialSync2() {\n  let initialSync = _classPrivateFieldGet(this, _initialSyncPromise);\n  if (!initialSync) {\n    const promises = [];\n    _classPrivateFieldGet(this, _configs).forEach(config => {\n      promises.push((async () => {\n        await waitForSync(config, 0);\n        if (!config._lastFatalError) {\n          config._network = await config.provider.getNetwork();\n        }\n      })());\n    });\n    _classPrivateFieldSet(this, _initialSyncPromise, initialSync = (async () => {\n      // Wait for all providers to have a block number and network\n      await Promise.all(promises);\n      // Check all the networks match\n      let chainId = null;\n      for (const config of _classPrivateFieldGet(this, _configs)) {\n        if (config._lastFatalError) {\n          continue;\n        }\n        const network = config._network;\n        if (chainId == null) {\n          chainId = network.chainId;\n        } else if (network.chainId !== chainId) {\n          assert(false, \"cannot mix providers on different networks\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"new FallbackProvider\"\n          });\n        }\n      }\n    })());\n  }\n  await initialSync;\n}\nasync function _checkQuorum2(running, req) {\n  // Get all the result objects\n  const results = [];\n  for (const runner of running) {\n    if (runner.result != null) {\n      const {\n        tag,\n        value\n      } = normalizeResult(runner.result);\n      results.push({\n        tag,\n        value,\n        weight: runner.config.weight\n      });\n    }\n  }\n  // Are there enough results to event meet quorum?\n  if (results.reduce((a, r) => a + r.weight, 0) < this.quorum) {\n    return undefined;\n  }\n  switch (req.method) {\n    case \"getBlockNumber\":\n      {\n        // We need to get the bootstrap block height\n        if (_classPrivateFieldGet(this, _height) === -2) {\n          _classPrivateFieldSet(this, _height, Math.ceil(getNumber(getMedian(this.quorum, _classPrivateFieldGet(this, _configs).filter(c => !c._lastFatalError).map(c => ({\n            value: c.blockNumber,\n            tag: getNumber(c.blockNumber).toString(),\n            weight: c.weight\n          }))))));\n        }\n        // Find the mode across all the providers, allowing for\n        // a little drift between block heights\n        const mode = getFuzzyMode(this.quorum, results);\n        if (mode === undefined) {\n          return undefined;\n        }\n        if (mode > _classPrivateFieldGet(this, _height)) {\n          _classPrivateFieldSet(this, _height, mode);\n        }\n        return _classPrivateFieldGet(this, _height);\n      }\n    case \"getGasPrice\":\n    case \"getPriorityFee\":\n    case \"estimateGas\":\n      return getMedian(this.quorum, results);\n    case \"getBlock\":\n      // Pending blocks are in the mempool and already\n      // quite untrustworthy; just grab anything\n      if (\"blockTag\" in req && req.blockTag === \"pending\") {\n        return getAnyResult(this.quorum, results);\n      }\n      return checkQuorum(this.quorum, results);\n    case \"call\":\n    case \"chainId\":\n    case \"getBalance\":\n    case \"getTransactionCount\":\n    case \"getCode\":\n    case \"getStorage\":\n    case \"getTransaction\":\n    case \"getTransactionReceipt\":\n    case \"getLogs\":\n      return checkQuorum(this.quorum, results);\n    case \"broadcastTransaction\":\n      return getAnyResult(this.quorum, results);\n  }\n  assert(false, \"unsupported method\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"_perform(\".concat(stringify(req.method), \")\")\n  });\n}\nasync function _waitForQuorum2(running, req) {\n  if (running.size === 0) {\n    throw new Error(\"no runners?!\");\n  }\n  // Any promises that are interesting to watch for; an expired stall\n  // or a successful perform\n  const interesting = [];\n  let newRunners = 0;\n  for (const runner of running) {\n    // No responses, yet; keep an eye on it\n    if (runner.perform) {\n      interesting.push(runner.perform);\n    }\n    // Still stalling...\n    if (runner.staller) {\n      interesting.push(runner.staller);\n      continue;\n    }\n    // This runner has already triggered another runner\n    if (runner.didBump) {\n      continue;\n    }\n    // Got a response (result or error) or stalled; kick off another runner\n    runner.didBump = true;\n    newRunners++;\n  }\n  // Check if we have reached quorum on a result (or error)\n  const value = await _classPrivateMethodGet(this, _checkQuorum, _checkQuorum2).call(this, running, req);\n  if (value !== undefined) {\n    if (value instanceof Error) {\n      throw value;\n    }\n    return value;\n  }\n  // Add any new runners, because a staller timed out or a result\n  // or error response came in.\n  for (let i = 0; i < newRunners; i++) {\n    _classPrivateMethodGet(this, _addRunner, _addRunner2).call(this, running, req);\n  }\n  // All providers have returned, and we have no result\n  assert(interesting.length > 0, \"quorum not met\", \"SERVER_ERROR\", {\n    request: \"%sub-requests\",\n    info: {\n      request: req,\n      results: Array.from(running).map(r => stringify(r.result))\n    }\n  });\n  // Wait for someone to either complete its perform or stall out\n  await Promise.race(interesting);\n  // This is recursive, but at worst case the depth is 2x the\n  // number of providers (each has a perform and a staller)\n  return await _classPrivateMethodGet(this, _waitForQuorum, _waitForQuorum2).call(this, running, req);\n}","map":{"version":3,"sources":["../../src.ts/providers/provider-fallback.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n *  A **FallbackProvider** providers resiliance, security and performatnce\n *  in a way that is customizable and configurable.\n *\n *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]\n */\nimport { assert, assertArgument, getBigInt, getNumber, isError } from \"../utils/index.js\";\nimport { AbstractProvider } from \"./abstract-provider.js\";\nimport { Network } from \"./network.js\";\nconst BN_1 = BigInt(\"1\");\nconst BN_2 = BigInt(\"2\");\nfunction shuffle(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}\nfunction stall(duration) {\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\n}\nfunction getTime() { return (new Date()).getTime(); }\nfunction stringify(value) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof (value) === \"bigint\") {\n            return { type: \"bigint\", value: value.toString() };\n        }\n        return value;\n    });\n}\n;\nconst defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };\nconst defaultState = {\n    blockNumber: -2, requests: 0, lateResponses: 0, errorResponses: 0,\n    outOfSync: -1, unsupportedEvents: 0, rollingDuration: 0, score: 0,\n    _network: null, _updateNumber: null, _totalTime: 0,\n    _lastFatalError: null, _lastFatalErrorTimestamp: 0\n};\nasync function waitForSync(config, blockNumber) {\n    while (config.blockNumber < 0 || config.blockNumber < blockNumber) {\n        if (!config._updateNumber) {\n            config._updateNumber = (async () => {\n                try {\n                    const blockNumber = await config.provider.getBlockNumber();\n                    if (blockNumber > config.blockNumber) {\n                        config.blockNumber = blockNumber;\n                    }\n                }\n                catch (error) {\n                    config.blockNumber = -2;\n                    config._lastFatalError = error;\n                    config._lastFatalErrorTimestamp = getTime();\n                }\n                config._updateNumber = null;\n            })();\n        }\n        await config._updateNumber;\n        config.outOfSync++;\n        if (config._lastFatalError) {\n            break;\n        }\n    }\n}\nfunction _normalize(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[\" + (value.map(_normalize)).join(\",\") + \"]\";\n    }\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\n        return _normalize(value.toJSON());\n    }\n    switch (typeof (value)) {\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n        case \"number\":\n            return BigInt(value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{\" + keys.map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(\",\") + \"}\";\n        }\n    }\n    console.log(\"Could not serialize\", value);\n    throw new Error(\"Hmm...\");\n}\nfunction normalizeResult(value) {\n    if (\"error\" in value) {\n        const error = value.error;\n        return { tag: _normalize(error), value: error };\n    }\n    const result = value.result;\n    return { tag: _normalize(result), value: result };\n}\n// This strategy picks the highest weight result, as long as the weight is\n// equal to or greater than quorum\nfunction checkQuorum(quorum, results) {\n    const tally = new Map();\n    for (const { value, tag, weight } of results) {\n        const t = tally.get(tag) || { value, weight: 0 };\n        t.weight += weight;\n        tally.set(tag, t);\n    }\n    let best = null;\n    for (const r of tally.values()) {\n        if (r.weight >= quorum && (!best || r.weight > best.weight)) {\n            best = r;\n        }\n    }\n    if (best) {\n        return best.value;\n    }\n    return undefined;\n}\nfunction getMedian(quorum, results) {\n    let resultWeight = 0;\n    const errorMap = new Map();\n    let bestError = null;\n    const values = [];\n    for (const { value, tag, weight } of results) {\n        if (value instanceof Error) {\n            const e = errorMap.get(tag) || { value, weight: 0 };\n            e.weight += weight;\n            errorMap.set(tag, e);\n            if (bestError == null || e.weight > bestError.weight) {\n                bestError = e;\n            }\n        }\n        else {\n            values.push(BigInt(value));\n            resultWeight += weight;\n        }\n    }\n    if (resultWeight < quorum) {\n        // We have quorum for an error\n        if (bestError && bestError.weight >= quorum) {\n            return bestError.value;\n        }\n        // We do not have quorum for a result\n        return undefined;\n    }\n    // Get the sorted values\n    values.sort((a, b) => ((a < b) ? -1 : (b > a) ? 1 : 0));\n    const mid = Math.floor(values.length / 2);\n    // Odd-length; take the middle value\n    if (values.length % 2) {\n        return values[mid];\n    }\n    // Even length; take the ceiling of the mean of the center two values\n    return (values[mid - 1] + values[mid] + BN_1) / BN_2;\n}\nfunction getAnyResult(quorum, results) {\n    // If any value or error meets quorum, that is our preferred result\n    const result = checkQuorum(quorum, results);\n    if (result !== undefined) {\n        return result;\n    }\n    // Otherwise, do we have any result?\n    for (const r of results) {\n        if (r.value) {\n            return r.value;\n        }\n    }\n    // Nope!\n    return undefined;\n}\nfunction getFuzzyMode(quorum, results) {\n    if (quorum === 1) {\n        return getNumber(getMedian(quorum, results), \"%internal\");\n    }\n    const tally = new Map();\n    const add = (result, weight) => {\n        const t = tally.get(result) || { result, weight: 0 };\n        t.weight += weight;\n        tally.set(result, t);\n    };\n    for (const { weight, value } of results) {\n        const r = getNumber(value);\n        add(r - 1, weight);\n        add(r, weight);\n        add(r + 1, weight);\n    }\n    let bestWeight = 0;\n    let bestResult = undefined;\n    for (const { weight, result } of tally.values()) {\n        // Use this result, if this result meets quorum and has either:\n        // - a better weight\n        // - or equal weight, but the result is larger\n        if (weight >= quorum && (weight > bestWeight || (bestResult != null && weight === bestWeight && result > bestResult))) {\n            bestWeight = weight;\n            bestResult = result;\n        }\n    }\n    return bestResult;\n}\n/**\n *  A **FallbackProvider** manages several [[Providers]] providing\n *  resiliance by switching between slow or misbehaving nodes, security\n *  by requiring multiple backends to aggree and performance by allowing\n *  faster backends to respond earlier.\n *\n */\nexport class FallbackProvider extends AbstractProvider {\n    /**\n     *  The number of backends that must agree on a value before it is\n     *  accpeted.\n     */\n    quorum;\n    /**\n     *  @_ignore:\n     */\n    eventQuorum;\n    /**\n     *  @_ignore:\n     */\n    eventWorkers;\n    #configs;\n    #height;\n    #initialSyncPromise;\n    /**\n     *  Creates a new **FallbackProvider** with %%providers%% connected to\n     *  %%network%%.\n     *\n     *  If a [[Provider]] is included in %%providers%%, defaults are used\n     *  for the configuration.\n     */\n    constructor(providers, network, options) {\n        super(network, options);\n        this.#configs = providers.map((p) => {\n            if (p instanceof AbstractProvider) {\n                return Object.assign({ provider: p }, defaultConfig, defaultState);\n            }\n            else {\n                return Object.assign({}, defaultConfig, p, defaultState);\n            }\n        });\n        this.#height = -2;\n        this.#initialSyncPromise = null;\n        if (options && options.quorum != null) {\n            this.quorum = options.quorum;\n        }\n        else {\n            this.quorum = Math.ceil(this.#configs.reduce((accum, config) => {\n                accum += config.weight;\n                return accum;\n            }, 0) / 2);\n        }\n        this.eventQuorum = 1;\n        this.eventWorkers = 1;\n        assertArgument(this.quorum <= this.#configs.reduce((a, c) => (a + c.weight), 0), \"quorum exceed provider wieght\", \"quorum\", this.quorum);\n    }\n    get providerConfigs() {\n        return this.#configs.map((c) => {\n            const result = Object.assign({}, c);\n            for (const key in result) {\n                if (key[0] === \"_\") {\n                    delete result[key];\n                }\n            }\n            return result;\n        });\n    }\n    async _detectNetwork() {\n        return Network.from(getBigInt(await this._perform({ method: \"chainId\" })));\n    }\n    // @TODO: Add support to select providers to be the event subscriber\n    //_getSubscriber(sub: Subscription): Subscriber {\n    //    throw new Error(\"@TODO\");\n    //}\n    /**\n     *  Transforms a %%req%% into the correct method call on %%provider%%.\n     */\n    async _translatePerform(provider, req) {\n        switch (req.method) {\n            case \"broadcastTransaction\":\n                return await provider.broadcastTransaction(req.signedTransaction);\n            case \"call\":\n                return await provider.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));\n            case \"chainId\":\n                return (await provider.getNetwork()).chainId;\n            case \"estimateGas\":\n                return await provider.estimateGas(req.transaction);\n            case \"getBalance\":\n                return await provider.getBalance(req.address, req.blockTag);\n            case \"getBlock\": {\n                const block = (\"blockHash\" in req) ? req.blockHash : req.blockTag;\n                return await provider.getBlock(block, req.includeTransactions);\n            }\n            case \"getBlockNumber\":\n                return await provider.getBlockNumber();\n            case \"getCode\":\n                return await provider.getCode(req.address, req.blockTag);\n            case \"getGasPrice\":\n                return (await provider.getFeeData()).gasPrice;\n            case \"getPriorityFee\":\n                return (await provider.getFeeData()).maxPriorityFeePerGas;\n            case \"getLogs\":\n                return await provider.getLogs(req.filter);\n            case \"getStorage\":\n                return await provider.getStorage(req.address, req.position, req.blockTag);\n            case \"getTransaction\":\n                return await provider.getTransaction(req.hash);\n            case \"getTransactionCount\":\n                return await provider.getTransactionCount(req.address, req.blockTag);\n            case \"getTransactionReceipt\":\n                return await provider.getTransactionReceipt(req.hash);\n            case \"getTransactionResult\":\n                return await provider.getTransactionResult(req.hash);\n        }\n    }\n    // Grab the next (random) config that is not already part of\n    // the running set\n    #getNextConfig(running) {\n        // @TODO: Maybe do a check here to favour (heavily) providers that\n        //        do not require waitForSync and disfavour providers that\n        //        seem down-ish or are behaving slowly\n        const configs = Array.from(running).map((r) => r.config);\n        // Shuffle the states, sorted by priority\n        const allConfigs = this.#configs.slice();\n        shuffle(allConfigs);\n        allConfigs.sort((a, b) => (a.priority - b.priority));\n        for (const config of allConfigs) {\n            if (config._lastFatalError) {\n                continue;\n            }\n            if (configs.indexOf(config) === -1) {\n                return config;\n            }\n        }\n        return null;\n    }\n    // Adds a new runner (if available) to running.\n    #addRunner(running, req) {\n        const config = this.#getNextConfig(running);\n        // No runners available\n        if (config == null) {\n            return null;\n        }\n        // Create a new runner\n        const runner = {\n            config, result: null, didBump: false,\n            perform: null, staller: null\n        };\n        const now = getTime();\n        // Start performing this operation\n        runner.perform = (async () => {\n            try {\n                config.requests++;\n                const result = await this._translatePerform(config.provider, req);\n                runner.result = { result };\n            }\n            catch (error) {\n                config.errorResponses++;\n                runner.result = { error };\n            }\n            const dt = (getTime() - now);\n            config._totalTime += dt;\n            config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;\n            runner.perform = null;\n        })();\n        // Start a staller; when this times out, it's time to force\n        // kicking off another runner because we are taking too long\n        runner.staller = (async () => {\n            await stall(config.stallTimeout);\n            runner.staller = null;\n        })();\n        running.add(runner);\n        return runner;\n    }\n    // Initializes the blockNumber and network for each runner and\n    // blocks until initialized\n    async #initialSync() {\n        let initialSync = this.#initialSyncPromise;\n        if (!initialSync) {\n            const promises = [];\n            this.#configs.forEach((config) => {\n                promises.push((async () => {\n                    await waitForSync(config, 0);\n                    if (!config._lastFatalError) {\n                        config._network = await config.provider.getNetwork();\n                    }\n                })());\n            });\n            this.#initialSyncPromise = initialSync = (async () => {\n                // Wait for all providers to have a block number and network\n                await Promise.all(promises);\n                // Check all the networks match\n                let chainId = null;\n                for (const config of this.#configs) {\n                    if (config._lastFatalError) {\n                        continue;\n                    }\n                    const network = (config._network);\n                    if (chainId == null) {\n                        chainId = network.chainId;\n                    }\n                    else if (network.chainId !== chainId) {\n                        assert(false, \"cannot mix providers on different networks\", \"UNSUPPORTED_OPERATION\", {\n                            operation: \"new FallbackProvider\"\n                        });\n                    }\n                }\n            })();\n        }\n        await initialSync;\n    }\n    async #checkQuorum(running, req) {\n        // Get all the result objects\n        const results = [];\n        for (const runner of running) {\n            if (runner.result != null) {\n                const { tag, value } = normalizeResult(runner.result);\n                results.push({ tag, value, weight: runner.config.weight });\n            }\n        }\n        // Are there enough results to event meet quorum?\n        if (results.reduce((a, r) => (a + r.weight), 0) < this.quorum) {\n            return undefined;\n        }\n        switch (req.method) {\n            case \"getBlockNumber\": {\n                // We need to get the bootstrap block height\n                if (this.#height === -2) {\n                    this.#height = Math.ceil(getNumber(getMedian(this.quorum, this.#configs.filter((c) => (!c._lastFatalError)).map((c) => ({\n                        value: c.blockNumber,\n                        tag: getNumber(c.blockNumber).toString(),\n                        weight: c.weight\n                    })))));\n                }\n                // Find the mode across all the providers, allowing for\n                // a little drift between block heights\n                const mode = getFuzzyMode(this.quorum, results);\n                if (mode === undefined) {\n                    return undefined;\n                }\n                if (mode > this.#height) {\n                    this.#height = mode;\n                }\n                return this.#height;\n            }\n            case \"getGasPrice\":\n            case \"getPriorityFee\":\n            case \"estimateGas\":\n                return getMedian(this.quorum, results);\n            case \"getBlock\":\n                // Pending blocks are in the mempool and already\n                // quite untrustworthy; just grab anything\n                if (\"blockTag\" in req && req.blockTag === \"pending\") {\n                    return getAnyResult(this.quorum, results);\n                }\n                return checkQuorum(this.quorum, results);\n            case \"call\":\n            case \"chainId\":\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n            case \"getStorage\":\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n            case \"getLogs\":\n                return checkQuorum(this.quorum, results);\n            case \"broadcastTransaction\":\n                return getAnyResult(this.quorum, results);\n        }\n        assert(false, \"unsupported method\", \"UNSUPPORTED_OPERATION\", {\n            operation: `_perform(${stringify(req.method)})`\n        });\n    }\n    async #waitForQuorum(running, req) {\n        if (running.size === 0) {\n            throw new Error(\"no runners?!\");\n        }\n        // Any promises that are interesting to watch for; an expired stall\n        // or a successful perform\n        const interesting = [];\n        let newRunners = 0;\n        for (const runner of running) {\n            // No responses, yet; keep an eye on it\n            if (runner.perform) {\n                interesting.push(runner.perform);\n            }\n            // Still stalling...\n            if (runner.staller) {\n                interesting.push(runner.staller);\n                continue;\n            }\n            // This runner has already triggered another runner\n            if (runner.didBump) {\n                continue;\n            }\n            // Got a response (result or error) or stalled; kick off another runner\n            runner.didBump = true;\n            newRunners++;\n        }\n        // Check if we have reached quorum on a result (or error)\n        const value = await this.#checkQuorum(running, req);\n        if (value !== undefined) {\n            if (value instanceof Error) {\n                throw value;\n            }\n            return value;\n        }\n        // Add any new runners, because a staller timed out or a result\n        // or error response came in.\n        for (let i = 0; i < newRunners; i++) {\n            this.#addRunner(running, req);\n        }\n        // All providers have returned, and we have no result\n        assert(interesting.length > 0, \"quorum not met\", \"SERVER_ERROR\", {\n            request: \"%sub-requests\",\n            info: { request: req, results: Array.from(running).map((r) => stringify(r.result)) }\n        });\n        // Wait for someone to either complete its perform or stall out\n        await Promise.race(interesting);\n        // This is recursive, but at worst case the depth is 2x the\n        // number of providers (each has a perform and a staller)\n        return await this.#waitForQuorum(running, req);\n    }\n    async _perform(req) {\n        // Broadcasting a transaction is rare (ish) and already incurs\n        // a cost on the user, so spamming is safe-ish. Just send it to\n        // every backend.\n        if (req.method === \"broadcastTransaction\") {\n            // Once any broadcast provides a positive result, use it. No\n            // need to wait for anyone else\n            const results = this.#configs.map((c) => null);\n            const broadcasts = this.#configs.map(async ({ provider, weight }, index) => {\n                try {\n                    const result = await provider._perform(req);\n                    results[index] = Object.assign(normalizeResult({ result }), { weight });\n                }\n                catch (error) {\n                    results[index] = Object.assign(normalizeResult({ error }), { weight });\n                }\n            });\n            // As each promise finishes...\n            while (true) {\n                // Check for a valid broadcast result\n                const done = results.filter((r) => (r != null));\n                for (const { value } of done) {\n                    if (!(value instanceof Error)) {\n                        return value;\n                    }\n                }\n                // Check for a legit broadcast error (one which we cannot\n                // recover from; some nodes may return the following red\n                // herring events:\n                // - alredy seend (UNKNOWN_ERROR)\n                // - NONCE_EXPIRED\n                // - REPLACEMENT_UNDERPRICED\n                const result = checkQuorum(this.quorum, results.filter((r) => (r != null)));\n                if (isError(result, \"INSUFFICIENT_FUNDS\")) {\n                    throw result;\n                }\n                // Kick off the next provider (if any)\n                const waiting = broadcasts.filter((b, i) => (results[i] == null));\n                if (waiting.length === 0) {\n                    break;\n                }\n                await Promise.race(waiting);\n            }\n            // Use standard quorum results; any result was returned above,\n            // so this will find any error that met quorum if any\n            const result = getAnyResult(this.quorum, results);\n            assert(result !== undefined, \"problem multi-broadcasting\", \"SERVER_ERROR\", {\n                request: \"%sub-requests\",\n                info: { request: req, results: results.map(stringify) }\n            });\n            if (result instanceof Error) {\n                throw result;\n            }\n            return result;\n        }\n        await this.#initialSync();\n        // Bootstrap enough runners to meet quorum\n        const running = new Set();\n        let inflightQuorum = 0;\n        while (true) {\n            const runner = this.#addRunner(running, req);\n            if (runner == null) {\n                break;\n            }\n            inflightQuorum += runner.config.weight;\n            if (inflightQuorum >= this.quorum) {\n                break;\n            }\n        }\n        const result = await this.#waitForQuorum(running, req);\n        // Track requests sent to a provider that are still\n        // outstanding after quorum has been otherwise found\n        for (const runner of running) {\n            if (runner.perform && runner.result == null) {\n                runner.config.lateResponses++;\n            }\n        }\n        return result;\n    }\n    async destroy() {\n        for (const { provider } of this.#configs) {\n            provider.destroy();\n        }\n        super.destroy();\n    }\n}\n//# sourceMappingURL=provider-fallback.js.map"]},"metadata":{},"sourceType":"module"}