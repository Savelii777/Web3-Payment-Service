{"ast":null,"code":"import _classPrivateFieldInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldSet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _classPrivateFieldGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport { WebSocket as _WebSocket } from \"./ws.js\"; /*-browser*/\nimport { SocketProvider } from \"./provider-socket.js\";\n/**\n *  A JSON-RPC provider which is backed by a WebSocket.\n *\n *  WebSockets are often preferred because they retain a live connection\n *  to a server, which permits more instant access to events.\n *\n *  However, this incurs higher server infrasturture costs, so additional\n *  resources may be required to host your own WebSocket nodes and many\n *  third-party services charge additional fees for WebSocket endpoints.\n */\nvar _connect = /*#__PURE__*/new WeakMap();\nvar _websocket = /*#__PURE__*/new WeakMap();\nexport class WebSocketProvider extends SocketProvider {\n  get websocket() {\n    if (_classPrivateFieldGet(this, _websocket) == null) {\n      throw new Error(\"websocket closed\");\n    }\n    return _classPrivateFieldGet(this, _websocket);\n  }\n  constructor(url, network, options) {\n    super(network, options);\n    _classPrivateFieldInitSpec(this, _connect, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _websocket, {\n      writable: true,\n      value: void 0\n    });\n    if (typeof url === \"string\") {\n      _classPrivateFieldSet(this, _connect, () => {\n        return new _WebSocket(url);\n      });\n      _classPrivateFieldSet(this, _websocket, _classPrivateFieldGet(this, _connect).call(this));\n    } else if (typeof url === \"function\") {\n      _classPrivateFieldSet(this, _connect, url);\n      _classPrivateFieldSet(this, _websocket, url());\n    } else {\n      _classPrivateFieldSet(this, _connect, null);\n      _classPrivateFieldSet(this, _websocket, url);\n    }\n    this.websocket.onopen = async () => {\n      try {\n        await this._start();\n        this.resume();\n      } catch (error) {\n        console.log(\"failed to start WebsocketProvider\", error);\n        // @TODO: now what? Attempt reconnect?\n      }\n    };\n    this.websocket.onmessage = message => {\n      this._processMessage(message.data);\n    };\n    /*\n            this.websocket.onclose = (event) => {\n                // @TODO: What event.code should we reconnect on?\n                const reconnect = false;\n                if (reconnect) {\n                    this.pause(true);\n                    if (this.#connect) {\n                        this.#websocket = this.#connect();\n                        this.#websocket.onopen = ...\n                        // @TODO: this requires the super class to rebroadcast; move it there\n                    }\n                    this._reconnect();\n                }\n            };\n    */\n  }\n  async _write(message) {\n    this.websocket.send(message);\n  }\n  async destroy() {\n    if (_classPrivateFieldGet(this, _websocket) != null) {\n      _classPrivateFieldGet(this, _websocket).close();\n      _classPrivateFieldSet(this, _websocket, null);\n    }\n    super.destroy();\n  }\n}","map":{"version":3,"sources":["../../src.ts/providers/provider-websocket.ts"],"names":[],"mappings":";;;AAEA,SAAS,SAAS,IAAI,UAAU,QAAQ,SAAS,CAAC,CAAC;AAEnD,SAAS,cAAc,QAAQ,sBAAsB;AAyBrD;;;;;;;;;AASG;AATH,IAAA,QAAA,oBAAA,OAAA;AAAA,IAAA,UAAA,oBAAA,OAAA;AAUA,OAAM,MAAO,iBAAkB,SAAQ,cAAc,CAAA;EAIjD,IAAI,SAAS,CAAA,EAAA;IACT,IAAI,qBAAA,KAAI,EAAA,UAAA,KAAe,IAAI,EAAE;MAAE,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC;IAAG;IACrE,OAAA,qBAAA,CAAO,IAAI,EAAA,UAAA;EACf;EAEA,WAAA,CAAY,GAA8C,EAAE,OAAoB,EAAE,OAAmC,EAAA;IACjH,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC;IAAC,0BAAA,OAAA,QAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAAA,0BAAA,OAAA,UAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IACxB,IAAI,OAAO,GAAI,KAAK,QAAQ,EAAE;MAC1B,qBAAA,KAAI,EAAA,QAAA,EAAY,MAAK;QAAG,OAAO,IAAI,UAAU,CAAC,GAAG,CAAC;MAAE,CAAC;MACrD,qBAAA,KAAI,EAAA,UAAA,EAAA,qBAAA,CAAc,IAAI,EAAA,QAAA,EAAA,IAAA,CAAJ,IAAI;KACzB,MAAM,IAAI,OAAO,GAAI,KAAK,UAAU,EAAE;MACnC,qBAAA,KAAI,EAAA,QAAA,EAAY,GAAG;MACnB,qBAAA,KAAI,EAAA,UAAA,EAAc,GAAG,CAAA,CAAE;KAC1B,MAAM;MACH,qBAAA,KAAI,EAAA,QAAA,EAAY,IAAI;MACpB,qBAAA,KAAI,EAAA,UAAA,EAAc,GAAG;IACxB;IAED,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,YAAW;MAC/B,IAAI;QACA,MAAM,IAAI,CAAC,MAAM,CAAA,CAAE;QACnB,IAAI,CAAC,MAAM,CAAA,CAAE;OAChB,CAAC,OAAO,KAAK,EAAE;QACZ,OAAO,CAAC,GAAG,CAAC,mCAAmC,EAAE,KAAK,CAAC;QACvD;MACH;IACL,CAAC;IAED,IAAI,CAAC,SAAS,CAAC,SAAS,GAAI,OAAyB,IAAI;MACrD,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,IAAI,CAAC;IACtC,CAAC;IACT;;;;;;;;;;;;;;AAcE;EACE;EAEA,MAAM,MAAM,CAAC,OAAe,EAAA;IACxB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC;EAChC;EAEA,MAAM,OAAO,CAAA,EAAA;IACT,IAAI,qBAAA,KAAI,EAAA,UAAA,KAAe,IAAI,EAAE;MACzB,qBAAA,KAAI,EAAA,UAAA,EAAY,KAAK,CAAA,CAAE;MACvB,qBAAA,KAAI,EAAA,UAAA,EAAc,IAAI;IACzB;IACD,KAAK,CAAC,OAAO,CAAA,CAAE;EACnB;AACH","sourceRoot":"","sourcesContent":["import { WebSocket as _WebSocket } from \"./ws.js\"; /*-browser*/\nimport { SocketProvider } from \"./provider-socket.js\";\n/**\n *  A JSON-RPC provider which is backed by a WebSocket.\n *\n *  WebSockets are often preferred because they retain a live connection\n *  to a server, which permits more instant access to events.\n *\n *  However, this incurs higher server infrasturture costs, so additional\n *  resources may be required to host your own WebSocket nodes and many\n *  third-party services charge additional fees for WebSocket endpoints.\n */\nexport class WebSocketProvider extends SocketProvider {\n    #connect;\n    #websocket;\n    get websocket() {\n        if (this.#websocket == null) {\n            throw new Error(\"websocket closed\");\n        }\n        return this.#websocket;\n    }\n    constructor(url, network, options) {\n        super(network, options);\n        if (typeof (url) === \"string\") {\n            this.#connect = () => { return new _WebSocket(url); };\n            this.#websocket = this.#connect();\n        }\n        else if (typeof (url) === \"function\") {\n            this.#connect = url;\n            this.#websocket = url();\n        }\n        else {\n            this.#connect = null;\n            this.#websocket = url;\n        }\n        this.websocket.onopen = async () => {\n            try {\n                await this._start();\n                this.resume();\n            }\n            catch (error) {\n                console.log(\"failed to start WebsocketProvider\", error);\n                // @TODO: now what? Attempt reconnect?\n            }\n        };\n        this.websocket.onmessage = (message) => {\n            this._processMessage(message.data);\n        };\n        /*\n                this.websocket.onclose = (event) => {\n                    // @TODO: What event.code should we reconnect on?\n                    const reconnect = false;\n                    if (reconnect) {\n                        this.pause(true);\n                        if (this.#connect) {\n                            this.#websocket = this.#connect();\n                            this.#websocket.onopen = ...\n                            // @TODO: this requires the super class to rebroadcast; move it there\n                        }\n                        this._reconnect();\n                    }\n                };\n        */\n    }\n    async _write(message) {\n        this.websocket.send(message);\n    }\n    async destroy() {\n        if (this.#websocket != null) {\n            this.#websocket.close();\n            this.#websocket = null;\n        }\n        super.destroy();\n    }\n}\n//# sourceMappingURL=provider-websocket.js.map"]},"metadata":{},"sourceType":"module"}