{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateMethodGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _defineProperty from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficent for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */\nimport { resolveAddress } from \"../address/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport { defineProperties, getBigInt, resolveProperties, assert, assertArgument } from \"../utils/index.js\";\nimport { copyRequest } from \"./provider.js\";\nfunction checkProvider(signer, operation) {\n  if (signer.provider) {\n    return signer.provider;\n  }\n  assert(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", {\n    operation\n  });\n}\nasync function populate(signer, tx) {\n  let pop = copyRequest(tx);\n  if (pop.to != null) {\n    pop.to = resolveAddress(pop.to, signer);\n  }\n  if (pop.from != null) {\n    const from = pop.from;\n    pop.from = Promise.all([signer.getAddress(), resolveAddress(from, signer)]).then(_ref => {\n      let [address, from] = _ref;\n      assertArgument(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\n      return address;\n    });\n  } else {\n    pop.from = signer.getAddress();\n  }\n  return await resolveProperties(pop);\n}\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */\nexport class AbstractSigner {\n  /**\n   *  The provider this signer is connected to.\n   */\n\n  /**\n   *  Creates a new Signer connected to %%provider%%.\n   */\n  constructor(provider) {\n    _defineProperty(this, \"provider\", void 0);\n    defineProperties(this, {\n      provider: provider || null\n    });\n  }\n  async getNonce(blockTag) {\n    return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\n  }\n  async populateCall(tx) {\n    const pop = await populate(this, tx);\n    return pop;\n  }\n  async populateTransaction(tx) {\n    const provider = checkProvider(this, \"populateTransaction\");\n    const pop = await populate(this, tx);\n    if (pop.nonce == null) {\n      pop.nonce = await this.getNonce(\"pending\");\n    }\n    if (pop.gasLimit == null) {\n      pop.gasLimit = await this.estimateGas(pop);\n    }\n    // Populate the chain ID\n    const network = await this.provider.getNetwork();\n    if (pop.chainId != null) {\n      const chainId = getBigInt(pop.chainId);\n      assertArgument(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n    } else {\n      pop.chainId = network.chainId;\n    }\n    // Do not allow mixing pre-eip-1559 and eip-1559 properties\n    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;\n    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n      assertArgument(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n      assertArgument(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n    }\n    if ((pop.type === 2 || pop.type == null) && pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null) {\n      // Fully-formed EIP-1559 transaction (skip getFeeData)\n      pop.type = 2;\n    } else if (pop.type === 0 || pop.type === 1) {\n      // Explicit Legacy or EIP-2930 transaction\n      // We need to get fee data to determine things\n      const feeData = await provider.getFeeData();\n      assert(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getGasPrice\"\n      });\n      // Populate missing gasPrice\n      if (pop.gasPrice == null) {\n        pop.gasPrice = feeData.gasPrice;\n      }\n    } else {\n      // We need to get fee data to determine things\n      const feeData = await provider.getFeeData();\n      if (pop.type == null) {\n        // We need to auto-detect the intended type of this transaction...\n        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n          // The network supports EIP-1559!\n          // Upgrade transaction from null to eip-1559\n          pop.type = 2;\n          if (pop.gasPrice != null) {\n            // Using legacy gasPrice property on an eip-1559 network,\n            // so use gasPrice as both fee properties\n            const gasPrice = pop.gasPrice;\n            delete pop.gasPrice;\n            pop.maxFeePerGas = gasPrice;\n            pop.maxPriorityFeePerGas = gasPrice;\n          } else {\n            // Populate missing fee data\n            if (pop.maxFeePerGas == null) {\n              pop.maxFeePerGas = feeData.maxFeePerGas;\n            }\n            if (pop.maxPriorityFeePerGas == null) {\n              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n            }\n          }\n        } else if (feeData.gasPrice != null) {\n          // Network doesn't support EIP-1559...\n          // ...but they are trying to use EIP-1559 properties\n          assert(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"populateTransaction\"\n          });\n          // Populate missing fee data\n          if (pop.gasPrice == null) {\n            pop.gasPrice = feeData.gasPrice;\n          }\n          // Explicitly set untyped transaction to legacy\n          // @TODO: Maybe this shold allow type 1?\n          pop.type = 0;\n        } else {\n          // getFeeData has failed us.\n          assert(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"signer.getFeeData\"\n          });\n        }\n      } else if (pop.type === 2) {\n        // Explicitly using EIP-1559\n        // Populate missing fee data\n        if (pop.maxFeePerGas == null) {\n          pop.maxFeePerGas = feeData.maxFeePerGas;\n        }\n        if (pop.maxPriorityFeePerGas == null) {\n          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n        }\n      }\n    }\n    //@TOOD: Don't await all over the place; save them up for\n    // the end for better batching\n    return await resolveProperties(pop);\n  }\n  async estimateGas(tx) {\n    return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\n  }\n  async call(tx) {\n    return checkProvider(this, \"call\").call(await this.populateCall(tx));\n  }\n  async resolveName(name) {\n    const provider = checkProvider(this, \"resolveName\");\n    return await provider.resolveName(name);\n  }\n  async sendTransaction(tx) {\n    const provider = checkProvider(this, \"sendTransaction\");\n    const pop = await this.populateTransaction(tx);\n    delete pop.from;\n    const txObj = Transaction.from(pop);\n    return await provider.broadcastTransaction(await this.signTransaction(txObj));\n  }\n}\n/**\n *  A **VoidSigner** is a class deisgned to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */\nvar _throwUnsupported = /*#__PURE__*/new WeakSet();\nexport class VoidSigner extends AbstractSigner {\n  /**\n   *  The signer address.\n   */\n\n  /**\n   *  Creates a new **VoidSigner** with %%address%% attached to\n   *  %%provider%%.\n   */\n  constructor(address, provider) {\n    super(provider);\n    _classPrivateMethodInitSpec(this, _throwUnsupported);\n    _defineProperty(this, \"address\", void 0);\n    defineProperties(this, {\n      address\n    });\n  }\n  async getAddress() {\n    return this.address;\n  }\n  connect(provider) {\n    return new VoidSigner(this.address, provider);\n  }\n  async signTransaction(tx) {\n    _classPrivateMethodGet(this, _throwUnsupported, _throwUnsupported2).call(this, \"transactions\", \"signTransaction\");\n  }\n  async signMessage(message) {\n    _classPrivateMethodGet(this, _throwUnsupported, _throwUnsupported2).call(this, \"messages\", \"signMessage\");\n  }\n  async signTypedData(domain, types, value) {\n    _classPrivateMethodGet(this, _throwUnsupported, _throwUnsupported2).call(this, \"typed-data\", \"signTypedData\");\n  }\n}\nfunction _throwUnsupported2(suffix, operation) {\n  assert(false, \"VoidSigner cannot sign \".concat(suffix), \"UNSUPPORTED_OPERATION\", {\n    operation\n  });\n}","map":{"version":3,"sources":["../../src.ts/providers/abstract-signer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficent for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */\nimport { resolveAddress } from \"../address/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport { defineProperties, getBigInt, resolveProperties, assert, assertArgument } from \"../utils/index.js\";\nimport { copyRequest } from \"./provider.js\";\nfunction checkProvider(signer, operation) {\n    if (signer.provider) {\n        return signer.provider;\n    }\n    assert(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", { operation });\n}\nasync function populate(signer, tx) {\n    let pop = copyRequest(tx);\n    if (pop.to != null) {\n        pop.to = resolveAddress(pop.to, signer);\n    }\n    if (pop.from != null) {\n        const from = pop.from;\n        pop.from = Promise.all([\n            signer.getAddress(),\n            resolveAddress(from, signer)\n        ]).then(([address, from]) => {\n            assertArgument(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\n            return address;\n        });\n    }\n    else {\n        pop.from = signer.getAddress();\n    }\n    return await resolveProperties(pop);\n}\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */\nexport class AbstractSigner {\n    /**\n     *  The provider this signer is connected to.\n     */\n    provider;\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */\n    constructor(provider) {\n        defineProperties(this, { provider: (provider || null) });\n    }\n    async getNonce(blockTag) {\n        return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\n    }\n    async populateCall(tx) {\n        const pop = await populate(this, tx);\n        return pop;\n    }\n    async populateTransaction(tx) {\n        const provider = checkProvider(this, \"populateTransaction\");\n        const pop = await populate(this, tx);\n        if (pop.nonce == null) {\n            pop.nonce = await this.getNonce(\"pending\");\n        }\n        if (pop.gasLimit == null) {\n            pop.gasLimit = await this.estimateGas(pop);\n        }\n        // Populate the chain ID\n        const network = await (this.provider).getNetwork();\n        if (pop.chainId != null) {\n            const chainId = getBigInt(pop.chainId);\n            assertArgument(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n        }\n        else {\n            pop.chainId = network.chainId;\n        }\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null);\n        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n            assertArgument(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n        }\n        else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n            assertArgument(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n        }\n        if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            pop.type = 2;\n        }\n        else if (pop.type === 0 || pop.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            assert(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getGasPrice\"\n            });\n            // Populate missing gasPrice\n            if (pop.gasPrice == null) {\n                pop.gasPrice = feeData.gasPrice;\n            }\n        }\n        else {\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            if (pop.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n                    // Upgrade transaction from null to eip-1559\n                    pop.type = 2;\n                    if (pop.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = pop.gasPrice;\n                        delete pop.gasPrice;\n                        pop.maxFeePerGas = gasPrice;\n                        pop.maxPriorityFeePerGas = gasPrice;\n                    }\n                    else {\n                        // Populate missing fee data\n                        if (pop.maxFeePerGas == null) {\n                            pop.maxFeePerGas = feeData.maxFeePerGas;\n                        }\n                        if (pop.maxPriorityFeePerGas == null) {\n                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                        }\n                    }\n                }\n                else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n                    // ...but they are trying to use EIP-1559 properties\n                    assert(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"populateTransaction\"\n                    });\n                    // Populate missing fee data\n                    if (pop.gasPrice == null) {\n                        pop.gasPrice = feeData.gasPrice;\n                    }\n                    // Explicitly set untyped transaction to legacy\n                    // @TODO: Maybe this shold allow type 1?\n                    pop.type = 0;\n                }\n                else {\n                    // getFeeData has failed us.\n                    assert(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n            }\n            else if (pop.type === 2) {\n                // Explicitly using EIP-1559\n                // Populate missing fee data\n                if (pop.maxFeePerGas == null) {\n                    pop.maxFeePerGas = feeData.maxFeePerGas;\n                }\n                if (pop.maxPriorityFeePerGas == null) {\n                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                }\n            }\n        }\n        //@TOOD: Don't await all over the place; save them up for\n        // the end for better batching\n        return await resolveProperties(pop);\n    }\n    async estimateGas(tx) {\n        return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\n    }\n    async call(tx) {\n        return checkProvider(this, \"call\").call(await this.populateCall(tx));\n    }\n    async resolveName(name) {\n        const provider = checkProvider(this, \"resolveName\");\n        return await provider.resolveName(name);\n    }\n    async sendTransaction(tx) {\n        const provider = checkProvider(this, \"sendTransaction\");\n        const pop = await this.populateTransaction(tx);\n        delete pop.from;\n        const txObj = Transaction.from(pop);\n        return await provider.broadcastTransaction(await this.signTransaction(txObj));\n    }\n}\n/**\n *  A **VoidSigner** is a class deisgned to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */\nexport class VoidSigner extends AbstractSigner {\n    /**\n     *  The signer address.\n     */\n    address;\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */\n    constructor(address, provider) {\n        super(provider);\n        defineProperties(this, { address });\n    }\n    async getAddress() { return this.address; }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n    #throwUnsupported(suffix, operation) {\n        assert(false, `VoidSigner cannot sign ${suffix}`, \"UNSUPPORTED_OPERATION\", { operation });\n    }\n    async signTransaction(tx) {\n        this.#throwUnsupported(\"transactions\", \"signTransaction\");\n    }\n    async signMessage(message) {\n        this.#throwUnsupported(\"messages\", \"signMessage\");\n    }\n    async signTypedData(domain, types, value) {\n        this.#throwUnsupported(\"typed-data\", \"signTypedData\");\n    }\n}\n//# sourceMappingURL=abstract-signer.js.map"]},"metadata":{},"sourceType":"module"}