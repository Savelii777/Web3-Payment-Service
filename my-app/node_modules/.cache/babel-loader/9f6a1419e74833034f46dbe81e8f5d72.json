{"ast":null,"code":"/* Browser Crypto Shims */\nimport { hmac } from \"@noble/hashes/hmac\";\nimport { pbkdf2 } from \"@noble/hashes/pbkdf2\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { sha512 } from \"@noble/hashes/sha512\";\nimport { assert, assertArgument } from \"../utils/index.js\";\nfunction getGlobal() {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  throw new Error('unable to locate global object');\n}\n;\nconst anyGlobal = getGlobal();\nconst crypto = anyGlobal.crypto || anyGlobal.msCrypto;\nexport function createHash(algo) {\n  switch (algo) {\n    case \"sha256\":\n      return sha256.create();\n    case \"sha512\":\n      return sha512.create();\n  }\n  assertArgument(false, \"invalid hashing algorithm name\", \"algorithm\", algo);\n}\nexport function createHmac(_algo, key) {\n  const algo = {\n    sha256,\n    sha512\n  }[_algo];\n  assertArgument(algo != null, \"invalid hmac algorithm\", \"algorithm\", _algo);\n  return hmac.create(algo, key);\n}\nexport function pbkdf2Sync(password, salt, iterations, keylen, _algo) {\n  const algo = {\n    sha256,\n    sha512\n  }[_algo];\n  assertArgument(algo != null, \"invalid pbkdf2 algorithm\", \"algorithm\", _algo);\n  return pbkdf2(algo, password, salt, {\n    c: iterations,\n    dkLen: keylen\n  });\n}\nexport function randomBytes(length) {\n  assert(crypto != null, \"platform does not support secure random numbers\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"randomBytes\"\n  });\n  assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, \"invalid length\", \"length\", length);\n  const result = new Uint8Array(length);\n  crypto.getRandomValues(result);\n  return result;\n}","map":{"version":3,"sources":["../../src.ts/crypto/crypto-browser.ts"],"names":[],"mappings":"AAAA;AAEA,SAAS,IAAI,QAAQ,oBAAoB;AACzC,SAAS,MAAM,QAAQ,sBAAsB;AAC7C,SAAS,MAAM,QAAQ,sBAAsB;AAC7C,SAAS,MAAM,QAAQ,sBAAsB;AAE7C,SAAS,MAAM,EAAE,cAAc,QAAQ,mBAAmB;AAW1D,SAAS,SAAS,CAAA,EAAA;EAChB,IAAI,OAAO,IAAI,KAAK,WAAW,EAAE;IAAE,OAAO,IAAI;EAAG;EACjD,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE;IAAE,OAAO,MAAM;EAAG;EACrD,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE;IAAE,OAAO,MAAM;EAAG;EACrD,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC;AACnD;AAAC;AAED,MAAM,SAAS,GAAG,SAAS,CAAA,CAAE;AAC7B,MAAM,MAAM,GAAQ,SAAS,CAAC,MAAM,IAAI,SAAS,CAAC,QAAQ;AAQ1D,OAAM,SAAU,UAAU,CAAC,IAAY,EAAA;EACnC,QAAQ,IAAI;IACR,KAAK,QAAQ;MAAE,OAAO,MAAM,CAAC,MAAM,CAAA,CAAE;IACrC,KAAK,QAAQ;MAAE,OAAO,MAAM,CAAC,MAAM,CAAA,CAAE;EACxC;EACD,cAAc,CAAC,KAAK,EAAE,gCAAgC,EAAE,WAAW,EAAE,IAAI,CAAC;AAC9E;AAEA,OAAM,SAAU,UAAU,CAAC,KAAa,EAAE,GAAe,EAAA;EACrD,MAAM,IAAI,GAAI;IAAE,MAAM;IAAE;EAAM,CAAE,CAAC,KAAK,CAAE;EACxC,cAAc,CAAC,IAAI,IAAI,IAAI,EAAE,wBAAwB,EAAE,WAAW,EAAE,KAAK,CAAC;EAC1E,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC;AACjC;AAEA,OAAM,SAAU,UAAU,CAAC,QAAoB,EAAE,IAAgB,EAAE,UAAkB,EAAE,MAAc,EAAE,KAA0B,EAAA;EAC7H,MAAM,IAAI,GAAI;IAAE,MAAM;IAAE;EAAM,CAAE,CAAC,KAAK,CAAE;EACxC,cAAc,CAAC,IAAI,IAAI,IAAI,EAAE,0BAA0B,EAAE,WAAW,EAAE,KAAK,CAAC;EAC5E,OAAO,MAAM,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE;IAAE,CAAC,EAAE,UAAU;IAAE,KAAK,EAAE;EAAM,CAAE,CAAC;AACzE;AAEA,OAAM,SAAU,WAAW,CAAC,MAAc,EAAA;EACtC,MAAM,CAAC,MAAM,IAAI,IAAI,EAAE,iDAAiD,EAAE,uBAAuB,EAAE;IAC/F,SAAS,EAAE;GAAe,CAAC;EAE/B,cAAc,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,MAAM,GAAG,CAAC,IAAI,MAAM,IAAI,IAAI,EAAE,gBAAgB,EAAE,QAAQ,EAAE,MAAM,CAAC;EAE5G,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC;EACrC,MAAM,CAAC,eAAe,CAAC,MAAM,CAAC;EAC9B,OAAO,MAAM;AACjB","sourceRoot":"","sourcesContent":["/* Browser Crypto Shims */\nimport { hmac } from \"@noble/hashes/hmac\";\nimport { pbkdf2 } from \"@noble/hashes/pbkdf2\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { sha512 } from \"@noble/hashes/sha512\";\nimport { assert, assertArgument } from \"../utils/index.js\";\nfunction getGlobal() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n}\n;\nconst anyGlobal = getGlobal();\nconst crypto = anyGlobal.crypto || anyGlobal.msCrypto;\nexport function createHash(algo) {\n    switch (algo) {\n        case \"sha256\": return sha256.create();\n        case \"sha512\": return sha512.create();\n    }\n    assertArgument(false, \"invalid hashing algorithm name\", \"algorithm\", algo);\n}\nexport function createHmac(_algo, key) {\n    const algo = ({ sha256, sha512 }[_algo]);\n    assertArgument(algo != null, \"invalid hmac algorithm\", \"algorithm\", _algo);\n    return hmac.create(algo, key);\n}\nexport function pbkdf2Sync(password, salt, iterations, keylen, _algo) {\n    const algo = ({ sha256, sha512 }[_algo]);\n    assertArgument(algo != null, \"invalid pbkdf2 algorithm\", \"algorithm\", _algo);\n    return pbkdf2(algo, password, salt, { c: iterations, dkLen: keylen });\n}\nexport function randomBytes(length) {\n    assert(crypto != null, \"platform does not support secure random numbers\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"randomBytes\"\n    });\n    assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, \"invalid length\", \"length\", length);\n    const result = new Uint8Array(length);\n    crypto.getRandomValues(result);\n    return result;\n}\n//# sourceMappingURL=crypto-browser.js.map"]},"metadata":{},"sourceType":"module"}