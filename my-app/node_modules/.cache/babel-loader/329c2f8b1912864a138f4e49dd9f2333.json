{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateMethodGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldSet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _classPrivateFieldGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _defineProperty from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */\n// @TODO:\n// - Add the batching API\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\nimport { AbiCoder } from \"../abi/index.js\";\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { TypedDataEncoder } from \"../hash/index.js\";\nimport { accessListify } from \"../transaction/index.js\";\nimport { defineProperties, getBigInt, hexlify, isHexString, toQuantity, toUtf8Bytes, makeError, assert, assertArgument, FetchRequest, resolveProperties } from \"../utils/index.js\";\nimport { AbstractProvider, UnmanagedSubscriber } from \"./abstract-provider.js\";\nimport { AbstractSigner } from \"./abstract-signer.js\";\nimport { Network } from \"./network.js\";\nimport { FilterIdEventSubscriber, FilterIdPendingSubscriber } from \"./subscriber-filterid.js\";\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy(value) {\n  if (value == null || Primitive.indexOf(typeof value) >= 0) {\n    return value;\n  }\n  // Keep any Addressable\n  if (typeof value.getAddress === \"function\") {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    return value.map(deepCopy);\n  }\n  if (typeof value === \"object\") {\n    return Object.keys(value).reduce((accum, key) => {\n      accum[key] = value[key];\n      return accum;\n    }, {});\n  }\n  throw new Error(\"should not happen: \".concat(value, \" (\").concat(typeof value, \")\"));\n}\nfunction stall(duration) {\n  return new Promise(resolve => {\n    setTimeout(resolve, duration);\n  });\n}\nfunction getLowerCase(value) {\n  if (value) {\n    return value.toLowerCase();\n  }\n  return value;\n}\nfunction isPollable(value) {\n  return value && typeof value.pollingInterval === \"number\";\n}\nconst defaultOptions = {\n  polling: false,\n  staticNetwork: null,\n  batchStallTime: 10,\n  batchMaxSize: 1 << 20,\n  batchMaxCount: 100,\n  cacheTimeout: 250,\n  pollingInterval: 4000\n};\n// @TODO: Unchecked Signers\nexport class JsonRpcSigner extends AbstractSigner {\n  constructor(provider, address) {\n    super(provider);\n    _defineProperty(this, \"address\", void 0);\n    address = getAddress(address);\n    defineProperties(this, {\n      address\n    });\n  }\n  connect(provider) {\n    assert(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"signer.connect\"\n    });\n  }\n  async getAddress() {\n    return this.address;\n  }\n  // JSON-RPC will automatially fill in nonce, etc. so we just check from\n  async populateTransaction(tx) {\n    return await this.populateCall(tx);\n  }\n  // Returns just the hash of the transaction after sent, which is what\n  // the bare JSON-RPC API does;\n  async sendUncheckedTransaction(_tx) {\n    const tx = deepCopy(_tx);\n    const promises = [];\n    // Make sure the from matches the sender\n    if (tx.from) {\n      const _from = tx.from;\n      promises.push((async () => {\n        const from = await resolveAddress(_from, this.provider);\n        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n        tx.from = from;\n      })());\n    } else {\n      tx.from = this.address;\n    }\n    // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n    // wishes to use this, it is easy to specify explicitly, otherwise\n    // we look it up for them.\n    if (tx.gasLimit == null) {\n      promises.push((async () => {\n        tx.gasLimit = await this.provider.estimateGas({\n          ...tx,\n          from: this.address\n        });\n      })());\n    }\n    // The address may be an ENS name or Addressable\n    if (tx.to != null) {\n      const _to = tx.to;\n      promises.push((async () => {\n        tx.to = await resolveAddress(_to, this.provider);\n      })());\n    }\n    // Wait until all of our properties are filled in\n    if (promises.length) {\n      await Promise.all(promises);\n    }\n    const hexTx = this.provider.getRpcTransaction(tx);\n    return this.provider.send(\"eth_sendTransaction\", [hexTx]);\n  }\n  async sendTransaction(tx) {\n    // This cannot be mined any earlier than any recent block\n    const blockNumber = await this.provider.getBlockNumber();\n    // Send the transaction\n    const hash = await this.sendUncheckedTransaction(tx);\n    // Unfortunately, JSON-RPC only provides and opaque transaction hash\n    // for a response, and we need the actual transaction, so we poll\n    // for it; it should show up very quickly\n    return await new Promise((resolve, reject) => {\n      const timeouts = [1000, 100];\n      const checkTx = async () => {\n        // Try getting the transaction\n        const tx = await this.provider.getTransaction(hash);\n        if (tx != null) {\n          resolve(tx.replaceableTransaction(blockNumber));\n          return;\n        }\n        // Wait another 4 seconds\n        this.provider._setTimeout(() => {\n          checkTx();\n        }, timeouts.pop() || 4000);\n      };\n      checkTx();\n    });\n  }\n  async signTransaction(_tx) {\n    const tx = deepCopy(_tx);\n    // Make sure the from matches the sender\n    if (tx.from) {\n      const from = await resolveAddress(tx.from, this.provider);\n      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n      tx.from = from;\n    } else {\n      tx.from = this.address;\n    }\n    const hexTx = this.provider.getRpcTransaction(tx);\n    return await this.provider.send(\"eth_signTransaction\", [hexTx]);\n  }\n  async signMessage(_message) {\n    const message = typeof _message === \"string\" ? toUtf8Bytes(_message) : _message;\n    return await this.provider.send(\"personal_sign\", [hexlify(message), this.address.toLowerCase()]);\n  }\n  async signTypedData(domain, types, _value) {\n    const value = deepCopy(_value);\n    // Populate any ENS names (in-place)\n    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async value => {\n      const address = await resolveAddress(value);\n      assertArgument(address != null, \"TypedData does not support null address\", \"value\", value);\n      return address;\n    });\n    return await this.provider.send(\"eth_signTypedData_v4\", [this.address.toLowerCase(), JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))]);\n  }\n  async unlock(password) {\n    return this.provider.send(\"personal_unlockAccount\", [this.address.toLowerCase(), password, null]);\n  }\n  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n  async _legacySignMessage(_message) {\n    const message = typeof _message === \"string\" ? toUtf8Bytes(_message) : _message;\n    return await this.provider.send(\"eth_sign\", [this.address.toLowerCase(), hexlify(message)]);\n  }\n}\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */\nvar _options = /*#__PURE__*/new WeakMap();\nvar _nextId = /*#__PURE__*/new WeakMap();\nvar _payloads = /*#__PURE__*/new WeakMap();\nvar _drainTimer = /*#__PURE__*/new WeakMap();\nvar _notReady = /*#__PURE__*/new WeakMap();\nvar _network = /*#__PURE__*/new WeakMap();\nvar _pendingDetectNetwork = /*#__PURE__*/new WeakMap();\nvar _scheduleDrain = /*#__PURE__*/new WeakSet();\nexport class JsonRpcApiProvider extends AbstractProvider {\n  // The next ID to use for the JSON-RPC ID field\n\n  // Payloads are queued and triggered in batches using the drainTimer\n\n  constructor(network, options) {\n    super(network, options);\n    _classPrivateMethodInitSpec(this, _scheduleDrain);\n    _classPrivateFieldInitSpec(this, _options, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _nextId, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _payloads, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _drainTimer, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _notReady, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _network, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _pendingDetectNetwork, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _nextId, 1);\n    _classPrivateFieldSet(this, _options, Object.assign({}, defaultOptions, options || {}));\n    _classPrivateFieldSet(this, _payloads, []);\n    _classPrivateFieldSet(this, _drainTimer, null);\n    _classPrivateFieldSet(this, _network, null);\n    _classPrivateFieldSet(this, _pendingDetectNetwork, null);\n    {\n      let resolve = null;\n      const promise = new Promise(_resolve => {\n        resolve = _resolve;\n      });\n      _classPrivateFieldSet(this, _notReady, {\n        promise,\n        resolve\n      });\n    }\n    const staticNetwork = this._getOption(\"staticNetwork\");\n    if (typeof staticNetwork === \"boolean\") {\n      assertArgument(!staticNetwork || network !== \"any\", \"staticNetwork cannot be used on special network 'any'\", \"options\", options);\n      if (staticNetwork && network != null) {\n        _classPrivateFieldSet(this, _network, Network.from(network));\n      }\n    } else if (staticNetwork) {\n      // Make sure any static network is compatbile with the provided netwrok\n      assertArgument(network == null || staticNetwork.matches(network), \"staticNetwork MUST match network object\", \"options\", options);\n      _classPrivateFieldSet(this, _network, staticNetwork);\n    }\n  }\n  /**\n   *  Returns the value associated with the option %%key%%.\n   *\n   *  Sub-classes can use this to inquire about configuration options.\n   */\n  _getOption(key) {\n    return _classPrivateFieldGet(this, _options)[key];\n  }\n  /**\n   *  Gets the [[Network]] this provider has committed to. On each call, the network\n   *  is detected, and if it has changed, the call will reject.\n   */\n  get _network() {\n    assert(_classPrivateFieldGet(this, _network), \"network is not available yet\", \"NETWORK_ERROR\");\n    return _classPrivateFieldGet(this, _network);\n  }\n  /**\n   *  Resolves to the non-normalized value by performing %%req%%.\n   *\n   *  Sub-classes may override this to modify behavior of actions,\n   *  and should generally call ``super._perform`` as a fallback.\n   */\n  async _perform(req) {\n    // Legacy networks do not like the type field being passed along (which\n    // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n    if (req.method === \"call\" || req.method === \"estimateGas\") {\n      let tx = req.transaction;\n      if (tx && tx.type != null && getBigInt(tx.type)) {\n        // If there are no EIP-1559 properties, it might be non-EIP-a559\n        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n          const feeData = await this.getFeeData();\n          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n            // Network doesn't know about EIP-1559 (and hence type)\n            req = Object.assign({}, req, {\n              transaction: Object.assign({}, tx, {\n                type: undefined\n              })\n            });\n          }\n        }\n      }\n    }\n    const request = this.getRpcRequest(req);\n    if (request != null) {\n      return await this.send(request.method, request.args);\n    }\n    return super._perform(req);\n  }\n  /**\n   *  Sub-classes may override this; it detects the *actual* network that\n   *  we are **currently** connected to.\n   *\n   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n   *  _send primitive must be used instead.\n   */\n  async _detectNetwork() {\n    const network = this._getOption(\"staticNetwork\");\n    if (network) {\n      if (network === true) {\n        if (_classPrivateFieldGet(this, _network)) {\n          return _classPrivateFieldGet(this, _network);\n        }\n      } else {\n        return network;\n      }\n    }\n    if (_classPrivateFieldGet(this, _pendingDetectNetwork)) {\n      return await _classPrivateFieldGet(this, _pendingDetectNetwork);\n    }\n    // If we are ready, use ``send``, which enabled requests to be batched\n    if (this.ready) {\n      _classPrivateFieldSet(this, _pendingDetectNetwork, (async () => {\n        const result = Network.from(getBigInt(await this.send(\"eth_chainId\", [])));\n        _classPrivateFieldSet(this, _pendingDetectNetwork, null);\n        return result;\n      })());\n      return await _classPrivateFieldGet(this, _pendingDetectNetwork);\n    }\n    // We are not ready yet; use the primitive _send\n    _classPrivateFieldSet(this, _pendingDetectNetwork, (async (_this$nextId, _this$nextId2) => {\n      const payload = {\n        id: (_classPrivateFieldSet(this, _nextId, (_this$nextId = _classPrivateFieldGet(this, _nextId), _this$nextId2 = _this$nextId++, _this$nextId)), _this$nextId2),\n        method: \"eth_chainId\",\n        params: [],\n        jsonrpc: \"2.0\"\n      };\n      this.emit(\"debug\", {\n        action: \"sendRpcPayload\",\n        payload\n      });\n      let result;\n      try {\n        result = (await this._send(payload))[0];\n        _classPrivateFieldSet(this, _pendingDetectNetwork, null);\n      } catch (error) {\n        _classPrivateFieldSet(this, _pendingDetectNetwork, null);\n        this.emit(\"debug\", {\n          action: \"receiveRpcError\",\n          error\n        });\n        throw error;\n      }\n      this.emit(\"debug\", {\n        action: \"receiveRpcResult\",\n        result\n      });\n      if (\"result\" in result) {\n        return Network.from(getBigInt(result.result));\n      }\n      throw this.getRpcError(payload, result);\n    })());\n    return await _classPrivateFieldGet(this, _pendingDetectNetwork);\n  }\n  /**\n   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n   *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n   *  ``super._start()`` **MUST** be called.\n   *\n   *  Calling it multiple times is safe and has no effect.\n   */\n  _start() {\n    if (_classPrivateFieldGet(this, _notReady) == null || _classPrivateFieldGet(this, _notReady).resolve == null) {\n      return;\n    }\n    _classPrivateFieldGet(this, _notReady).resolve();\n    _classPrivateFieldSet(this, _notReady, null);\n    (async () => {\n      // Bootstrap the network\n      while (_classPrivateFieldGet(this, _network) == null && !this.destroyed) {\n        try {\n          _classPrivateFieldSet(this, _network, await this._detectNetwork());\n        } catch (error) {\n          if (this.destroyed) {\n            break;\n          }\n          console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n          this.emit(\"error\", makeError(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", {\n            event: \"initial-network-discovery\",\n            info: {\n              error\n            }\n          }));\n          await stall(1000);\n        }\n      }\n      // Start dispatching requests\n      _classPrivateMethodGet(this, _scheduleDrain, _scheduleDrain2).call(this);\n    })();\n  }\n  /**\n   *  Resolves once the [[_start]] has been called. This can be used in\n   *  sub-classes to defer sending data until the connection has been\n   *  established.\n   */\n  async _waitUntilReady() {\n    if (_classPrivateFieldGet(this, _notReady) == null) {\n      return;\n    }\n    return await _classPrivateFieldGet(this, _notReady).promise;\n  }\n  /**\n   *  Return a Subscriber that will manage the %%sub%%.\n   *\n   *  Sub-classes may override this to modify the behavior of\n   *  subscription management.\n   */\n  _getSubscriber(sub) {\n    // Pending Filters aren't availble via polling\n    if (sub.type === \"pending\") {\n      return new FilterIdPendingSubscriber(this);\n    }\n    if (sub.type === \"event\") {\n      if (this._getOption(\"polling\")) {\n        return new PollingEventSubscriber(this, sub.filter);\n      }\n      return new FilterIdEventSubscriber(this, sub.filter);\n    }\n    // Orphaned Logs are handled automatically, by the filter, since\n    // logs with removed are emitted by it\n    if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n      return new UnmanagedSubscriber(\"orphan\");\n    }\n    return super._getSubscriber(sub);\n  }\n  /**\n   *  Returns true only if the [[_start]] has been called.\n   */\n  get ready() {\n    return _classPrivateFieldGet(this, _notReady) == null;\n  }\n  /**\n   *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n   *  which has all values hexlified and any numeric values converted\n   *  to Quantity values.\n   */\n  getRpcTransaction(tx) {\n    const result = {};\n    // JSON-RPC now requires numeric values to be \"quantity\" values\n    [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(key => {\n      if (tx[key] == null) {\n        return;\n      }\n      let dstKey = key;\n      if (key === \"gasLimit\") {\n        dstKey = \"gas\";\n      }\n      result[dstKey] = toQuantity(getBigInt(tx[key], \"tx.\".concat(key)));\n    });\n    // Make sure addresses and data are lowercase\n    [\"from\", \"to\", \"data\"].forEach(key => {\n      if (tx[key] == null) {\n        return;\n      }\n      result[key] = hexlify(tx[key]);\n    });\n    // Normalize the access list object\n    if (tx.accessList) {\n      result[\"accessList\"] = accessListify(tx.accessList);\n    }\n    return result;\n  }\n  /**\n   *  Returns the request method and arguments required to perform\n   *  %%req%%.\n   */\n  getRpcRequest(req) {\n    switch (req.method) {\n      case \"chainId\":\n        return {\n          method: \"eth_chainId\",\n          args: []\n        };\n      case \"getBlockNumber\":\n        return {\n          method: \"eth_blockNumber\",\n          args: []\n        };\n      case \"getGasPrice\":\n        return {\n          method: \"eth_gasPrice\",\n          args: []\n        };\n      case \"getPriorityFee\":\n        return {\n          method: \"eth_maxPriorityFeePerGas\",\n          args: []\n        };\n      case \"getBalance\":\n        return {\n          method: \"eth_getBalance\",\n          args: [getLowerCase(req.address), req.blockTag]\n        };\n      case \"getTransactionCount\":\n        return {\n          method: \"eth_getTransactionCount\",\n          args: [getLowerCase(req.address), req.blockTag]\n        };\n      case \"getCode\":\n        return {\n          method: \"eth_getCode\",\n          args: [getLowerCase(req.address), req.blockTag]\n        };\n      case \"getStorage\":\n        return {\n          method: \"eth_getStorageAt\",\n          args: [getLowerCase(req.address), \"0x\" + req.position.toString(16), req.blockTag]\n        };\n      case \"broadcastTransaction\":\n        return {\n          method: \"eth_sendRawTransaction\",\n          args: [req.signedTransaction]\n        };\n      case \"getBlock\":\n        if (\"blockTag\" in req) {\n          return {\n            method: \"eth_getBlockByNumber\",\n            args: [req.blockTag, !!req.includeTransactions]\n          };\n        } else if (\"blockHash\" in req) {\n          return {\n            method: \"eth_getBlockByHash\",\n            args: [req.blockHash, !!req.includeTransactions]\n          };\n        }\n        break;\n      case \"getTransaction\":\n        return {\n          method: \"eth_getTransactionByHash\",\n          args: [req.hash]\n        };\n      case \"getTransactionReceipt\":\n        return {\n          method: \"eth_getTransactionReceipt\",\n          args: [req.hash]\n        };\n      case \"call\":\n        return {\n          method: \"eth_call\",\n          args: [this.getRpcTransaction(req.transaction), req.blockTag]\n        };\n      case \"estimateGas\":\n        {\n          return {\n            method: \"eth_estimateGas\",\n            args: [this.getRpcTransaction(req.transaction)]\n          };\n        }\n      case \"getLogs\":\n        if (req.filter && req.filter.address != null) {\n          if (Array.isArray(req.filter.address)) {\n            req.filter.address = req.filter.address.map(getLowerCase);\n          } else {\n            req.filter.address = getLowerCase(req.filter.address);\n          }\n        }\n        return {\n          method: \"eth_getLogs\",\n          args: [req.filter]\n        };\n    }\n    return null;\n  }\n  /**\n   *  Returns an ethers-style Error for the given JSON-RPC error\n   *  %%payload%%, coalescing the various strings and error shapes\n   *  that different nodes return, coercing them into a machine-readable\n   *  standardized error.\n   */\n  getRpcError(payload, _error) {\n    const {\n      method\n    } = payload;\n    const {\n      error\n    } = _error;\n    if (method === \"eth_estimateGas\" && error.message) {\n      const msg = error.message;\n      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n        return makeError(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n          transaction: payload.params[0],\n          info: {\n            payload,\n            error\n          }\n        });\n      }\n    }\n    if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n      const result = spelunkData(error);\n      const e = AbiCoder.getBuiltinCallException(method === \"eth_call\" ? \"call\" : \"estimateGas\", payload.params[0], result ? result.data : null);\n      e.info = {\n        error,\n        payload\n      };\n      return e;\n    }\n    // Only estimateGas and call can return arbitrary contract-defined text, so now we\n    // we can process text safely.\n    const message = JSON.stringify(spelunkMessage(error));\n    if (typeof error.message === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n      const actionMap = {\n        eth_sign: \"signMessage\",\n        personal_sign: \"signMessage\",\n        eth_signTypedData_v4: \"signTypedData\",\n        eth_signTransaction: \"signTransaction\",\n        eth_sendTransaction: \"sendTransaction\",\n        eth_requestAccounts: \"requestAccess\",\n        wallet_requestAccounts: \"requestAccess\"\n      };\n      return makeError(\"user rejected action\", \"ACTION_REJECTED\", {\n        action: actionMap[method] || \"unknown\",\n        reason: \"rejected\",\n        info: {\n          payload,\n          error\n        }\n      });\n    }\n    if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n      const transaction = payload.params[0];\n      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n        return makeError(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n          transaction,\n          info: {\n            error\n          }\n        });\n      }\n      if (message.match(/nonce/i) && message.match(/too low/i)) {\n        return makeError(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n          transaction,\n          info: {\n            error\n          }\n        });\n      }\n      // \"replacement transaction underpriced\"\n      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n        return makeError(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n          transaction,\n          info: {\n            error\n          }\n        });\n      }\n      if (message.match(/only replay-protected/i)) {\n        return makeError(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n          operation: method,\n          info: {\n            transaction,\n            info: {\n              error\n            }\n          }\n        });\n      }\n    }\n    let unsupported = !!message.match(/the method .* does not exist/i);\n    if (!unsupported) {\n      if (error && error.details && error.details.startsWith(\"Unauthorized method:\")) {\n        unsupported = true;\n      }\n    }\n    if (unsupported) {\n      return makeError(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n        operation: payload.method,\n        info: {\n          error,\n          payload\n        }\n      });\n    }\n    return makeError(\"could not coalesce error\", \"UNKNOWN_ERROR\", {\n      error,\n      payload\n    });\n  }\n  /**\n   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n   *  over the underlying channel. This can be used to call methods\n   *  on the backend that do not have a high-level API within the Provider\n   *  API.\n   *\n   *  This method queues requests according to the batch constraints\n   *  in the options, assigns the request a unique ID.\n   *\n   *  **Do NOT override** this method in sub-classes; instead\n   *  override [[_send]] or force the options values in the\n   *  call to the constructor to modify this method's behavior.\n   */\n  send(method, params) {\n    var _this$nextId3, _this$nextId4;\n    // @TODO: cache chainId?? purge on switch_networks\n    // We have been destroyed; no operations are supported anymore\n    if (this.destroyed) {\n      return Promise.reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n        operation: method\n      }));\n    }\n    const id = (_classPrivateFieldSet(this, _nextId, (_this$nextId3 = _classPrivateFieldGet(this, _nextId), _this$nextId4 = _this$nextId3++, _this$nextId3)), _this$nextId4);\n    const promise = new Promise((resolve, reject) => {\n      _classPrivateFieldGet(this, _payloads).push({\n        resolve,\n        reject,\n        payload: {\n          method,\n          params,\n          id,\n          jsonrpc: \"2.0\"\n        }\n      });\n    });\n    // If there is not a pending drainTimer, set one\n    _classPrivateMethodGet(this, _scheduleDrain, _scheduleDrain2).call(this);\n    return promise;\n  }\n  /**\n   *  Resolves to the [[Signer]] account for  %%address%% managed by\n   *  the client.\n   *\n   *  If the %%address%% is a number, it is used as an index in the\n   *  the accounts from [[listAccounts]].\n   *\n   *  This can only be used on clients which manage accounts (such as\n   *  Geth with imported account or MetaMask).\n   *\n   *  Throws if the account doesn't exist.\n   */\n  async getSigner(address) {\n    if (address == null) {\n      address = 0;\n    }\n    const accountsPromise = this.send(\"eth_accounts\", []);\n    // Account index\n    if (typeof address === \"number\") {\n      const accounts = await accountsPromise;\n      if (address >= accounts.length) {\n        throw new Error(\"no such account\");\n      }\n      return new JsonRpcSigner(this, accounts[address]);\n    }\n    const {\n      accounts\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      accounts: accountsPromise\n    });\n    // Account address\n    address = getAddress(address);\n    for (const account of accounts) {\n      if (getAddress(account) === address) {\n        return new JsonRpcSigner(this, address);\n      }\n    }\n    throw new Error(\"invalid account\");\n  }\n  async listAccounts() {\n    const accounts = await this.send(\"eth_accounts\", []);\n    return accounts.map(a => new JsonRpcSigner(this, a));\n  }\n  destroy() {\n    // Stop processing requests\n    if (_classPrivateFieldGet(this, _drainTimer)) {\n      clearTimeout(_classPrivateFieldGet(this, _drainTimer));\n      _classPrivateFieldSet(this, _drainTimer, null);\n    }\n    // Cancel all pending requests\n    for (const {\n      payload,\n      reject\n    } of _classPrivateFieldGet(this, _payloads)) {\n      reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n        operation: payload.method\n      }));\n    }\n    _classPrivateFieldSet(this, _payloads, []);\n    // Parent clean-up\n    super.destroy();\n  }\n}\n// @TODO: remove this in v7, it is not exported because this functionality\n// is exposed in the JsonRpcApiProvider by setting polling to true. It should\n// be safe to remove regardless, because it isn't reachable, but just in case.\n/**\n *  @_ignore:\n */\nfunction _scheduleDrain2() {\n  if (_classPrivateFieldGet(this, _drainTimer)) {\n    return;\n  }\n  // If we aren't using batching, no hard in sending it immeidately\n  const stallTime = this._getOption(\"batchMaxCount\") === 1 ? 0 : this._getOption(\"batchStallTime\");\n  _classPrivateFieldSet(this, _drainTimer, setTimeout(() => {\n    _classPrivateFieldSet(this, _drainTimer, null);\n    const payloads = _classPrivateFieldGet(this, _payloads);\n    _classPrivateFieldSet(this, _payloads, []);\n    while (payloads.length) {\n      // Create payload batches that satisfy our batch constraints\n      const batch = [payloads.shift()];\n      while (payloads.length) {\n        if (batch.length === _classPrivateFieldGet(this, _options).batchMaxCount) {\n          break;\n        }\n        batch.push(payloads.shift());\n        const bytes = JSON.stringify(batch.map(p => p.payload));\n        if (bytes.length > _classPrivateFieldGet(this, _options).batchMaxSize) {\n          payloads.unshift(batch.pop());\n          break;\n        }\n      }\n      // Process the result to each payload\n      (async () => {\n        const payload = batch.length === 1 ? batch[0].payload : batch.map(p => p.payload);\n        this.emit(\"debug\", {\n          action: \"sendRpcPayload\",\n          payload\n        });\n        try {\n          const result = await this._send(payload);\n          this.emit(\"debug\", {\n            action: \"receiveRpcResult\",\n            result\n          });\n          // Process results in batch order\n          for (const {\n            resolve,\n            reject,\n            payload\n          } of batch) {\n            if (this.destroyed) {\n              reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method\n              }));\n              continue;\n            }\n            // Find the matching result\n            const resp = result.filter(r => r.id === payload.id)[0];\n            // No result; the node failed us in unexpected ways\n            if (resp == null) {\n              const error = makeError(\"missing response for request\", \"BAD_DATA\", {\n                value: result,\n                info: {\n                  payload\n                }\n              });\n              this.emit(\"error\", error);\n              reject(error);\n              continue;\n            }\n            // The response is an error\n            if (\"error\" in resp) {\n              reject(this.getRpcError(payload, resp));\n              continue;\n            }\n            // All good; send the result\n            resolve(resp.result);\n          }\n        } catch (error) {\n          this.emit(\"debug\", {\n            action: \"receiveRpcError\",\n            error\n          });\n          for (const {\n            reject\n          } of batch) {\n            // @TODO: augment the error with the payload\n            reject(error);\n          }\n        }\n      })();\n    }\n  }, stallTime));\n}\nvar _pollingInterval = /*#__PURE__*/new WeakMap();\nexport class JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n  constructor(network, options) {\n    super(network, options);\n    _classPrivateFieldInitSpec(this, _pollingInterval, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _pollingInterval, 4000);\n  }\n  _getSubscriber(sub) {\n    const subscriber = super._getSubscriber(sub);\n    if (isPollable(subscriber)) {\n      subscriber.pollingInterval = _classPrivateFieldGet(this, _pollingInterval);\n    }\n    return subscriber;\n  }\n  /**\n   *  The polling interval (default: 4000 ms)\n   */\n  get pollingInterval() {\n    return _classPrivateFieldGet(this, _pollingInterval);\n  }\n  set pollingInterval(value) {\n    if (!Number.isInteger(value) || value < 0) {\n      throw new Error(\"invalid interval\");\n    }\n    _classPrivateFieldSet(this, _pollingInterval, value);\n    this._forEachSubscriber(sub => {\n      if (isPollable(sub)) {\n        sub.pollingInterval = _classPrivateFieldGet(this, _pollingInterval);\n      }\n    });\n  }\n}\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */\nvar _connect = /*#__PURE__*/new WeakMap();\nexport class JsonRpcProvider extends JsonRpcApiPollingProvider {\n  constructor(url, network, options) {\n    if (url == null) {\n      url = \"http:/\\/localhost:8545\";\n    }\n    super(network, options);\n    _classPrivateFieldInitSpec(this, _connect, {\n      writable: true,\n      value: void 0\n    });\n    if (typeof url === \"string\") {\n      _classPrivateFieldSet(this, _connect, new FetchRequest(url));\n    } else {\n      _classPrivateFieldSet(this, _connect, url.clone());\n    }\n  }\n  _getConnection() {\n    return _classPrivateFieldGet(this, _connect).clone();\n  }\n  async send(method, params) {\n    // All requests are over HTTP, so we can just start handling requests\n    // We do this here rather than the constructor so that we don't send any\n    // requests to the network (i.e. eth_chainId) until we absolutely have to.\n    await this._start();\n    return await super.send(method, params);\n  }\n  async _send(payload) {\n    // Configure a POST connection for the requested method\n    const request = this._getConnection();\n    request.body = JSON.stringify(payload);\n    request.setHeader(\"content-type\", \"application/json\");\n    const response = await request.send();\n    response.assertOk();\n    let resp = response.bodyJson;\n    if (!Array.isArray(resp)) {\n      resp = [resp];\n    }\n    return resp;\n  }\n}\nfunction spelunkData(value) {\n  if (value == null) {\n    return null;\n  }\n  // These *are* the droids we're looking for.\n  if (typeof value.message === \"string\" && value.message.match(/revert/i) && isHexString(value.data)) {\n    return {\n      message: value.message,\n      data: value.data\n    };\n  }\n  // Spelunk further...\n  if (typeof value === \"object\") {\n    for (const key in value) {\n      const result = spelunkData(value[key]);\n      if (result) {\n        return result;\n      }\n    }\n    return null;\n  }\n  // Might be a JSON string we can further descend...\n  if (typeof value === \"string\") {\n    try {\n      return spelunkData(JSON.parse(value));\n    } catch (error) {}\n  }\n  return null;\n}\nfunction _spelunkMessage(value, result) {\n  if (value == null) {\n    return;\n  }\n  // These *are* the droids we're looking for.\n  if (typeof value.message === \"string\") {\n    result.push(value.message);\n  }\n  // Spelunk further...\n  if (typeof value === \"object\") {\n    for (const key in value) {\n      _spelunkMessage(value[key], result);\n    }\n  }\n  // Might be a JSON string we can further descend...\n  if (typeof value === \"string\") {\n    try {\n      return _spelunkMessage(JSON.parse(value), result);\n    } catch (error) {}\n  }\n}\nfunction spelunkMessage(value) {\n  const result = [];\n  _spelunkMessage(value, result);\n  return result;\n}","map":{"version":3,"sources":["../../src.ts/providers/provider-jsonrpc.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */\n// @TODO:\n// - Add the batching API\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\nimport { AbiCoder } from \"../abi/index.js\";\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { TypedDataEncoder } from \"../hash/index.js\";\nimport { accessListify } from \"../transaction/index.js\";\nimport { defineProperties, getBigInt, hexlify, isHexString, toQuantity, toUtf8Bytes, makeError, assert, assertArgument, FetchRequest, resolveProperties } from \"../utils/index.js\";\nimport { AbstractProvider, UnmanagedSubscriber } from \"./abstract-provider.js\";\nimport { AbstractSigner } from \"./abstract-signer.js\";\nimport { Network } from \"./network.js\";\nimport { FilterIdEventSubscriber, FilterIdPendingSubscriber } from \"./subscriber-filterid.js\";\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy(value) {\n    if (value == null || Primitive.indexOf(typeof (value)) >= 0) {\n        return value;\n    }\n    // Keep any Addressable\n    if (typeof (value.getAddress) === \"function\") {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return (value.map(deepCopy));\n    }\n    if (typeof (value) === \"object\") {\n        return Object.keys(value).reduce((accum, key) => {\n            accum[key] = value[key];\n            return accum;\n        }, {});\n    }\n    throw new Error(`should not happen: ${value} (${typeof (value)})`);\n}\nfunction stall(duration) {\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nfunction isPollable(value) {\n    return (value && typeof (value.pollingInterval) === \"number\");\n}\nconst defaultOptions = {\n    polling: false,\n    staticNetwork: null,\n    batchStallTime: 10,\n    batchMaxSize: (1 << 20),\n    batchMaxCount: 100,\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n// @TODO: Unchecked Signers\nexport class JsonRpcSigner extends AbstractSigner {\n    address;\n    constructor(provider, address) {\n        super(provider);\n        address = getAddress(address);\n        defineProperties(this, { address });\n    }\n    connect(provider) {\n        assert(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"signer.connect\"\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    // JSON-RPC will automatially fill in nonce, etc. so we just check from\n    async populateTransaction(tx) {\n        return await this.populateCall(tx);\n    }\n    // Returns just the hash of the transaction after sent, which is what\n    // the bare JSON-RPC API does;\n    async sendUncheckedTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        const promises = [];\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const _from = tx.from;\n            promises.push((async () => {\n                const from = await resolveAddress(_from, this.provider);\n                assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n                tx.from = from;\n            })());\n        }\n        else {\n            tx.from = this.address;\n        }\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (tx.gasLimit == null) {\n            promises.push((async () => {\n                tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });\n            })());\n        }\n        // The address may be an ENS name or Addressable\n        if (tx.to != null) {\n            const _to = tx.to;\n            promises.push((async () => {\n                tx.to = await resolveAddress(_to, this.provider);\n            })());\n        }\n        // Wait until all of our properties are filled in\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return this.provider.send(\"eth_sendTransaction\", [hexTx]);\n    }\n    async sendTransaction(tx) {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider.getBlockNumber();\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(tx);\n        // Unfortunately, JSON-RPC only provides and opaque transaction hash\n        // for a response, and we need the actual transaction, so we poll\n        // for it; it should show up very quickly\n        return await (new Promise((resolve, reject) => {\n            const timeouts = [1000, 100];\n            const checkTx = async () => {\n                // Try getting the transaction\n                const tx = await this.provider.getTransaction(hash);\n                if (tx != null) {\n                    resolve(tx.replaceableTransaction(blockNumber));\n                    return;\n                }\n                // Wait another 4 seconds\n                this.provider._setTimeout(() => { checkTx(); }, timeouts.pop() || 4000);\n            };\n            checkTx();\n        }));\n    }\n    async signTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const from = await resolveAddress(tx.from, this.provider);\n            assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n            tx.from = from;\n        }\n        else {\n            tx.from = this.address;\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return await this.provider.send(\"eth_signTransaction\", [hexTx]);\n    }\n    async signMessage(_message) {\n        const message = ((typeof (_message) === \"string\") ? toUtf8Bytes(_message) : _message);\n        return await this.provider.send(\"personal_sign\", [\n            hexlify(message), this.address.toLowerCase()\n        ]);\n    }\n    async signTypedData(domain, types, _value) {\n        const value = deepCopy(_value);\n        // Populate any ENS names (in-place)\n        const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (value) => {\n            const address = await resolveAddress(value);\n            assertArgument(address != null, \"TypedData does not support null address\", \"value\", value);\n            return address;\n        });\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            this.address.toLowerCase(),\n            JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n    async unlock(password) {\n        return this.provider.send(\"personal_unlockAccount\", [\n            this.address.toLowerCase(), password, null\n        ]);\n    }\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    async _legacySignMessage(_message) {\n        const message = ((typeof (_message) === \"string\") ? toUtf8Bytes(_message) : _message);\n        return await this.provider.send(\"eth_sign\", [\n            this.address.toLowerCase(), hexlify(message)\n        ]);\n    }\n}\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */\nexport class JsonRpcApiProvider extends AbstractProvider {\n    #options;\n    // The next ID to use for the JSON-RPC ID field\n    #nextId;\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads;\n    #drainTimer;\n    #notReady;\n    #network;\n    #pendingDetectNetwork;\n    #scheduleDrain() {\n        if (this.#drainTimer) {\n            return;\n        }\n        // If we aren't using batching, no hard in sending it immeidately\n        const stallTime = (this._getOption(\"batchMaxCount\") === 1) ? 0 : this._getOption(\"batchStallTime\");\n        this.#drainTimer = setTimeout(() => {\n            this.#drainTimer = null;\n            const payloads = this.#payloads;\n            this.#payloads = [];\n            while (payloads.length) {\n                // Create payload batches that satisfy our batch constraints\n                const batch = [(payloads.shift())];\n                while (payloads.length) {\n                    if (batch.length === this.#options.batchMaxCount) {\n                        break;\n                    }\n                    batch.push((payloads.shift()));\n                    const bytes = JSON.stringify(batch.map((p) => p.payload));\n                    if (bytes.length > this.#options.batchMaxSize) {\n                        payloads.unshift((batch.pop()));\n                        break;\n                    }\n                }\n                // Process the result to each payload\n                (async () => {\n                    const payload = ((batch.length === 1) ? batch[0].payload : batch.map((p) => p.payload));\n                    this.emit(\"debug\", { action: \"sendRpcPayload\", payload });\n                    try {\n                        const result = await this._send(payload);\n                        this.emit(\"debug\", { action: \"receiveRpcResult\", result });\n                        // Process results in batch order\n                        for (const { resolve, reject, payload } of batch) {\n                            if (this.destroyed) {\n                                reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: payload.method }));\n                                continue;\n                            }\n                            // Find the matching result\n                            const resp = result.filter((r) => (r.id === payload.id))[0];\n                            // No result; the node failed us in unexpected ways\n                            if (resp == null) {\n                                const error = makeError(\"missing response for request\", \"BAD_DATA\", {\n                                    value: result, info: { payload }\n                                });\n                                this.emit(\"error\", error);\n                                reject(error);\n                                continue;\n                            }\n                            // The response is an error\n                            if (\"error\" in resp) {\n                                reject(this.getRpcError(payload, resp));\n                                continue;\n                            }\n                            // All good; send the result\n                            resolve(resp.result);\n                        }\n                    }\n                    catch (error) {\n                        this.emit(\"debug\", { action: \"receiveRpcError\", error });\n                        for (const { reject } of batch) {\n                            // @TODO: augment the error with the payload\n                            reject(error);\n                        }\n                    }\n                })();\n            }\n        }, stallTime);\n    }\n    constructor(network, options) {\n        super(network, options);\n        this.#nextId = 1;\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        this.#payloads = [];\n        this.#drainTimer = null;\n        this.#network = null;\n        this.#pendingDetectNetwork = null;\n        {\n            let resolve = null;\n            const promise = new Promise((_resolve) => {\n                resolve = _resolve;\n            });\n            this.#notReady = { promise, resolve };\n        }\n        const staticNetwork = this._getOption(\"staticNetwork\");\n        if (typeof (staticNetwork) === \"boolean\") {\n            assertArgument(!staticNetwork || network !== \"any\", \"staticNetwork cannot be used on special network 'any'\", \"options\", options);\n            if (staticNetwork && network != null) {\n                this.#network = Network.from(network);\n            }\n        }\n        else if (staticNetwork) {\n            // Make sure any static network is compatbile with the provided netwrok\n            assertArgument(network == null || staticNetwork.matches(network), \"staticNetwork MUST match network object\", \"options\", options);\n            this.#network = staticNetwork;\n        }\n    }\n    /**\n     *  Returns the value associated with the option %%key%%.\n     *\n     *  Sub-classes can use this to inquire about configuration options.\n     */\n    _getOption(key) {\n        return this.#options[key];\n    }\n    /**\n     *  Gets the [[Network]] this provider has committed to. On each call, the network\n     *  is detected, and if it has changed, the call will reject.\n     */\n    get _network() {\n        assert(this.#network, \"network is not available yet\", \"NETWORK_ERROR\");\n        return this.#network;\n    }\n    /**\n     *  Resolves to the non-normalized value by performing %%req%%.\n     *\n     *  Sub-classes may override this to modify behavior of actions,\n     *  and should generally call ``super._perform`` as a fallback.\n     */\n    async _perform(req) {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            let tx = req.transaction;\n            if (tx && tx.type != null && getBigInt(tx.type)) {\n                // If there are no EIP-1559 properties, it might be non-EIP-a559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        req = Object.assign({}, req, {\n                            transaction: Object.assign({}, tx, { type: undefined })\n                        });\n                    }\n                }\n            }\n        }\n        const request = this.getRpcRequest(req);\n        if (request != null) {\n            return await this.send(request.method, request.args);\n        }\n        return super._perform(req);\n    }\n    /**\n     *  Sub-classes may override this; it detects the *actual* network that\n     *  we are **currently** connected to.\n     *\n     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n     *  _send primitive must be used instead.\n     */\n    async _detectNetwork() {\n        const network = this._getOption(\"staticNetwork\");\n        if (network) {\n            if (network === true) {\n                if (this.#network) {\n                    return this.#network;\n                }\n            }\n            else {\n                return network;\n            }\n        }\n        if (this.#pendingDetectNetwork) {\n            return await this.#pendingDetectNetwork;\n        }\n        // If we are ready, use ``send``, which enabled requests to be batched\n        if (this.ready) {\n            this.#pendingDetectNetwork = (async () => {\n                const result = Network.from(getBigInt(await this.send(\"eth_chainId\", [])));\n                this.#pendingDetectNetwork = null;\n                return result;\n            })();\n            return await this.#pendingDetectNetwork;\n        }\n        // We are not ready yet; use the primitive _send\n        this.#pendingDetectNetwork = (async () => {\n            const payload = {\n                id: this.#nextId++, method: \"eth_chainId\", params: [], jsonrpc: \"2.0\"\n            };\n            this.emit(\"debug\", { action: \"sendRpcPayload\", payload });\n            let result;\n            try {\n                result = (await this._send(payload))[0];\n                this.#pendingDetectNetwork = null;\n            }\n            catch (error) {\n                this.#pendingDetectNetwork = null;\n                this.emit(\"debug\", { action: \"receiveRpcError\", error });\n                throw error;\n            }\n            this.emit(\"debug\", { action: \"receiveRpcResult\", result });\n            if (\"result\" in result) {\n                return Network.from(getBigInt(result.result));\n            }\n            throw this.getRpcError(payload, result);\n        })();\n        return await this.#pendingDetectNetwork;\n    }\n    /**\n     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n     *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n     *  ``super._start()`` **MUST** be called.\n     *\n     *  Calling it multiple times is safe and has no effect.\n     */\n    _start() {\n        if (this.#notReady == null || this.#notReady.resolve == null) {\n            return;\n        }\n        this.#notReady.resolve();\n        this.#notReady = null;\n        (async () => {\n            // Bootstrap the network\n            while (this.#network == null && !this.destroyed) {\n                try {\n                    this.#network = await this._detectNetwork();\n                }\n                catch (error) {\n                    if (this.destroyed) {\n                        break;\n                    }\n                    console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n                    this.emit(\"error\", makeError(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", { event: \"initial-network-discovery\", info: { error } }));\n                    await stall(1000);\n                }\n            }\n            // Start dispatching requests\n            this.#scheduleDrain();\n        })();\n    }\n    /**\n     *  Resolves once the [[_start]] has been called. This can be used in\n     *  sub-classes to defer sending data until the connection has been\n     *  established.\n     */\n    async _waitUntilReady() {\n        if (this.#notReady == null) {\n            return;\n        }\n        return await this.#notReady.promise;\n    }\n    /**\n     *  Return a Subscriber that will manage the %%sub%%.\n     *\n     *  Sub-classes may override this to modify the behavior of\n     *  subscription management.\n     */\n    _getSubscriber(sub) {\n        // Pending Filters aren't availble via polling\n        if (sub.type === \"pending\") {\n            return new FilterIdPendingSubscriber(this);\n        }\n        if (sub.type === \"event\") {\n            if (this._getOption(\"polling\")) {\n                return new PollingEventSubscriber(this, sub.filter);\n            }\n            return new FilterIdEventSubscriber(this, sub.filter);\n        }\n        // Orphaned Logs are handled automatically, by the filter, since\n        // logs with removed are emitted by it\n        if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n            return new UnmanagedSubscriber(\"orphan\");\n        }\n        return super._getSubscriber(sub);\n    }\n    /**\n     *  Returns true only if the [[_start]] has been called.\n     */\n    get ready() { return this.#notReady == null; }\n    /**\n     *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n     *  which has all values hexlified and any numeric values converted\n     *  to Quantity values.\n     */\n    getRpcTransaction(tx) {\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach((key) => {\n            if (tx[key] == null) {\n                return;\n            }\n            let dstKey = key;\n            if (key === \"gasLimit\") {\n                dstKey = \"gas\";\n            }\n            result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));\n        });\n        // Make sure addresses and data are lowercase\n        [\"from\", \"to\", \"data\"].forEach((key) => {\n            if (tx[key] == null) {\n                return;\n            }\n            result[key] = hexlify(tx[key]);\n        });\n        // Normalize the access list object\n        if (tx.accessList) {\n            result[\"accessList\"] = accessListify(tx.accessList);\n        }\n        return result;\n    }\n    /**\n     *  Returns the request method and arguments required to perform\n     *  %%req%%.\n     */\n    getRpcRequest(req) {\n        switch (req.method) {\n            case \"chainId\":\n                return { method: \"eth_chainId\", args: [] };\n            case \"getBlockNumber\":\n                return { method: \"eth_blockNumber\", args: [] };\n            case \"getGasPrice\":\n                return { method: \"eth_gasPrice\", args: [] };\n            case \"getPriorityFee\":\n                return { method: \"eth_maxPriorityFeePerGas\", args: [] };\n            case \"getBalance\":\n                return {\n                    method: \"eth_getBalance\",\n                    args: [getLowerCase(req.address), req.blockTag]\n                };\n            case \"getTransactionCount\":\n                return {\n                    method: \"eth_getTransactionCount\",\n                    args: [getLowerCase(req.address), req.blockTag]\n                };\n            case \"getCode\":\n                return {\n                    method: \"eth_getCode\",\n                    args: [getLowerCase(req.address), req.blockTag]\n                };\n            case \"getStorage\":\n                return {\n                    method: \"eth_getStorageAt\",\n                    args: [\n                        getLowerCase(req.address),\n                        (\"0x\" + req.position.toString(16)),\n                        req.blockTag\n                    ]\n                };\n            case \"broadcastTransaction\":\n                return {\n                    method: \"eth_sendRawTransaction\",\n                    args: [req.signedTransaction]\n                };\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return {\n                        method: \"eth_getBlockByNumber\",\n                        args: [req.blockTag, !!req.includeTransactions]\n                    };\n                }\n                else if (\"blockHash\" in req) {\n                    return {\n                        method: \"eth_getBlockByHash\",\n                        args: [req.blockHash, !!req.includeTransactions]\n                    };\n                }\n                break;\n            case \"getTransaction\":\n                return {\n                    method: \"eth_getTransactionByHash\",\n                    args: [req.hash]\n                };\n            case \"getTransactionReceipt\":\n                return {\n                    method: \"eth_getTransactionReceipt\",\n                    args: [req.hash]\n                };\n            case \"call\":\n                return {\n                    method: \"eth_call\",\n                    args: [this.getRpcTransaction(req.transaction), req.blockTag]\n                };\n            case \"estimateGas\": {\n                return {\n                    method: \"eth_estimateGas\",\n                    args: [this.getRpcTransaction(req.transaction)]\n                };\n            }\n            case \"getLogs\":\n                if (req.filter && req.filter.address != null) {\n                    if (Array.isArray(req.filter.address)) {\n                        req.filter.address = req.filter.address.map(getLowerCase);\n                    }\n                    else {\n                        req.filter.address = getLowerCase(req.filter.address);\n                    }\n                }\n                return { method: \"eth_getLogs\", args: [req.filter] };\n        }\n        return null;\n    }\n    /**\n     *  Returns an ethers-style Error for the given JSON-RPC error\n     *  %%payload%%, coalescing the various strings and error shapes\n     *  that different nodes return, coercing them into a machine-readable\n     *  standardized error.\n     */\n    getRpcError(payload, _error) {\n        const { method } = payload;\n        const { error } = _error;\n        if (method === \"eth_estimateGas\" && error.message) {\n            const msg = error.message;\n            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n                return makeError(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: (payload.params[0]),\n                    info: { payload, error }\n                });\n            }\n        }\n        if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n            const result = spelunkData(error);\n            const e = AbiCoder.getBuiltinCallException((method === \"eth_call\") ? \"call\" : \"estimateGas\", (payload.params[0]), (result ? result.data : null));\n            e.info = { error, payload };\n            return e;\n        }\n        // Only estimateGas and call can return arbitrary contract-defined text, so now we\n        // we can process text safely.\n        const message = JSON.stringify(spelunkMessage(error));\n        if (typeof (error.message) === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n            const actionMap = {\n                eth_sign: \"signMessage\",\n                personal_sign: \"signMessage\",\n                eth_signTypedData_v4: \"signTypedData\",\n                eth_signTransaction: \"signTransaction\",\n                eth_sendTransaction: \"sendTransaction\",\n                eth_requestAccounts: \"requestAccess\",\n                wallet_requestAccounts: \"requestAccess\",\n            };\n            return makeError(`user rejected action`, \"ACTION_REJECTED\", {\n                action: (actionMap[method] || \"unknown\"),\n                reason: \"rejected\",\n                info: { payload, error }\n            });\n        }\n        if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n            const transaction = (payload.params[0]);\n            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n                return makeError(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                    transaction, info: { error }\n                });\n            }\n            if (message.match(/nonce/i) && message.match(/too low/i)) {\n                return makeError(\"nonce has already been used\", \"NONCE_EXPIRED\", { transaction, info: { error } });\n            }\n            // \"replacement transaction underpriced\"\n            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n                return makeError(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", { transaction, info: { error } });\n            }\n            if (message.match(/only replay-protected/i)) {\n                return makeError(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n                    operation: method, info: { transaction, info: { error } }\n                });\n            }\n        }\n        let unsupported = !!message.match(/the method .* does not exist/i);\n        if (!unsupported) {\n            if (error && error.details && error.details.startsWith(\"Unauthorized method:\")) {\n                unsupported = true;\n            }\n        }\n        if (unsupported) {\n            return makeError(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method, info: { error, payload }\n            });\n        }\n        return makeError(\"could not coalesce error\", \"UNKNOWN_ERROR\", { error, payload });\n    }\n    /**\n     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n     *  over the underlying channel. This can be used to call methods\n     *  on the backend that do not have a high-level API within the Provider\n     *  API.\n     *\n     *  This method queues requests according to the batch constraints\n     *  in the options, assigns the request a unique ID.\n     *\n     *  **Do NOT override** this method in sub-classes; instead\n     *  override [[_send]] or force the options values in the\n     *  call to the constructor to modify this method's behavior.\n     */\n    send(method, params) {\n        // @TODO: cache chainId?? purge on switch_networks\n        // We have been destroyed; no operations are supported anymore\n        if (this.destroyed) {\n            return Promise.reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: method }));\n        }\n        const id = this.#nextId++;\n        const promise = new Promise((resolve, reject) => {\n            this.#payloads.push({\n                resolve, reject,\n                payload: { method, params, id, jsonrpc: \"2.0\" }\n            });\n        });\n        // If there is not a pending drainTimer, set one\n        this.#scheduleDrain();\n        return promise;\n    }\n    /**\n     *  Resolves to the [[Signer]] account for  %%address%% managed by\n     *  the client.\n     *\n     *  If the %%address%% is a number, it is used as an index in the\n     *  the accounts from [[listAccounts]].\n     *\n     *  This can only be used on clients which manage accounts (such as\n     *  Geth with imported account or MetaMask).\n     *\n     *  Throws if the account doesn't exist.\n     */\n    async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accountsPromise = this.send(\"eth_accounts\", []);\n        // Account index\n        if (typeof (address) === \"number\") {\n            const accounts = (await accountsPromise);\n            if (address >= accounts.length) {\n                throw new Error(\"no such account\");\n            }\n            return new JsonRpcSigner(this, accounts[address]);\n        }\n        const { accounts } = await resolveProperties({\n            network: this.getNetwork(),\n            accounts: accountsPromise\n        });\n        // Account address\n        address = getAddress(address);\n        for (const account of accounts) {\n            if (getAddress(account) === address) {\n                return new JsonRpcSigner(this, address);\n            }\n        }\n        throw new Error(\"invalid account\");\n    }\n    async listAccounts() {\n        const accounts = await this.send(\"eth_accounts\", []);\n        return accounts.map((a) => new JsonRpcSigner(this, a));\n    }\n    destroy() {\n        // Stop processing requests\n        if (this.#drainTimer) {\n            clearTimeout(this.#drainTimer);\n            this.#drainTimer = null;\n        }\n        // Cancel all pending requests\n        for (const { payload, reject } of this.#payloads) {\n            reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: payload.method }));\n        }\n        this.#payloads = [];\n        // Parent clean-up\n        super.destroy();\n    }\n}\n// @TODO: remove this in v7, it is not exported because this functionality\n// is exposed in the JsonRpcApiProvider by setting polling to true. It should\n// be safe to remove regardless, because it isn't reachable, but just in case.\n/**\n *  @_ignore:\n */\nexport class JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n    #pollingInterval;\n    constructor(network, options) {\n        super(network, options);\n        this.#pollingInterval = 4000;\n    }\n    _getSubscriber(sub) {\n        const subscriber = super._getSubscriber(sub);\n        if (isPollable(subscriber)) {\n            subscriber.pollingInterval = this.#pollingInterval;\n        }\n        return subscriber;\n    }\n    /**\n     *  The polling interval (default: 4000 ms)\n     */\n    get pollingInterval() { return this.#pollingInterval; }\n    set pollingInterval(value) {\n        if (!Number.isInteger(value) || value < 0) {\n            throw new Error(\"invalid interval\");\n        }\n        this.#pollingInterval = value;\n        this._forEachSubscriber((sub) => {\n            if (isPollable(sub)) {\n                sub.pollingInterval = this.#pollingInterval;\n            }\n        });\n    }\n}\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */\nexport class JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect;\n    constructor(url, network, options) {\n        if (url == null) {\n            url = \"http:/\\/localhost:8545\";\n        }\n        super(network, options);\n        if (typeof (url) === \"string\") {\n            this.#connect = new FetchRequest(url);\n        }\n        else {\n            this.#connect = url.clone();\n        }\n    }\n    _getConnection() {\n        return this.#connect.clone();\n    }\n    async send(method, params) {\n        // All requests are over HTTP, so we can just start handling requests\n        // We do this here rather than the constructor so that we don't send any\n        // requests to the network (i.e. eth_chainId) until we absolutely have to.\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        // Configure a POST connection for the requested method\n        const request = this._getConnection();\n        request.body = JSON.stringify(payload);\n        request.setHeader(\"content-type\", \"application/json\");\n        const response = await request.send();\n        response.assertOk();\n        let resp = response.bodyJson;\n        if (!Array.isArray(resp)) {\n            resp = [resp];\n        }\n        return resp;\n    }\n}\nfunction spelunkData(value) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\" && value.message.match(/revert/i) && isHexString(value.data)) {\n        return { message: value.message, data: value.data };\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (const key in value) {\n            const result = spelunkData(value[key]);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return spelunkData(JSON.parse(value));\n        }\n        catch (error) { }\n    }\n    return null;\n}\nfunction _spelunkMessage(value, result) {\n    if (value == null) {\n        return;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\") {\n        result.push(value.message);\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (const key in value) {\n            _spelunkMessage(value[key], result);\n        }\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return _spelunkMessage(JSON.parse(value), result);\n        }\n        catch (error) { }\n    }\n}\nfunction spelunkMessage(value) {\n    const result = [];\n    _spelunkMessage(value, result);\n    return result;\n}\n//# sourceMappingURL=provider-jsonrpc.js.map"]},"metadata":{},"sourceType":"module"}