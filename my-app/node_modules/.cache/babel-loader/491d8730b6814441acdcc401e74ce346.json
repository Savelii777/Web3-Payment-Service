{"ast":null,"code":"/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\nfunction checkType(value, type, name) {\n  const types = type.split(\"|\").map(t => t.trim());\n  for (let i = 0; i < types.length; i++) {\n    switch (type) {\n      case \"any\":\n        return;\n      case \"bigint\":\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        if (typeof value === type) {\n          return;\n        }\n    }\n  }\n  const error = new Error(`invalid value for type ${type}`);\n  error.code = \"INVALID_ARGUMENT\";\n  error.argument = `value.${name}`;\n  error.value = value;\n  throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nexport async function resolveProperties(value) {\n  const keys = Object.keys(value);\n  const results = await Promise.all(keys.map(k => Promise.resolve(value[k])));\n  return results.reduce((accum, v, index) => {\n    accum[keys[index]] = v;\n    return accum;\n  }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nexport function defineProperties(target, values, types) {\n  for (let key in values) {\n    let value = values[key];\n    const type = types ? types[key] : null;\n    if (type) {\n      checkType(value, type, key);\n    }\n    Object.defineProperty(target, key, {\n      enumerable: true,\n      value,\n      writable: false\n    });\n  }\n}","map":{"version":3,"sources":["../../src.ts/utils/properties.ts"],"names":[],"mappings":"AAAA;;;;AAIG;AAEH,SAAS,SAAS,CAAC,KAAU,EAAE,IAAY,EAAE,IAAY,EAAA;EACrD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAA,CAAE,CAAC;EAChD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACnC,QAAQ,IAAI;MACR,KAAK,KAAK;QACN;MACJ,KAAK,QAAQ;MACb,KAAK,SAAS;MACd,KAAK,QAAQ;MACb,KAAK,QAAQ;QACT,IAAI,OAAO,KAAM,KAAK,IAAI,EAAE;UAAE;QAAS;IAC9C;EACJ;EAED,MAAM,KAAK,GAAQ,IAAI,KAAK,CAAC,0BAA2B,IAAK,EAAE,CAAC;EAChE,KAAK,CAAC,IAAI,GAAG,kBAAkB;EAC/B,KAAK,CAAC,QAAQ,GAAG,SAAU,IAAK,EAAE;EAClC,KAAK,CAAC,KAAK,GAAG,KAAK;EAEnB,MAAM,KAAK;AACf;AAEA;;;AAGG;AACH,OAAO,eAAe,iBAAiB,CAAI,KAAgD,EAAA;EACvF,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;EAC/B,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAE,CAAC,IAAK,OAAO,CAAC,OAAO,CAAC,KAAK,CAAU,CAAC,CAAC,CAAC,CAAC,CAAC;EACtF,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC,KAAU,EAAE,CAAC,EAAE,KAAK,KAAI;IAC3C,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC;IACtB,OAAO,KAAK;EAChB,CAAC,EAA6B,CAAA,CAAG,CAAC;AACtC;AAEA;;;;AAIG;AACH,OAAM,SAAU,gBAAgB,CAC/B,MAAS,EACT,MAAmC,EACnC,KAAqC,EAAA;EAElC,KAAK,IAAI,GAAG,IAAI,MAAM,EAAE;IACpB,IAAI,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC;IAEvB,MAAM,IAAI,GAAI,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,GAAE,IAAK;IACvC,IAAI,IAAI,EAAE;MAAE,SAAS,CAAC,KAAK,EAAE,IAAI,EAAE,GAAG,CAAC;IAAG;IAE1C,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,GAAG,EAAE;MAAE,UAAU,EAAE,IAAI;MAAE,KAAK;MAAE,QAAQ,EAAE;IAAK,CAAE,CAAC;EACnF;AACL","sourceRoot":"","sourcesContent":["/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\nfunction checkType(value, type, name) {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof (value) === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nexport async function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));\n    return results.reduce((accum, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nexport function defineProperties(target, values, types) {\n    for (let key in values) {\n        let value = values[key];\n        const type = (types ? types[key] : null);\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\n//# sourceMappingURL=properties.js.map"]},"metadata":{},"sourceType":"module"}