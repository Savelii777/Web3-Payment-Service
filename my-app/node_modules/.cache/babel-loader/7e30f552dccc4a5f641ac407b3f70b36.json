{"ast":null,"code":"const Base64 = \")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\";\n/**\n *  @_ignore\n */\nexport function decodeBits(width, data) {\n  const maxValue = (1 << width) - 1;\n  const result = [];\n  let accum = 0,\n    bits = 0,\n    flood = 0;\n  for (let i = 0; i < data.length; i++) {\n    // Accumulate 6 bits of data\n    accum = accum << 6 | Base64.indexOf(data[i]);\n    bits += 6;\n    // While we have enough for a word...\n    while (bits >= width) {\n      // ...read the word\n      const value = accum >> bits - width;\n      accum &= (1 << bits - width) - 1;\n      bits -= width;\n      // A value of 0 indicates we exceeded maxValue, it\n      // floods over into the next value\n      if (value === 0) {\n        flood += maxValue;\n      } else {\n        result.push(value + flood);\n        flood = 0;\n      }\n    }\n  }\n  return result;\n}","map":{"version":3,"sources":["../../src.ts/wordlists/bit-reader.ts"],"names":[],"mappings":"AAAA,MAAM,MAAM,GAAG,kEAAkE;AAEjF;;AAEG;AACH,OAAM,SAAU,UAAU,CAAC,KAAa,EAAE,IAAY,EAAA;EAClD,MAAM,QAAQ,GAAG,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC;EACjC,MAAM,MAAM,GAAkB,EAAG;EACjC,IAAI,KAAK,GAAG,CAAC;IAAE,IAAI,GAAG,CAAC;IAAE,KAAK,GAAG,CAAC;EAClC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IAElC;IACA,KAAK,GAAK,KAAK,IAAI,CAAC,GAAI,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAE;IAChD,IAAI,IAAI,CAAC;IAET;IACA,OAAO,IAAI,IAAI,KAAK,EAAE;MAClB;MACA,MAAM,KAAK,GAAI,KAAK,IAAK,IAAI,GAAG,KAAO;MACvC,KAAK,IAAI,CAAC,CAAC,IAAK,IAAI,GAAG,KAAM,IAAI,CAAC;MAClC,IAAI,IAAI,KAAK;MAEb;MACA;MACA,IAAI,KAAK,KAAK,CAAC,EAAE;QACb,KAAK,IAAI,QAAQ;OACpB,MAAM;QACH,MAAM,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QAC1B,KAAK,GAAG,CAAC;MACZ;IACJ;EACJ;EAED,OAAO,MAAM;AACjB","sourceRoot":"","sourcesContent":["const Base64 = \")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\";\n/**\n *  @_ignore\n */\nexport function decodeBits(width, data) {\n    const maxValue = (1 << width) - 1;\n    const result = [];\n    let accum = 0, bits = 0, flood = 0;\n    for (let i = 0; i < data.length; i++) {\n        // Accumulate 6 bits of data\n        accum = ((accum << 6) | Base64.indexOf(data[i]));\n        bits += 6;\n        // While we have enough for a word...\n        while (bits >= width) {\n            // ...read the word\n            const value = (accum >> (bits - width));\n            accum &= (1 << (bits - width)) - 1;\n            bits -= width;\n            // A value of 0 indicates we exceeded maxValue, it\n            // floods over into the next value\n            if (value === 0) {\n                flood += maxValue;\n            }\n            else {\n                result.push(value + flood);\n                flood = 0;\n            }\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=bit-reader.js.map"]},"metadata":{},"sourceType":"module"}