{"ast":null,"code":"import { ZeroHash } from \"../constants/index.js\";\nimport { concat, dataLength, getBigInt, getBytes, getNumber, hexlify, toBeArray, isHexString, zeroPadValue, assertArgument, assertPrivate } from \"../utils/index.js\";\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst _guard = {};\nfunction toUint256(value) {\n  return zeroPadValue(toBeArray(value), 32);\n}\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */\nexport class Signature {\n  #r;\n  #s;\n  #v;\n  #networkV;\n  /**\n   *  The ``r`` value for a signautre.\n   *\n   *  This represents the ``x`` coordinate of a \"reference\" or\n   *  challenge point, from which the ``y`` can be computed.\n   */\n  get r() {\n    return this.#r;\n  }\n  set r(value) {\n    assertArgument(dataLength(value) === 32, \"invalid r\", \"value\", value);\n    this.#r = hexlify(value);\n  }\n  /**\n   *  The ``s`` value for a signature.\n   */\n  get s() {\n    return this.#s;\n  }\n  set s(_value) {\n    assertArgument(dataLength(_value) === 32, \"invalid s\", \"value\", _value);\n    const value = hexlify(_value);\n    assertArgument(parseInt(value.substring(0, 3)) < 8, \"non-canonical s\", \"value\", value);\n    this.#s = value;\n  }\n  /**\n   *  The ``v`` value for a signature.\n   *\n   *  Since a given ``x`` value for ``r`` has two possible values for\n   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n   *  values to use.\n   *\n   *  It is normalized to the values ``27`` or ``28`` for legacy\n   *  purposes.\n   */\n  get v() {\n    return this.#v;\n  }\n  set v(value) {\n    const v = getNumber(value, \"value\");\n    assertArgument(v === 27 || v === 28, \"invalid v\", \"v\", value);\n    this.#v = v;\n  }\n  /**\n   *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n   *  transactions, this value is ``null``.\n   */\n  get networkV() {\n    return this.#networkV;\n  }\n  /**\n   *  The chain ID for EIP-155 legacy transactions. For non-legacy\n   *  transactions, this value is ``null``.\n   */\n  get legacyChainId() {\n    const v = this.networkV;\n    if (v == null) {\n      return null;\n    }\n    return Signature.getChainId(v);\n  }\n  /**\n   *  The ``yParity`` for the signature.\n   *\n   *  See ``v`` for more details on how this value is used.\n   */\n  get yParity() {\n    return this.v === 27 ? 0 : 1;\n  }\n  /**\n   *  The [[link-eip-2098]] compact representation of the ``yParity``\n   *  and ``s`` compacted into a single ``bytes32``.\n   */\n  get yParityAndS() {\n    // The EIP-2098 compact representation\n    const yParityAndS = getBytes(this.s);\n    if (this.yParity) {\n      yParityAndS[0] |= 0x80;\n    }\n    return hexlify(yParityAndS);\n  }\n  /**\n   *  The [[link-eip-2098]] compact representation.\n   */\n  get compactSerialized() {\n    return concat([this.r, this.yParityAndS]);\n  }\n  /**\n   *  The serialized representation.\n   */\n  get serialized() {\n    return concat([this.r, this.s, this.yParity ? \"0x1c\" : \"0x1b\"]);\n  }\n  /**\n   *  @private\n   */\n  constructor(guard, r, s, v) {\n    assertPrivate(guard, _guard, \"Signature\");\n    this.#r = r;\n    this.#s = s;\n    this.#v = v;\n    this.#networkV = null;\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return `Signature { r: \"${this.r}\", s: \"${this.s}\", yParity: ${this.yParity}, networkV: ${this.networkV} }`;\n  }\n  /**\n   *  Returns a new identical [[Signature]].\n   */\n  clone() {\n    const clone = new Signature(_guard, this.r, this.s, this.v);\n    if (this.networkV) {\n      clone.#networkV = this.networkV;\n    }\n    return clone;\n  }\n  /**\n   *  Returns a representation that is compatible with ``JSON.stringify``.\n   */\n  toJSON() {\n    const networkV = this.networkV;\n    return {\n      _type: \"signature\",\n      networkV: networkV != null ? networkV.toString() : null,\n      r: this.r,\n      s: this.s,\n      v: this.v\n    };\n  }\n  /**\n   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n   *\n   *  @example:\n   *    Signature.getChainId(45)\n   *    //_result:\n   *\n   *    Signature.getChainId(46)\n   *    //_result:\n   */\n  static getChainId(v) {\n    const bv = getBigInt(v, \"v\");\n    // The v is not an EIP-155 v, so it is the unspecified chain ID\n    if (bv == BN_27 || bv == BN_28) {\n      return BN_0;\n    }\n    // Bad value for an EIP-155 v\n    assertArgument(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n    return (bv - BN_35) / BN_2;\n  }\n  /**\n   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n   *\n   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n   *  property to include the chain ID.\n   *\n   *  @example:\n   *    Signature.getChainIdV(5, 27)\n   *    //_result:\n   *\n   *    Signature.getChainIdV(5, 28)\n   *    //_result:\n   *\n   */\n  static getChainIdV(chainId, v) {\n    return getBigInt(chainId) * BN_2 + BigInt(35 + v - 27);\n  }\n  /**\n   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n   *\n   *  @example:\n   *    // The values 0 and 1 imply v is actually yParity\n   *    Signature.getNormalizedV(0)\n   *    //_result:\n   *\n   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n   *    Signature.getNormalizedV(27)\n   *    //_result:\n   *\n   *    // Legacy EIP-155 transaction (i.e. >= 35)\n   *    Signature.getNormalizedV(46)\n   *    //_result:\n   *\n   *    // Invalid values throw\n   *    Signature.getNormalizedV(5)\n   *    //_error:\n   */\n  static getNormalizedV(v) {\n    const bv = getBigInt(v);\n    if (bv === BN_0 || bv === BN_27) {\n      return 27;\n    }\n    if (bv === BN_1 || bv === BN_28) {\n      return 28;\n    }\n    assertArgument(bv >= BN_35, \"invalid v\", \"v\", v);\n    // Otherwise, EIP-155 v means odd is 27 and even is 28\n    return bv & BN_1 ? 27 : 28;\n  }\n  /**\n   *  Creates a new [[Signature]].\n   *\n   *  If no %%sig%% is provided, a new [[Signature]] is created\n   *  with default values.\n   *\n   *  If %%sig%% is a string, it is parsed.\n   */\n  static from(sig) {\n    function assertError(check, message) {\n      assertArgument(check, message, \"signature\", sig);\n    }\n    ;\n    if (sig == null) {\n      return new Signature(_guard, ZeroHash, ZeroHash, 27);\n    }\n    if (typeof sig === \"string\") {\n      const bytes = getBytes(sig, \"signature\");\n      if (bytes.length === 64) {\n        const r = hexlify(bytes.slice(0, 32));\n        const s = bytes.slice(32, 64);\n        const v = s[0] & 0x80 ? 28 : 27;\n        s[0] &= 0x7f;\n        return new Signature(_guard, r, hexlify(s), v);\n      }\n      if (bytes.length === 65) {\n        const r = hexlify(bytes.slice(0, 32));\n        const s = bytes.slice(32, 64);\n        assertError((s[0] & 0x80) === 0, \"non-canonical s\");\n        const v = Signature.getNormalizedV(bytes[64]);\n        return new Signature(_guard, r, hexlify(s), v);\n      }\n      assertError(false, \"invalid raw signature length\");\n    }\n    if (sig instanceof Signature) {\n      return sig.clone();\n    }\n    // Get r\n    const _r = sig.r;\n    assertError(_r != null, \"missing r\");\n    const r = toUint256(_r);\n    // Get s; by any means necessary (we check consistency below)\n    const s = function (s, yParityAndS) {\n      if (s != null) {\n        return toUint256(s);\n      }\n      if (yParityAndS != null) {\n        assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n        const bytes = getBytes(yParityAndS);\n        bytes[0] &= 0x7f;\n        return hexlify(bytes);\n      }\n      assertError(false, \"missing s\");\n    }(sig.s, sig.yParityAndS);\n    assertError((getBytes(s)[0] & 0x80) == 0, \"non-canonical s\");\n    // Get v; by any means necessary (we check consistency below)\n    const {\n      networkV,\n      v\n    } = function (_v, yParityAndS, yParity) {\n      if (_v != null) {\n        const v = getBigInt(_v);\n        return {\n          networkV: v >= BN_35 ? v : undefined,\n          v: Signature.getNormalizedV(v)\n        };\n      }\n      if (yParityAndS != null) {\n        assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n        return {\n          v: getBytes(yParityAndS)[0] & 0x80 ? 28 : 27\n        };\n      }\n      if (yParity != null) {\n        switch (getNumber(yParity, \"sig.yParity\")) {\n          case 0:\n            return {\n              v: 27\n            };\n          case 1:\n            return {\n              v: 28\n            };\n        }\n        assertError(false, \"invalid yParity\");\n      }\n      assertError(false, \"missing v\");\n    }(sig.v, sig.yParityAndS, sig.yParity);\n    const result = new Signature(_guard, r, s, v);\n    if (networkV) {\n      result.#networkV = networkV;\n    }\n    // If multiple of v, yParity, yParityAndS we given, check they match\n    assertError(sig.yParity == null || getNumber(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n    return result;\n  }\n}","map":{"version":3,"sources":["../../src.ts/crypto/signature.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ZeroHash } from \"../constants/index.js\";\nimport { concat, dataLength, getBigInt, getBytes, getNumber, hexlify, toBeArray, isHexString, zeroPadValue, assertArgument, assertPrivate } from \"../utils/index.js\";\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst _guard = {};\nfunction toUint256(value) {\n    return zeroPadValue(toBeArray(value), 32);\n}\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */\nexport class Signature {\n    #r;\n    #s;\n    #v;\n    #networkV;\n    /**\n     *  The ``r`` value for a signautre.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */\n    get r() { return this.#r; }\n    set r(value) {\n        assertArgument(dataLength(value) === 32, \"invalid r\", \"value\", value);\n        this.#r = hexlify(value);\n    }\n    /**\n     *  The ``s`` value for a signature.\n     */\n    get s() { return this.#s; }\n    set s(_value) {\n        assertArgument(dataLength(_value) === 32, \"invalid s\", \"value\", _value);\n        const value = hexlify(_value);\n        assertArgument(parseInt(value.substring(0, 3)) < 8, \"non-canonical s\", \"value\", value);\n        this.#s = value;\n    }\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */\n    get v() { return this.#v; }\n    set v(value) {\n        const v = getNumber(value, \"value\");\n        assertArgument(v === 27 || v === 28, \"invalid v\", \"v\", value);\n        this.#v = v;\n    }\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get networkV() { return this.#networkV; }\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get legacyChainId() {\n        const v = this.networkV;\n        if (v == null) {\n            return null;\n        }\n        return Signature.getChainId(v);\n    }\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */\n    get yParity() {\n        return (this.v === 27) ? 0 : 1;\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */\n    get yParityAndS() {\n        // The EIP-2098 compact representation\n        const yParityAndS = getBytes(this.s);\n        if (this.yParity) {\n            yParityAndS[0] |= 0x80;\n        }\n        return hexlify(yParityAndS);\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */\n    get compactSerialized() {\n        return concat([this.r, this.yParityAndS]);\n    }\n    /**\n     *  The serialized representation.\n     */\n    get serialized() {\n        return concat([this.r, this.s, (this.yParity ? \"0x1c\" : \"0x1b\")]);\n    }\n    /**\n     *  @private\n     */\n    constructor(guard, r, s, v) {\n        assertPrivate(guard, _guard, \"Signature\");\n        this.#r = r;\n        this.#s = s;\n        this.#v = v;\n        this.#networkV = null;\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return `Signature { r: \"${this.r}\", s: \"${this.s}\", yParity: ${this.yParity}, networkV: ${this.networkV} }`;\n    }\n    /**\n     *  Returns a new identical [[Signature]].\n     */\n    clone() {\n        const clone = new Signature(_guard, this.r, this.s, this.v);\n        if (this.networkV) {\n            clone.#networkV = this.networkV;\n        }\n        return clone;\n    }\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */\n    toJSON() {\n        const networkV = this.networkV;\n        return {\n            _type: \"signature\",\n            networkV: ((networkV != null) ? networkV.toString() : null),\n            r: this.r, s: this.s, v: this.v,\n        };\n    }\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */\n    static getChainId(v) {\n        const bv = getBigInt(v, \"v\");\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\n        if ((bv == BN_27) || (bv == BN_28)) {\n            return BN_0;\n        }\n        // Bad value for an EIP-155 v\n        assertArgument(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n        return (bv - BN_35) / BN_2;\n    }\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */\n    static getChainIdV(chainId, v) {\n        return (getBigInt(chainId) * BN_2) + BigInt(35 + v - 27);\n    }\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */\n    static getNormalizedV(v) {\n        const bv = getBigInt(v);\n        if (bv === BN_0 || bv === BN_27) {\n            return 27;\n        }\n        if (bv === BN_1 || bv === BN_28) {\n            return 28;\n        }\n        assertArgument(bv >= BN_35, \"invalid v\", \"v\", v);\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\n        return (bv & BN_1) ? 27 : 28;\n    }\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */\n    static from(sig) {\n        function assertError(check, message) {\n            assertArgument(check, message, \"signature\", sig);\n        }\n        ;\n        if (sig == null) {\n            return new Signature(_guard, ZeroHash, ZeroHash, 27);\n        }\n        if (typeof (sig) === \"string\") {\n            const bytes = getBytes(sig, \"signature\");\n            if (bytes.length === 64) {\n                const r = hexlify(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                const v = (s[0] & 0x80) ? 28 : 27;\n                s[0] &= 0x7f;\n                return new Signature(_guard, r, hexlify(s), v);\n            }\n            if (bytes.length === 65) {\n                const r = hexlify(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                assertError((s[0] & 0x80) === 0, \"non-canonical s\");\n                const v = Signature.getNormalizedV(bytes[64]);\n                return new Signature(_guard, r, hexlify(s), v);\n            }\n            assertError(false, \"invalid raw signature length\");\n        }\n        if (sig instanceof Signature) {\n            return sig.clone();\n        }\n        // Get r\n        const _r = sig.r;\n        assertError(_r != null, \"missing r\");\n        const r = toUint256(_r);\n        // Get s; by any means necessary (we check consistency below)\n        const s = (function (s, yParityAndS) {\n            if (s != null) {\n                return toUint256(s);\n            }\n            if (yParityAndS != null) {\n                assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n                const bytes = getBytes(yParityAndS);\n                bytes[0] &= 0x7f;\n                return hexlify(bytes);\n            }\n            assertError(false, \"missing s\");\n        })(sig.s, sig.yParityAndS);\n        assertError((getBytes(s)[0] & 0x80) == 0, \"non-canonical s\");\n        // Get v; by any means necessary (we check consistency below)\n        const { networkV, v } = (function (_v, yParityAndS, yParity) {\n            if (_v != null) {\n                const v = getBigInt(_v);\n                return {\n                    networkV: ((v >= BN_35) ? v : undefined),\n                    v: Signature.getNormalizedV(v)\n                };\n            }\n            if (yParityAndS != null) {\n                assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n                return { v: ((getBytes(yParityAndS)[0] & 0x80) ? 28 : 27) };\n            }\n            if (yParity != null) {\n                switch (getNumber(yParity, \"sig.yParity\")) {\n                    case 0: return { v: 27 };\n                    case 1: return { v: 28 };\n                }\n                assertError(false, \"invalid yParity\");\n            }\n            assertError(false, \"missing v\");\n        })(sig.v, sig.yParityAndS, sig.yParity);\n        const result = new Signature(_guard, r, s, v);\n        if (networkV) {\n            result.#networkV = networkV;\n        }\n        // If multiple of v, yParity, yParityAndS we given, check they match\n        assertError(sig.yParity == null || getNumber(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n        return result;\n    }\n}\n//# sourceMappingURL=signature.js.map"]},"metadata":{},"sourceType":"module"}