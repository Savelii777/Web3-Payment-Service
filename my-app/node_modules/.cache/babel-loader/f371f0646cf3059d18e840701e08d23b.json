{"ast":null,"code":"import _defineProperty from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateMethodInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateMethodGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldSet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _classPrivateFieldGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\n/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */\nimport { defineProperties, getBigInt, getNumber, assert, assertPrivate, assertArgument } from \"../utils/index.js\";\nimport { id } from \"../hash/index.js\";\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n  const result = new Set();\n  items.forEach(k => result.add(k));\n  return Object.freeze(result);\n}\nconst _kwVisibDeploy = \"external public payable\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n  \"(\": \"OPEN_PAREN\",\n  \")\": \"CLOSE_PAREN\",\n  \"[\": \"OPEN_BRACKET\",\n  \"]\": \"CLOSE_BRACKET\",\n  \",\": \"COMMA\",\n  \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nvar _offset = /*#__PURE__*/new WeakMap();\nvar _tokens = /*#__PURE__*/new WeakMap();\nvar _subTokenString = /*#__PURE__*/new WeakSet();\nclass TokenString {\n  get offset() {\n    return _classPrivateFieldGet(this, _offset);\n  }\n  get length() {\n    return _classPrivateFieldGet(this, _tokens).length - _classPrivateFieldGet(this, _offset);\n  }\n  constructor(tokens) {\n    _classPrivateMethodInitSpec(this, _subTokenString);\n    _classPrivateFieldInitSpec(this, _offset, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _tokens, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _offset, 0);\n    _classPrivateFieldSet(this, _tokens, tokens.slice());\n  }\n  clone() {\n    return new TokenString(_classPrivateFieldGet(this, _tokens));\n  }\n  reset() {\n    _classPrivateFieldSet(this, _offset, 0);\n  }\n  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n  popKeyword(allowed) {\n    const top = this.peek();\n    if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n      throw new Error(\"expected keyword \".concat(top.text));\n    }\n    return this.pop().text;\n  }\n  // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n  popType(type) {\n    if (this.peek().type !== type) {\n      throw new Error(\"expected \".concat(type, \"; got \").concat(JSON.stringify(this.peek())));\n    }\n    return this.pop().text;\n  }\n  // Pops and returns a \"(\" TOKENS \")\"\n  popParen() {\n    const top = this.peek();\n    if (top.type !== \"OPEN_PAREN\") {\n      throw new Error(\"bad start\");\n    }\n    const result = _classPrivateMethodGet(this, _subTokenString, _subTokenString2).call(this, _classPrivateFieldGet(this, _offset) + 1, top.match + 1);\n    _classPrivateFieldSet(this, _offset, top.match + 1);\n    return result;\n  }\n  // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n  popParams() {\n    const top = this.peek();\n    if (top.type !== \"OPEN_PAREN\") {\n      throw new Error(\"bad start\");\n    }\n    const result = [];\n    while (_classPrivateFieldGet(this, _offset) < top.match - 1) {\n      const link = this.peek().linkNext;\n      result.push(_classPrivateMethodGet(this, _subTokenString, _subTokenString2).call(this, _classPrivateFieldGet(this, _offset) + 1, link));\n      _classPrivateFieldSet(this, _offset, link);\n    }\n    _classPrivateFieldSet(this, _offset, top.match + 1);\n    return result;\n  }\n  // Returns the top Token, throwing if out of tokens\n  peek() {\n    if (_classPrivateFieldGet(this, _offset) >= _classPrivateFieldGet(this, _tokens).length) {\n      throw new Error(\"out-of-bounds\");\n    }\n    return _classPrivateFieldGet(this, _tokens)[_classPrivateFieldGet(this, _offset)];\n  }\n  // Returns the next value, if it is a keyword in `allowed`\n  peekKeyword(allowed) {\n    const top = this.peekType(\"KEYWORD\");\n    return top != null && allowed.has(top) ? top : null;\n  }\n  // Returns the value of the next token if it is `type`\n  peekType(type) {\n    if (this.length === 0) {\n      return null;\n    }\n    const top = this.peek();\n    return top.type === type ? top.text : null;\n  }\n  // Returns the next token; throws if out of tokens\n  pop() {\n    var _this$offset, _this$offset2;\n    const result = this.peek();\n    _classPrivateFieldSet(this, _offset, (_this$offset = _classPrivateFieldGet(this, _offset), _this$offset2 = _this$offset++, _this$offset)), _this$offset2;\n    return result;\n  }\n  toString() {\n    const tokens = [];\n    for (let i = _classPrivateFieldGet(this, _offset); i < _classPrivateFieldGet(this, _tokens).length; i++) {\n      const token = _classPrivateFieldGet(this, _tokens)[i];\n      tokens.push(\"\".concat(token.type, \":\").concat(token.text));\n    }\n    return \"<TokenString \".concat(tokens.join(\" \"), \">\");\n  }\n}\nfunction _subTokenString2() {\n  let from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return new TokenString(_classPrivateFieldGet(this, _tokens).slice(from, to).map(t => {\n    return Object.freeze(Object.assign({}, t, {\n      match: t.match - from,\n      linkBack: t.linkBack - from,\n      linkNext: t.linkNext - from\n    }));\n  }));\n}\nfunction lex(text) {\n  const tokens = [];\n  const throwError = message => {\n    const token = offset < text.length ? JSON.stringify(text[offset]) : \"$EOI\";\n    throw new Error(\"invalid token \".concat(token, \" at \").concat(offset, \": \").concat(message));\n  };\n  let brackets = [];\n  let commas = [];\n  let offset = 0;\n  while (offset < text.length) {\n    // Strip off any leading whitespace\n    let cur = text.substring(offset);\n    let match = cur.match(regexWhitespacePrefix);\n    if (match) {\n      offset += match[1].length;\n      cur = text.substring(offset);\n    }\n    const token = {\n      depth: brackets.length,\n      linkBack: -1,\n      linkNext: -1,\n      match: -1,\n      type: \"\",\n      text: \"\",\n      offset,\n      value: -1\n    };\n    tokens.push(token);\n    let type = SimpleTokens[cur[0]] || \"\";\n    if (type) {\n      token.type = type;\n      token.text = cur[0];\n      offset++;\n      if (type === \"OPEN_PAREN\") {\n        brackets.push(tokens.length - 1);\n        commas.push(tokens.length - 1);\n      } else if (type == \"CLOSE_PAREN\") {\n        if (brackets.length === 0) {\n          throwError(\"no matching open bracket\");\n        }\n        token.match = brackets.pop();\n        tokens[token.match].match = tokens.length - 1;\n        token.depth--;\n        token.linkBack = commas.pop();\n        tokens[token.linkBack].linkNext = tokens.length - 1;\n      } else if (type === \"COMMA\") {\n        token.linkBack = commas.pop();\n        tokens[token.linkBack].linkNext = tokens.length - 1;\n        commas.push(tokens.length - 1);\n      } else if (type === \"OPEN_BRACKET\") {\n        token.type = \"BRACKET\";\n      } else if (type === \"CLOSE_BRACKET\") {\n        // Remove the CLOSE_BRACKET\n        let suffix = tokens.pop().text;\n        if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n          const value = tokens.pop().text;\n          suffix = value + suffix;\n          tokens[tokens.length - 1].value = getNumber(value);\n        }\n        if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n          throw new Error(\"missing opening bracket\");\n        }\n        tokens[tokens.length - 1].text += suffix;\n      }\n      continue;\n    }\n    match = cur.match(regexIdPrefix);\n    if (match) {\n      token.text = match[1];\n      offset += token.text.length;\n      if (Keywords.has(token.text)) {\n        token.type = \"KEYWORD\";\n        continue;\n      }\n      if (token.text.match(regexType)) {\n        token.type = \"TYPE\";\n        continue;\n      }\n      token.type = \"ID\";\n      continue;\n    }\n    match = cur.match(regexNumberPrefix);\n    if (match) {\n      token.text = match[1];\n      token.type = \"NUMBER\";\n      offset += token.text.length;\n      continue;\n    }\n    throw new Error(\"unexpected token \".concat(JSON.stringify(cur[0]), \" at position \").concat(offset));\n  }\n  return new TokenString(tokens.map(t => Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n  let included = [];\n  for (const key in allowed.keys()) {\n    if (set.has(key)) {\n      included.push(key);\n    }\n  }\n  if (included.length > 1) {\n    throw new Error(\"conflicting types: \".concat(included.join(\", \")));\n  }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n  if (tokens.peekKeyword(KwTypes)) {\n    const keyword = tokens.pop().text;\n    if (keyword !== type) {\n      throw new Error(\"expected \".concat(type, \", got \").concat(keyword));\n    }\n  }\n  return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n  const keywords = new Set();\n  while (true) {\n    const keyword = tokens.peekType(\"KEYWORD\");\n    if (keyword == null || allowed && !allowed.has(keyword)) {\n      break;\n    }\n    tokens.pop();\n    if (keywords.has(keyword)) {\n      throw new Error(\"duplicate keywords: \".concat(JSON.stringify(keyword)));\n    }\n    keywords.add(keyword);\n  }\n  return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n  let modifiers = consumeKeywords(tokens, KwVisib);\n  // Detect conflicting modifiers\n  allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n  allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n  // Process mutability states\n  if (modifiers.has(\"view\")) {\n    return \"view\";\n  }\n  if (modifiers.has(\"pure\")) {\n    return \"pure\";\n  }\n  if (modifiers.has(\"payable\")) {\n    return \"payable\";\n  }\n  if (modifiers.has(\"nonpayable\")) {\n    return \"nonpayable\";\n  }\n  // Process legacy `constant` last\n  if (modifiers.has(\"constant\")) {\n    return \"view\";\n  }\n  return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n  return tokens.popParams().map(t => ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n  if (tokens.peekType(\"AT\")) {\n    tokens.pop();\n    if (tokens.peekType(\"NUMBER\")) {\n      return getBigInt(tokens.pop().text);\n    }\n    throw new Error(\"invalid gas\");\n  }\n  return null;\n}\nfunction consumeEoi(tokens) {\n  if (tokens.length) {\n    throw new Error(\"unexpected tokens: \".concat(tokens.toString()));\n  }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n  const match = type.match(regexType);\n  assertArgument(match, \"invalid type\", \"type\", type);\n  if (type === \"uint\") {\n    return \"uint256\";\n  }\n  if (type === \"int\") {\n    return \"int256\";\n  }\n  if (match[2]) {\n    // bytesXX\n    const length = parseInt(match[2]);\n    assertArgument(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n  } else if (match[3]) {\n    // intXX or uintXX\n    const size = parseInt(match[3]);\n    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, \"invalid numeric width\", \"type\", type);\n  }\n  return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */\nvar _walkAsync = /*#__PURE__*/new WeakSet();\nexport class ParamType {\n  /**\n   *  The local name of the parameter (or ``\"\"`` if unbound)\n   */\n\n  /**\n   *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n   *  ``\"uint256[3][]\"``)\n   */\n\n  /**\n   *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\n   */\n\n  /**\n   *  True if the parameters is indexed.\n   *\n   *  For non-indexable types this is ``null``.\n   */\n\n  /**\n   *  The components for the tuple.\n   *\n   *  For non-tuple types this is ``null``.\n   */\n\n  /**\n   *  The array length, or ``-1`` for dynamic-lengthed arrays.\n   *\n   *  For non-array types this is ``null``.\n   */\n\n  /**\n   *  The type of each child in the array.\n   *\n   *  For non-array types this is ``null``.\n   */\n\n  /**\n   *  @private\n   */\n  constructor(guard, name, type, baseType, indexed, _components, arrayLength, arrayChildren) {\n    _classPrivateMethodInitSpec(this, _walkAsync);\n    _defineProperty(this, \"name\", void 0);\n    _defineProperty(this, \"type\", void 0);\n    _defineProperty(this, \"baseType\", void 0);\n    _defineProperty(this, \"indexed\", void 0);\n    _defineProperty(this, \"components\", void 0);\n    _defineProperty(this, \"arrayLength\", void 0);\n    _defineProperty(this, \"arrayChildren\", void 0);\n    assertPrivate(guard, _guard, \"ParamType\");\n    Object.defineProperty(this, internal, {\n      value: ParamTypeInternal\n    });\n    if (_components) {\n      _components = Object.freeze(_components.slice());\n    }\n    if (baseType === \"array\") {\n      if (arrayLength == null || arrayChildren == null) {\n        throw new Error(\"\");\n      }\n    } else if (arrayLength != null || arrayChildren != null) {\n      throw new Error(\"\");\n    }\n    if (baseType === \"tuple\") {\n      if (_components == null) {\n        throw new Error(\"\");\n      }\n    } else if (_components != null) {\n      throw new Error(\"\");\n    }\n    defineProperties(this, {\n      name,\n      type,\n      baseType,\n      indexed,\n      components: _components,\n      arrayLength,\n      arrayChildren\n    });\n  }\n  /**\n   *  Return a string representation of this type.\n   *\n   *  For example,\n   *\n   *  ``sighash\" => \"(uint256,address)\"``\n   *\n   *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n   *\n   *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n   */\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n    if (format === \"json\") {\n      const name = this.name || \"\";\n      if (this.isArray()) {\n        const result = JSON.parse(this.arrayChildren.format(\"json\"));\n        result.name = name;\n        result.type += \"[\".concat(this.arrayLength < 0 ? \"\" : String(this.arrayLength), \"]\");\n        return JSON.stringify(result);\n      }\n      const result = {\n        type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n        name\n      };\n      if (typeof this.indexed === \"boolean\") {\n        result.indexed = this.indexed;\n      }\n      if (this.isTuple()) {\n        result.components = this.components.map(c => JSON.parse(c.format(format)));\n      }\n      return JSON.stringify(result);\n    }\n    let result = \"\";\n    // Array\n    if (this.isArray()) {\n      result += this.arrayChildren.format(format);\n      result += \"[\".concat(this.arrayLength < 0 ? \"\" : String(this.arrayLength), \"]\");\n    } else {\n      if (this.isTuple()) {\n        result += \"(\" + this.components.map(comp => comp.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n      } else {\n        result += this.type;\n      }\n    }\n    if (format !== \"sighash\") {\n      if (this.indexed === true) {\n        result += \" indexed\";\n      }\n      if (format === \"full\" && this.name) {\n        result += \" \" + this.name;\n      }\n    }\n    return result;\n  }\n  /**\n   *  Returns true if %%this%% is an Array type.\n   *\n   *  This provides a type gaurd ensuring that [[arrayChildren]]\n   *  and [[arrayLength]] are non-null.\n   */\n  isArray() {\n    return this.baseType === \"array\";\n  }\n  /**\n   *  Returns true if %%this%% is a Tuple type.\n   *\n   *  This provides a type gaurd ensuring that [[components]]\n   *  is non-null.\n   */\n  isTuple() {\n    return this.baseType === \"tuple\";\n  }\n  /**\n   *  Returns true if %%this%% is an Indexable type.\n   *\n   *  This provides a type gaurd ensuring that [[indexed]]\n   *  is non-null.\n   */\n  isIndexable() {\n    return this.indexed != null;\n  }\n  /**\n   *  Walks the **ParamType** with %%value%%, calling %%process%%\n   *  on each type, destructing the %%value%% recursively.\n   */\n  walk(value, process) {\n    if (this.isArray()) {\n      if (!Array.isArray(value)) {\n        throw new Error(\"invalid array value\");\n      }\n      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n        throw new Error(\"array is wrong length\");\n      }\n      const _this = this;\n      return value.map(v => _this.arrayChildren.walk(v, process));\n    }\n    if (this.isTuple()) {\n      if (!Array.isArray(value)) {\n        throw new Error(\"invalid tuple value\");\n      }\n      if (value.length !== this.components.length) {\n        throw new Error(\"array is wrong length\");\n      }\n      const _this = this;\n      return value.map((v, i) => _this.components[i].walk(v, process));\n    }\n    return process(this.type, value);\n  }\n  /**\n   *  Walks the **ParamType** with %%value%%, asynchronously calling\n   *  %%process%% on each type, destructing the %%value%% recursively.\n   *\n   *  This can be used to resolve ENS naes by walking and resolving each\n   *  ``\"address\"`` type.\n   */\n  async walkAsync(value, process) {\n    const promises = [];\n    const result = [value];\n    _classPrivateMethodGet(this, _walkAsync, _walkAsync2).call(this, promises, value, process, value => {\n      result[0] = value;\n    });\n    if (promises.length) {\n      await Promise.all(promises);\n    }\n    return result[0];\n  }\n  /**\n   *  Creates a new **ParamType** for %%obj%%.\n   *\n   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n   *  otherwise the ``indexed`` keyword will throw an error.\n   */\n  static from(obj, allowIndexed) {\n    if (ParamType.isParamType(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return ParamType.from(lex(obj), allowIndexed);\n      } catch (error) {\n        assertArgument(false, \"invalid param type\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      let type = \"\",\n        baseType = \"\";\n      let comps = null;\n      if (consumeKeywords(obj, setify([\"tuple\"])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n        // Tuple\n        baseType = \"tuple\";\n        comps = obj.popParams().map(t => ParamType.from(t));\n        type = \"tuple(\".concat(comps.map(c => c.format()).join(\",\"), \")\");\n      } else {\n        // Normal\n        type = verifyBasicType(obj.popType(\"TYPE\"));\n        baseType = type;\n      }\n      // Check for Array\n      let arrayChildren = null;\n      let arrayLength = null;\n      while (obj.length && obj.peekType(\"BRACKET\")) {\n        const bracket = obj.pop(); //arrays[i];\n        arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n        arrayLength = bracket.value;\n        type += bracket.text;\n        baseType = \"array\";\n        comps = null;\n      }\n      let indexed = null;\n      const keywords = consumeKeywords(obj, KwModifiers);\n      if (keywords.has(\"indexed\")) {\n        if (!allowIndexed) {\n          throw new Error(\"\");\n        }\n        indexed = true;\n      }\n      const name = obj.peekType(\"ID\") ? obj.pop().text : \"\";\n      if (obj.length) {\n        throw new Error(\"leftover tokens\");\n      }\n      return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n    }\n    const name = obj.name;\n    assertArgument(!name || typeof name === \"string\" && name.match(regexId), \"invalid name\", \"obj.name\", name);\n    let indexed = obj.indexed;\n    if (indexed != null) {\n      assertArgument(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n      indexed = !!indexed;\n    }\n    let type = obj.type;\n    let arrayMatch = type.match(regexArrayType);\n    if (arrayMatch) {\n      const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n      const arrayChildren = ParamType.from({\n        type: arrayMatch[1],\n        components: obj.components\n      });\n      return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n    }\n    if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */) || type.startsWith(\"(\" /* fix: ) */)) {\n      const comps = obj.components != null ? obj.components.map(c => ParamType.from(c)) : null;\n      const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n      // @TODO: use lexer to validate and normalize type\n      return tuple;\n    }\n    type = verifyBasicType(obj.type);\n    return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n  }\n  /**\n   *  Returns true if %%value%% is a **ParamType**.\n   */\n  static isParamType(value) {\n    return value && value[internal] === ParamTypeInternal;\n  }\n}\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */\nfunction _walkAsync2(promises, value, process, setValue) {\n  if (this.isArray()) {\n    if (!Array.isArray(value)) {\n      throw new Error(\"invalid array value\");\n    }\n    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n      throw new Error(\"array is wrong length\");\n    }\n    const childType = this.arrayChildren;\n    const result = value.slice();\n    result.forEach((value, index) => {\n      _classPrivateMethodGet(childType, _walkAsync, _walkAsync2).call(childType, promises, value, process, value => {\n        result[index] = value;\n      });\n    });\n    setValue(result);\n    return;\n  }\n  if (this.isTuple()) {\n    const components = this.components;\n    // Convert the object into an array\n    let result;\n    if (Array.isArray(value)) {\n      result = value.slice();\n    } else {\n      if (value == null || typeof value !== \"object\") {\n        throw new Error(\"invalid tuple value\");\n      }\n      result = components.map(param => {\n        if (!param.name) {\n          throw new Error(\"cannot use object value with unnamed components\");\n        }\n        if (!(param.name in value)) {\n          throw new Error(\"missing value for component \".concat(param.name));\n        }\n        return value[param.name];\n      });\n    }\n    if (result.length !== this.components.length) {\n      throw new Error(\"array is wrong length\");\n    }\n    result.forEach((value, index) => {\n      var _components$index;\n      _classPrivateMethodGet(_components$index = components[index], _walkAsync, _walkAsync2).call(_components$index, promises, value, process, value => {\n        result[index] = value;\n      });\n    });\n    setValue(result);\n    return;\n  }\n  const result = process(this.type, value);\n  if (result.then) {\n    promises.push(async function () {\n      setValue(await result);\n    }());\n  } else {\n    setValue(result);\n  }\n}\nexport class Fragment {\n  /**\n   *  The type of the fragment.\n   */\n\n  /**\n   *  The inputs for the fragment.\n   */\n\n  /**\n   *  @private\n   */\n  constructor(guard, type, inputs) {\n    _defineProperty(this, \"type\", void 0);\n    _defineProperty(this, \"inputs\", void 0);\n    assertPrivate(guard, _guard, \"Fragment\");\n    inputs = Object.freeze(inputs.slice());\n    defineProperties(this, {\n      type,\n      inputs\n    });\n  }\n  /**\n   *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n   *  ABI frgament type.\n   */\n  static from(obj) {\n    if (typeof obj === \"string\") {\n      // Try parsing JSON...\n      try {\n        Fragment.from(JSON.parse(obj));\n      } catch (e) {}\n      // ...otherwise, use the human-readable lexer\n      return Fragment.from(lex(obj));\n    }\n    if (obj instanceof TokenString) {\n      // Human-readable ABI (already lexed)\n      const type = obj.peekKeyword(KwTypes);\n      switch (type) {\n        case \"constructor\":\n          return ConstructorFragment.from(obj);\n        case \"error\":\n          return ErrorFragment.from(obj);\n        case \"event\":\n          return EventFragment.from(obj);\n        case \"fallback\":\n        case \"receive\":\n          return FallbackFragment.from(obj);\n        case \"function\":\n          return FunctionFragment.from(obj);\n        case \"struct\":\n          return StructFragment.from(obj);\n      }\n    } else if (typeof obj === \"object\") {\n      // JSON ABI\n      switch (obj.type) {\n        case \"constructor\":\n          return ConstructorFragment.from(obj);\n        case \"error\":\n          return ErrorFragment.from(obj);\n        case \"event\":\n          return EventFragment.from(obj);\n        case \"fallback\":\n        case \"receive\":\n          return FallbackFragment.from(obj);\n        case \"function\":\n          return FunctionFragment.from(obj);\n        case \"struct\":\n          return StructFragment.from(obj);\n      }\n      assert(false, \"unsupported type: \".concat(obj.type), \"UNSUPPORTED_OPERATION\", {\n        operation: \"Fragment.from\"\n      });\n    }\n    assertArgument(false, \"unsupported frgament object\", \"obj\", obj);\n  }\n  /**\n   *  Returns true if %%value%% is a [[ConstructorFragment]].\n   */\n  static isConstructor(value) {\n    return ConstructorFragment.isFragment(value);\n  }\n  /**\n   *  Returns true if %%value%% is an [[ErrorFragment]].\n   */\n  static isError(value) {\n    return ErrorFragment.isFragment(value);\n  }\n  /**\n   *  Returns true if %%value%% is an [[EventFragment]].\n   */\n  static isEvent(value) {\n    return EventFragment.isFragment(value);\n  }\n  /**\n   *  Returns true if %%value%% is a [[FunctionFragment]].\n   */\n  static isFunction(value) {\n    return FunctionFragment.isFragment(value);\n  }\n  /**\n   *  Returns true if %%value%% is a [[StructFragment]].\n   */\n  static isStruct(value) {\n    return StructFragment.isFragment(value);\n  }\n}\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */\nexport class NamedFragment extends Fragment {\n  /**\n   *  The name of the fragment.\n   */\n\n  /**\n   *  @private\n   */\n  constructor(guard, type, name, inputs) {\n    super(guard, type, inputs);\n    _defineProperty(this, \"name\", void 0);\n    assertArgument(typeof name === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n    inputs = Object.freeze(inputs.slice());\n    defineProperties(this, {\n      name\n    });\n  }\n}\nfunction joinParams(format, params) {\n  return \"(\" + params.map(p => p.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */\nexport class ErrorFragment extends NamedFragment {\n  /**\n   *  @private\n   */\n  constructor(guard, name, inputs) {\n    super(guard, \"error\", name, inputs);\n    Object.defineProperty(this, internal, {\n      value: ErrorFragmentInternal\n    });\n  }\n  /**\n   *  The Custom Error selector.\n   */\n  get selector() {\n    return id(this.format(\"sighash\")).substring(0, 10);\n  }\n  /**\n   *  Returns a string representation of this fragment as %%format%%.\n   */\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"error\",\n        name: this.name,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format)))\n      });\n    }\n    const result = [];\n    if (format !== \"sighash\") {\n      result.push(\"error\");\n    }\n    result.push(this.name + joinParams(format, this.inputs));\n    return result.join(\" \");\n  }\n  /**\n   *  Returns a new **ErrorFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (ErrorFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      return ErrorFragment.from(lex(obj));\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"error\", obj);\n      const inputs = consumeParams(obj);\n      consumeEoi(obj);\n      return new ErrorFragment(_guard, name, inputs);\n    }\n    return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is an\n   *  **ErrorFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === ErrorFragmentInternal;\n  }\n}\n/**\n *  A Fragment which represents an Event.\n */\nexport class EventFragment extends NamedFragment {\n  /**\n   *  Whether this event is anonymous.\n   */\n\n  /**\n   *  @private\n   */\n  constructor(guard, name, inputs, anonymous) {\n    super(guard, \"event\", name, inputs);\n    _defineProperty(this, \"anonymous\", void 0);\n    Object.defineProperty(this, internal, {\n      value: EventFragmentInternal\n    });\n    defineProperties(this, {\n      anonymous\n    });\n  }\n  /**\n   *  The Event topic hash.\n   */\n  get topicHash() {\n    return id(this.format(\"sighash\"));\n  }\n  /**\n   *  Returns a string representation of this event as %%format%%.\n   */\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"event\",\n        anonymous: this.anonymous,\n        name: this.name,\n        inputs: this.inputs.map(i => JSON.parse(i.format(format)))\n      });\n    }\n    const result = [];\n    if (format !== \"sighash\") {\n      result.push(\"event\");\n    }\n    result.push(this.name + joinParams(format, this.inputs));\n    if (format !== \"sighash\" && this.anonymous) {\n      result.push(\"anonymous\");\n    }\n    return result.join(\" \");\n  }\n  /**\n   *  Return the topic hash for an event with %%name%% and %%params%%.\n   */\n  static getTopicHash(name, params) {\n    params = (params || []).map(p => ParamType.from(p));\n    const fragment = new EventFragment(_guard, name, params, false);\n    return fragment.topicHash;\n  }\n  /**\n   *  Returns a new **EventFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (EventFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return EventFragment.from(lex(obj));\n      } catch (error) {\n        assertArgument(false, \"invalid event fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"event\", obj);\n      const inputs = consumeParams(obj, true);\n      const anonymous = !!consumeKeywords(obj, setify([\"anonymous\"])).has(\"anonymous\");\n      consumeEoi(obj);\n      return new EventFragment(_guard, name, inputs, anonymous);\n    }\n    return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(p => ParamType.from(p, true)) : [], !!obj.anonymous);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is an\n   *  **EventFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === EventFragmentInternal;\n  }\n}\n/**\n *  A Fragment which represents a constructor.\n */\nexport class ConstructorFragment extends Fragment {\n  /**\n   *  Whether the constructor can receive an endowment.\n   */\n\n  /**\n   *  The recommended gas limit for deployment or ``null``.\n   */\n\n  /**\n   *  @private\n   */\n  constructor(guard, type, inputs, payable, gas) {\n    super(guard, type, inputs);\n    _defineProperty(this, \"payable\", void 0);\n    _defineProperty(this, \"gas\", void 0);\n    Object.defineProperty(this, internal, {\n      value: ConstructorFragmentInternal\n    });\n    defineProperties(this, {\n      payable,\n      gas\n    });\n  }\n  /**\n   *  Returns a string representation of this constructor as %%format%%.\n   */\n  format(format) {\n    assert(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"format(sighash)\"\n    });\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"constructor\",\n        stateMutability: this.payable ? \"payable\" : \"undefined\",\n        payable: this.payable,\n        gas: this.gas != null ? this.gas : undefined,\n        inputs: this.inputs.map(i => JSON.parse(i.format(format)))\n      });\n    }\n    const result = [\"constructor\".concat(joinParams(format, this.inputs))];\n    if (this.payable) {\n      result.push(\"payable\");\n    }\n    if (this.gas != null) {\n      result.push(\"@\".concat(this.gas.toString()));\n    }\n    return result.join(\" \");\n  }\n  /**\n   *  Returns a new **ConstructorFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (ConstructorFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return ConstructorFragment.from(lex(obj));\n      } catch (error) {\n        assertArgument(false, \"invalid constuctor fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      consumeKeywords(obj, setify([\"constructor\"]));\n      const inputs = consumeParams(obj);\n      const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n      const gas = consumeGas(obj);\n      consumeEoi(obj);\n      return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n    }\n    return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is a\n   *  **ConstructorFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === ConstructorFragmentInternal;\n  }\n}\n/**\n *  A Fragment which represents a method.\n */\nexport class FallbackFragment extends Fragment {\n  /**\n   *  If the function can be sent value during invocation.\n   */\n\n  constructor(guard, inputs, payable) {\n    super(guard, \"fallback\", inputs);\n    _defineProperty(this, \"payable\", void 0);\n    Object.defineProperty(this, internal, {\n      value: FallbackFragmentInternal\n    });\n    defineProperties(this, {\n      payable\n    });\n  }\n  /**\n   *  Returns a string representation of this fallback as %%format%%.\n   */\n  format(format) {\n    const type = this.inputs.length === 0 ? \"receive\" : \"fallback\";\n    if (format === \"json\") {\n      const stateMutability = this.payable ? \"payable\" : \"nonpayable\";\n      return JSON.stringify({\n        type,\n        stateMutability\n      });\n    }\n    return \"\".concat(type, \"()\").concat(this.payable ? \" payable\" : \"\");\n  }\n  /**\n   *  Returns a new **FallbackFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (FallbackFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return FallbackFragment.from(lex(obj));\n      } catch (error) {\n        assertArgument(false, \"invalid fallback fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      const errorObj = obj.toString();\n      const topIsValid = obj.peekKeyword(setify([\"fallback\", \"receive\"]));\n      assertArgument(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n      const type = obj.popKeyword(setify([\"fallback\", \"receive\"]));\n      // receive()\n      if (type === \"receive\") {\n        const inputs = consumeParams(obj);\n        assertArgument(inputs.length === 0, \"receive cannot have arguments\", \"obj.inputs\", inputs);\n        consumeKeywords(obj, setify([\"payable\"]));\n        consumeEoi(obj);\n        return new FallbackFragment(_guard, [], true);\n      }\n      // fallback() [payable]\n      // fallback(bytes) [payable] returns (bytes)\n      let inputs = consumeParams(obj);\n      if (inputs.length) {\n        assertArgument(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map(i => i.format(\"minimal\")).join(\", \"));\n      } else {\n        inputs = [ParamType.from(\"bytes\")];\n      }\n      const mutability = consumeMutability(obj);\n      assertArgument(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n      if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n        const outputs = consumeParams(obj);\n        assertArgument(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map(i => i.format(\"minimal\")).join(\", \"));\n      }\n      consumeEoi(obj);\n      return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n    }\n    if (obj.type === \"receive\") {\n      return new FallbackFragment(_guard, [], true);\n    }\n    if (obj.type === \"fallback\") {\n      const inputs = [ParamType.from(\"bytes\")];\n      const payable = obj.stateMutability === \"payable\";\n      return new FallbackFragment(_guard, inputs, payable);\n    }\n    assertArgument(false, \"invalid fallback description\", \"obj\", obj);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is a\n   *  **FallbackFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === FallbackFragmentInternal;\n  }\n}\n/**\n *  A Fragment which represents a method.\n */\nexport class FunctionFragment extends NamedFragment {\n  /**\n   *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n   */\n\n  /**\n   *  The returned types for the result of calling this function.\n   */\n\n  /**\n   *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\n   *  or ``pure``)\n   */\n\n  /**\n   *  If the function can be sent value during invocation.\n   */\n\n  /**\n   *  The recommended gas limit to send when calling this function.\n   */\n\n  /**\n   *  @private\n   */\n  constructor(guard, name, stateMutability, inputs, outputs, gas) {\n    super(guard, \"function\", name, inputs);\n    _defineProperty(this, \"constant\", void 0);\n    _defineProperty(this, \"outputs\", void 0);\n    _defineProperty(this, \"stateMutability\", void 0);\n    _defineProperty(this, \"payable\", void 0);\n    _defineProperty(this, \"gas\", void 0);\n    Object.defineProperty(this, internal, {\n      value: FunctionFragmentInternal\n    });\n    outputs = Object.freeze(outputs.slice());\n    const constant = stateMutability === \"view\" || stateMutability === \"pure\";\n    const payable = stateMutability === \"payable\";\n    defineProperties(this, {\n      constant,\n      gas,\n      outputs,\n      payable,\n      stateMutability\n    });\n  }\n  /**\n   *  The Function selector.\n   */\n  get selector() {\n    return id(this.format(\"sighash\")).substring(0, 10);\n  }\n  /**\n   *  Returns a string representation of this function as %%format%%.\n   */\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"function\",\n        name: this.name,\n        constant: this.constant,\n        stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n        payable: this.payable,\n        gas: this.gas != null ? this.gas : undefined,\n        inputs: this.inputs.map(i => JSON.parse(i.format(format))),\n        outputs: this.outputs.map(o => JSON.parse(o.format(format)))\n      });\n    }\n    const result = [];\n    if (format !== \"sighash\") {\n      result.push(\"function\");\n    }\n    result.push(this.name + joinParams(format, this.inputs));\n    if (format !== \"sighash\") {\n      if (this.stateMutability !== \"nonpayable\") {\n        result.push(this.stateMutability);\n      }\n      if (this.outputs && this.outputs.length) {\n        result.push(\"returns\");\n        result.push(joinParams(format, this.outputs));\n      }\n      if (this.gas != null) {\n        result.push(\"@\".concat(this.gas.toString()));\n      }\n    }\n    return result.join(\" \");\n  }\n  /**\n   *  Return the selector for a function with %%name%% and %%params%%.\n   */\n  static getSelector(name, params) {\n    params = (params || []).map(p => ParamType.from(p));\n    const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n    return fragment.selector;\n  }\n  /**\n   *  Returns a new **FunctionFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (FunctionFragment.isFragment(obj)) {\n      return obj;\n    }\n    if (typeof obj === \"string\") {\n      try {\n        return FunctionFragment.from(lex(obj));\n      } catch (error) {\n        assertArgument(false, \"invalid function fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"function\", obj);\n      const inputs = consumeParams(obj);\n      const mutability = consumeMutability(obj);\n      let outputs = [];\n      if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n        outputs = consumeParams(obj);\n      }\n      const gas = consumeGas(obj);\n      consumeEoi(obj);\n      return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n    }\n    let stateMutability = obj.stateMutability;\n    // Use legacy Solidity ABI logic if stateMutability is missing\n    if (stateMutability == null) {\n      stateMutability = \"payable\";\n      if (typeof obj.constant === \"boolean\") {\n        stateMutability = \"view\";\n        if (!obj.constant) {\n          stateMutability = \"payable\";\n          if (typeof obj.payable === \"boolean\" && !obj.payable) {\n            stateMutability = \"nonpayable\";\n          }\n        }\n      } else if (typeof obj.payable === \"boolean\" && !obj.payable) {\n        stateMutability = \"nonpayable\";\n      }\n    }\n    // @TODO: verifyState for stateMutability (e.g. throw if\n    //        payable: false but stateMutability is \"nonpayable\")\n    return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is a\n   *  **FunctionFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === FunctionFragmentInternal;\n  }\n}\n/**\n *  A Fragment which represents a structure.\n */\nexport class StructFragment extends NamedFragment {\n  /**\n   *  @private\n   */\n  constructor(guard, name, inputs) {\n    super(guard, \"struct\", name, inputs);\n    Object.defineProperty(this, internal, {\n      value: StructFragmentInternal\n    });\n  }\n  /**\n   *  Returns a string representation of this struct as %%format%%.\n   */\n  format() {\n    throw new Error(\"@TODO\");\n  }\n  /**\n   *  Returns a new **StructFragment** for %%obj%%.\n   */\n  static from(obj) {\n    if (typeof obj === \"string\") {\n      try {\n        return StructFragment.from(lex(obj));\n      } catch (error) {\n        assertArgument(false, \"invalid struct fragment\", \"obj\", obj);\n      }\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"struct\", obj);\n      const inputs = consumeParams(obj);\n      consumeEoi(obj);\n      return new StructFragment(_guard, name, inputs);\n    }\n    return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n  }\n  // @TODO: fix this return type\n  /**\n   *  Returns ``true`` and provides a type guard if %%value%% is a\n   *  **StructFragment**.\n   */\n  static isFragment(value) {\n    return value && value[internal] === StructFragmentInternal;\n  }\n}","map":{"version":3,"sources":["../../src.ts/abi/fragments.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */\nimport { defineProperties, getBigInt, getNumber, assert, assertPrivate, assertArgument } from \"../utils/index.js\";\nimport { id } from \"../hash/index.js\";\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n    const result = new Set();\n    items.forEach((k) => result.add(k));\n    return Object.freeze(result);\n}\nconst _kwVisibDeploy = \"external public payable\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n    \"(\": \"OPEN_PAREN\", \")\": \"CLOSE_PAREN\",\n    \"[\": \"OPEN_BRACKET\", \"]\": \"CLOSE_BRACKET\",\n    \",\": \"COMMA\", \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nclass TokenString {\n    #offset;\n    #tokens;\n    get offset() { return this.#offset; }\n    get length() { return this.#tokens.length - this.#offset; }\n    constructor(tokens) {\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n    clone() { return new TokenString(this.#tokens); }\n    reset() { this.#offset = 0; }\n    #subTokenString(from = 0, to = 0) {\n        return new TokenString(this.#tokens.slice(from, to).map((t) => {\n            return Object.freeze(Object.assign({}, t, {\n                match: (t.match - from),\n                linkBack: (t.linkBack - from),\n                linkNext: (t.linkNext - from),\n            }));\n        }));\n    }\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed) {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n            throw new Error(`expected keyword ${top.text}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type) {\n        if (this.peek().type !== type) {\n            throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = [];\n        while (this.#offset < top.match - 1) {\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Returns the top Token, throwing if out of tokens\n    peek() {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed) {\n        const top = this.peekType(\"KEYWORD\");\n        return (top != null && allowed.has(top)) ? top : null;\n    }\n    // Returns the value of the next token if it is `type`\n    peekType(type) {\n        if (this.length === 0) {\n            return null;\n        }\n        const top = this.peek();\n        return (top.type === type) ? top.text : null;\n    }\n    // Returns the next token; throws if out of tokens\n    pop() {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n    toString() {\n        const tokens = [];\n        for (let i = this.#offset; i < this.#tokens.length; i++) {\n            const token = this.#tokens[i];\n            tokens.push(`${token.type}:${token.text}`);\n        }\n        return `<TokenString ${tokens.join(\" \")}>`;\n    }\n}\nfunction lex(text) {\n    const tokens = [];\n    const throwError = (message) => {\n        const token = (offset < text.length) ? JSON.stringify(text[offset]) : \"$EOI\";\n        throw new Error(`invalid token ${token} at ${offset}: ${message}`);\n    };\n    let brackets = [];\n    let commas = [];\n    let offset = 0;\n    while (offset < text.length) {\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: \"\", text: \"\", offset, value: -1 };\n        tokens.push(token);\n        let type = (SimpleTokens[cur[0]] || \"\");\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n            }\n            else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) {\n                    throwError(\"no matching open bracket\");\n                }\n                token.match = brackets.pop();\n                (tokens[token.match]).match = tokens.length - 1;\n                token.depth--;\n                token.linkBack = commas.pop();\n                (tokens[token.linkBack]).linkNext = tokens.length - 1;\n            }\n            else if (type === \"COMMA\") {\n                token.linkBack = commas.pop();\n                (tokens[token.linkBack]).linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n            }\n            else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n            }\n            else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = tokens.pop().text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = tokens.pop().text;\n                    suffix = value + suffix;\n                    (tokens[tokens.length - 1]).value = getNumber(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                (tokens[tokens.length - 1]).text += suffix;\n            }\n            continue;\n        }\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n            token.type = \"ID\";\n            continue;\n        }\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\n    }\n    return new TokenString(tokens.map((t) => Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n    let included = [];\n    for (const key in allowed.keys()) {\n        if (set.has(key)) {\n            included.push(key);\n        }\n    }\n    if (included.length > 1) {\n        throw new Error(`conflicting types: ${included.join(\", \")}`);\n    }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${type}, got ${keyword}`);\n        }\n    }\n    return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n    const keywords = new Set();\n    while (true) {\n        const keyword = tokens.peekType(\"KEYWORD\");\n        if (keyword == null || (allowed && !allowed.has(keyword))) {\n            break;\n        }\n        tokens.pop();\n        if (keywords.has(keyword)) {\n            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\n        }\n        keywords.add(keyword);\n    }\n    return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n    // Process mutability states\n    if (modifiers.has(\"view\")) {\n        return \"view\";\n    }\n    if (modifiers.has(\"pure\")) {\n        return \"pure\";\n    }\n    if (modifiers.has(\"payable\")) {\n        return \"payable\";\n    }\n    if (modifiers.has(\"nonpayable\")) {\n        return \"nonpayable\";\n    }\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) {\n        return \"view\";\n    }\n    return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return getBigInt(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\nfunction consumeEoi(tokens) {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens: ${tokens.toString()}`);\n    }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n    const match = type.match(regexType);\n    assertArgument(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") {\n        return \"uint256\";\n    }\n    if (type === \"int\") {\n        return \"int256\";\n    }\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        assertArgument(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n    }\n    else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3]);\n        assertArgument(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid numeric width\", \"type\", type);\n    }\n    return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */\nexport class ParamType {\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    name;\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    type;\n    /**\n     *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\n     */\n    baseType;\n    /**\n     *  True if the parameters is indexed.\n     *\n     *  For non-indexable types this is ``null``.\n     */\n    indexed;\n    /**\n     *  The components for the tuple.\n     *\n     *  For non-tuple types this is ``null``.\n     */\n    components;\n    /**\n     *  The array length, or ``-1`` for dynamic-lengthed arrays.\n     *\n     *  For non-array types this is ``null``.\n     */\n    arrayLength;\n    /**\n     *  The type of each child in the array.\n     *\n     *  For non-array types this is ``null``.\n     */\n    arrayChildren;\n    /**\n     *  @private\n     */\n    constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {\n        assertPrivate(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, { value: ParamTypeInternal });\n        if (components) {\n            components = Object.freeze(components.slice());\n        }\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        }\n        else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n        if (baseType === \"tuple\") {\n            if (components == null) {\n                throw new Error(\"\");\n            }\n        }\n        else if (components != null) {\n            throw new Error(\"\");\n        }\n        defineProperties(this, {\n            name, type, baseType, indexed, components, arrayLength, arrayChildren\n        });\n    }\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            const name = this.name || \"\";\n            if (this.isArray()) {\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\n                result.name = name;\n                result.type += `[${(this.arrayLength < 0 ? \"\" : String(this.arrayLength))}]`;\n                return JSON.stringify(result);\n            }\n            const result = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n                name\n            };\n            if (typeof (this.indexed) === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.isTuple()) {\n                result.components = this.components.map((c) => JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${(this.arrayLength < 0 ? \"\" : String(this.arrayLength))}]`;\n        }\n        else {\n            if (this.isTuple()) {\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === \"full\") ? \", \" : \",\") + \")\";\n            }\n            else {\n                result += this.type;\n            }\n        }\n        if (format !== \"sighash\") {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */\n    isArray() {\n        return (this.baseType === \"array\");\n    }\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */\n    isTuple() {\n        return (this.baseType === \"tuple\");\n    }\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */\n    isIndexable() {\n        return (this.indexed != null);\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */\n    walk(value, process) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v) => (_this.arrayChildren.walk(v, process)));\n        }\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid tuple value\");\n            }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i) => (_this.components[i].walk(v, process)));\n        }\n        return process(this.type, value);\n    }\n    #walkAsync(promises, value, process, setValue) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n            const result = value.slice();\n            result.forEach((value, index) => {\n                childType.#walkAsync(promises, value, process, (value) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        if (this.isTuple()) {\n            const components = this.components;\n            // Convert the object into an array\n            let result;\n            if (Array.isArray(value)) {\n                result = value.slice();\n            }\n            else {\n                if (value == null || typeof (value) !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n                result = components.map((param) => {\n                    if (!param.name) {\n                        throw new Error(\"cannot use object value with unnamed components\");\n                    }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${param.name}`);\n                    }\n                    return value[param.name];\n                });\n            }\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            result.forEach((value, index) => {\n                components[index].#walkAsync(promises, value, process, (value) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push((async function () { setValue(await result); })());\n        }\n        else {\n            setValue(result);\n        }\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS naes by walking and resolving each\n     *  ``\"address\"`` type.\n     */\n    async walkAsync(value, process) {\n        const promises = [];\n        const result = [value];\n        this.#walkAsync(promises, value, process, (value) => {\n            result[0] = value;\n        });\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        return result[0];\n    }\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */\n    static from(obj, allowIndexed) {\n        if (ParamType.isParamType(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return ParamType.from(lex(obj), allowIndexed);\n            }\n            catch (error) {\n                assertArgument(false, \"invalid param type\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps = null;\n            if (consumeKeywords(obj, setify([\"tuple\"])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t) => ParamType.from(t));\n                type = `tuple(${comps.map((c) => c.format()).join(\",\")})`;\n            }\n            else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n            // Check for Array\n            let arrayChildren = null;\n            let arrayLength = null;\n            while (obj.length && obj.peekType(\"BRACKET\")) {\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n            let indexed = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) {\n                    throw new Error(\"\");\n                }\n                indexed = true;\n            }\n            const name = (obj.peekType(\"ID\") ? obj.pop().text : \"\");\n            if (obj.length) {\n                throw new Error(\"leftover tokens\");\n            }\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n        const name = obj.name;\n        assertArgument(!name || (typeof (name) === \"string\" && name.match(regexId)), \"invalid name\", \"obj.name\", name);\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            assertArgument(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n        let type = obj.type;\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n        if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */) || type.startsWith(\"(\" /* fix: ) */)) {\n            const comps = (obj.components != null) ? obj.components.map((c) => ParamType.from(c)) : null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n        type = verifyBasicType(obj.type);\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */\n    static isParamType(value) {\n        return (value && value[internal] === ParamTypeInternal);\n    }\n}\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */\nexport class Fragment {\n    /**\n     *  The type of the fragment.\n     */\n    type;\n    /**\n     *  The inputs for the fragment.\n     */\n    inputs;\n    /**\n     *  @private\n     */\n    constructor(guard, type, inputs) {\n        assertPrivate(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        defineProperties(this, { type, inputs });\n    }\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */\n    static from(obj) {\n        if (typeof (obj) === \"string\") {\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            }\n            catch (e) { }\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n            const type = obj.peekKeyword(KwTypes);\n            switch (type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n        }\n        else if (typeof (obj) === \"object\") {\n            // JSON ABI\n            switch (obj.type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n            assert(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n        assertArgument(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */\n    static isConstructor(value) {\n        return ConstructorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */\n    static isError(value) {\n        return ErrorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */\n    static isEvent(value) {\n        return EventFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */\n    static isFunction(value) {\n        return FunctionFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */\n    static isStruct(value) {\n        return StructFragment.isFragment(value);\n    }\n}\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */\nexport class NamedFragment extends Fragment {\n    /**\n     *  The name of the fragment.\n     */\n    name;\n    /**\n     *  @private\n     */\n    constructor(guard, type, name, inputs) {\n        super(guard, type, inputs);\n        assertArgument(typeof (name) === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        defineProperties(this, { name });\n    }\n}\nfunction joinParams(format, params) {\n    return \"(\" + params.map((p) => p.format(format)).join((format === \"full\") ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */\nexport class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs) {\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });\n    }\n    /**\n     *  The Custom Error selector.\n     */\n    get selector() {\n        return id(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"error\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (ErrorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            return ErrorFragment.from(lex(obj));\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new ErrorFragment(_guard, name, inputs);\n        }\n        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === ErrorFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents an Event.\n */\nexport class EventFragment extends NamedFragment {\n    /**\n     *  Whether this event is anonymous.\n     */\n    anonymous;\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs, anonymous) {\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, { value: EventFragmentInternal });\n        defineProperties(this, { anonymous });\n    }\n    /**\n     *  The Event topic hash.\n     */\n    get topicHash() {\n        return id(this.format(\"sighash\"));\n    }\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"event\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) {\n            result.push(\"anonymous\");\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */\n    static getTopicHash(name, params) {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (EventFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return EventFragment.from(lex(obj));\n            }\n            catch (error) {\n                assertArgument(false, \"invalid event fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([\"anonymous\"])).has(\"anonymous\");\n            consumeEoi(obj);\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === EventFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a constructor.\n */\nexport class ConstructorFragment extends Fragment {\n    /**\n     *  Whether the constructor can receive an endowment.\n     */\n    payable;\n    /**\n     *  The recommended gas limit for deployment or ``null``.\n     */\n    gas;\n    /**\n     *  @private\n     */\n    constructor(guard, type, inputs, payable, gas) {\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });\n        defineProperties(this, { payable, gas });\n    }\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */\n    format(format) {\n        assert(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", { operation: \"format(sighash)\" });\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: (this.payable ? \"payable\" : \"undefined\"),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas : undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n        const result = [`constructor${joinParams(format, this.inputs)}`];\n        if (this.payable) {\n            result.push(\"payable\");\n        }\n        if (this.gas != null) {\n            result.push(`@${this.gas.toString()}`);\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (ConstructorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return ConstructorFragment.from(lex(obj));\n            }\n            catch (error) {\n                assertArgument(false, \"invalid constuctor fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([\"constructor\"]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n        return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, (obj.gas != null) ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === ConstructorFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a method.\n */\nexport class FallbackFragment extends Fragment {\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    payable;\n    constructor(guard, inputs, payable) {\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, { value: FallbackFragmentInternal });\n        defineProperties(this, { payable });\n    }\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */\n    format(format) {\n        const type = ((this.inputs.length === 0) ? \"receive\" : \"fallback\");\n        if (format === \"json\") {\n            const stateMutability = (this.payable ? \"payable\" : \"nonpayable\");\n            return JSON.stringify({ type, stateMutability });\n        }\n        return `${type}()${this.payable ? \" payable\" : \"\"}`;\n    }\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (FallbackFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return FallbackFragment.from(lex(obj));\n            }\n            catch (error) {\n                assertArgument(false, \"invalid fallback fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n            const topIsValid = obj.peekKeyword(setify([\"fallback\", \"receive\"]));\n            assertArgument(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n            const type = obj.popKeyword(setify([\"fallback\", \"receive\"]));\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                assertArgument(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([\"payable\"]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [], true);\n            }\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                assertArgument(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            }\n            else {\n                inputs = [ParamType.from(\"bytes\")];\n            }\n            const mutability = consumeMutability(obj);\n            assertArgument(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n            if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                assertArgument(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            }\n            consumeEoi(obj);\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [], true);\n        }\n        if (obj.type === \"fallback\") {\n            const inputs = [ParamType.from(\"bytes\")];\n            const payable = (obj.stateMutability === \"payable\");\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n        assertArgument(false, \"invalid fallback description\", \"obj\", obj);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === FallbackFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a method.\n */\nexport class FunctionFragment extends NamedFragment {\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    constant;\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    outputs;\n    /**\n     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\n     *  or ``pure``)\n     */\n    stateMutability;\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    payable;\n    /**\n     *  The recommended gas limit to send when calling this function.\n     */\n    gas;\n    /**\n     *  @private\n     */\n    constructor(guard, name, stateMutability, inputs, outputs, gas) {\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, { value: FunctionFragmentInternal });\n        outputs = Object.freeze(outputs.slice());\n        const constant = (stateMutability === \"view\" || stateMutability === \"pure\");\n        const payable = (stateMutability === \"payable\");\n        defineProperties(this, { constant, gas, outputs, payable, stateMutability });\n    }\n    /**\n     *  The Function selector.\n     */\n    get selector() {\n        return id(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas : undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"function\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n            if (this.gas != null) {\n                result.push(`@${this.gas.toString()}`);\n            }\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */\n    static getSelector(name, params) {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n        return fragment.selector;\n    }\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (FunctionFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return FunctionFragment.from(lex(obj));\n            }\n            catch (error) {\n                assertArgument(false, \"invalid function fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n            let outputs = [];\n            if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n        let stateMutability = obj.stateMutability;\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n            if (typeof (obj.constant) === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\";\n                    if (typeof (obj.payable) === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            }\n            else if (typeof (obj.payable) === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], (obj.gas != null) ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === FunctionFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a structure.\n */\nexport class StructFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs) {\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, { value: StructFragmentInternal });\n    }\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */\n    format() {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (typeof (obj) === \"string\") {\n            try {\n                return StructFragment.from(lex(obj));\n            }\n            catch (error) {\n                assertArgument(false, \"invalid struct fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    // @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === StructFragmentInternal);\n    }\n}\n//# sourceMappingURL=fragments.js.map"]},"metadata":{},"sourceType":"module"}