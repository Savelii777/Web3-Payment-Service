{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateMethodGet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldSet from \"/home/savelii/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Web3-Login/my-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport { isError } from \"../utils/index.js\";\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _provider = /*#__PURE__*/new WeakMap();\nvar _filterIdPromise = /*#__PURE__*/new WeakMap();\nvar _poller = /*#__PURE__*/new WeakMap();\nvar _running = /*#__PURE__*/new WeakMap();\nvar _network = /*#__PURE__*/new WeakMap();\nvar _hault = /*#__PURE__*/new WeakMap();\nvar _poll = /*#__PURE__*/new WeakSet();\nvar _teardown = /*#__PURE__*/new WeakSet();\nexport class FilterIdSubscriber {\n  /**\n   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n   *  and [[_emitResults]] to setup the subscription and provide the event\n   *  to the %%provider%%.\n   */\n  constructor(provider) {\n    _classPrivateMethodInitSpec(this, _teardown);\n    _classPrivateMethodInitSpec(this, _poll);\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _filterIdPromise, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _poller, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _running, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _network, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _hault, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _provider, provider);\n    _classPrivateFieldSet(this, _filterIdPromise, null);\n    _classPrivateFieldSet(this, _poller, _classPrivateMethodGet(this, _poll, _poll2).bind(this));\n    _classPrivateFieldSet(this, _running, false);\n    _classPrivateFieldSet(this, _network, null);\n    _classPrivateFieldSet(this, _hault, false);\n  }\n  /**\n   *  Sub-classes **must** override this to begin the subscription.\n   */\n  _subscribe(provider) {\n    throw new Error(\"subclasses must override this\");\n  }\n  /**\n   *  Sub-classes **must** override this handle the events.\n   */\n  _emitResults(provider, result) {\n    throw new Error(\"subclasses must override this\");\n  }\n  /**\n   *  Sub-classes **must** override this handle recovery on errors.\n   */\n  _recover(provider) {\n    throw new Error(\"subclasses must override this\");\n  }\n  start() {\n    if (_classPrivateFieldGet(this, _running)) {\n      return;\n    }\n    _classPrivateFieldSet(this, _running, true);\n    _classPrivateMethodGet(this, _poll, _poll2).call(this, -2);\n  }\n  stop() {\n    if (!_classPrivateFieldGet(this, _running)) {\n      return;\n    }\n    _classPrivateFieldSet(this, _running, false);\n    _classPrivateFieldSet(this, _hault, true);\n    _classPrivateMethodGet(this, _teardown, _teardown2).call(this);\n    _classPrivateFieldGet(this, _provider).off(\"block\", _classPrivateFieldGet(this, _poller));\n  }\n  pause(dropWhilePaused) {\n    if (dropWhilePaused) {\n      _classPrivateMethodGet(this, _teardown, _teardown2).call(this);\n    }\n    _classPrivateFieldGet(this, _provider).off(\"block\", _classPrivateFieldGet(this, _poller));\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nasync function _poll2(blockNumber) {\n  try {\n    // Subscribe if necessary\n    if (_classPrivateFieldGet(this, _filterIdPromise) == null) {\n      _classPrivateFieldSet(this, _filterIdPromise, this._subscribe(_classPrivateFieldGet(this, _provider)));\n    }\n    // Get the Filter ID\n    let filterId = null;\n    try {\n      filterId = await _classPrivateFieldGet(this, _filterIdPromise);\n    } catch (error) {\n      if (!isError(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n        throw error;\n      }\n    }\n    // The backend does not support Filter ID; downgrade to\n    // polling\n    if (filterId == null) {\n      _classPrivateFieldSet(this, _filterIdPromise, null);\n      _classPrivateFieldGet(this, _provider)._recoverSubscriber(this, this._recover(_classPrivateFieldGet(this, _provider)));\n      return;\n    }\n    const network = await _classPrivateFieldGet(this, _provider).getNetwork();\n    if (!_classPrivateFieldGet(this, _network)) {\n      _classPrivateFieldSet(this, _network, network);\n    }\n    if (_classPrivateFieldGet(this, _network).chainId !== network.chainId) {\n      throw new Error(\"chaid changed\");\n    }\n    if (_classPrivateFieldGet(this, _hault)) {\n      return;\n    }\n    const result = await _classPrivateFieldGet(this, _provider).send(\"eth_getFilterChanges\", [filterId]);\n    await this._emitResults(_classPrivateFieldGet(this, _provider), result);\n  } catch (error) {\n    console.log(\"@TODO\", error);\n  }\n  _classPrivateFieldGet(this, _provider).once(\"block\", _classPrivateFieldGet(this, _poller));\n}\nfunction _teardown2() {\n  const filterIdPromise = _classPrivateFieldGet(this, _filterIdPromise);\n  if (filterIdPromise) {\n    _classPrivateFieldSet(this, _filterIdPromise, null);\n    filterIdPromise.then(filterId => {\n      _classPrivateFieldGet(this, _provider).send(\"eth_uninstallFilter\", [filterId]);\n    });\n  }\n}\nvar _event = /*#__PURE__*/new WeakMap();\nexport class FilterIdEventSubscriber extends FilterIdSubscriber {\n  /**\n   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n   *  listening for %%filter%%.\n   */\n  constructor(provider, filter) {\n    super(provider);\n    _classPrivateFieldInitSpec(this, _event, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _event, copy(filter));\n  }\n  _recover(provider) {\n    return new PollingEventSubscriber(provider, _classPrivateFieldGet(this, _event));\n  }\n  async _subscribe(provider) {\n    const filterId = await provider.send(\"eth_newFilter\", [_classPrivateFieldGet(this, _event)]);\n    return filterId;\n  }\n  async _emitResults(provider, results) {\n    for (const result of results) {\n      provider.emit(_classPrivateFieldGet(this, _event), provider._wrapLog(result, provider._network));\n    }\n  }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdPendingSubscriber extends FilterIdSubscriber {\n  async _subscribe(provider) {\n    return await provider.send(\"eth_newPendingTransactionFilter\", []);\n  }\n  async _emitResults(provider, results) {\n    for (const result of results) {\n      provider.emit(\"pending\", result);\n    }\n  }\n}","map":{"version":3,"sources":["../../src.ts/providers/subscriber-filterid.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isError } from \"../utils/index.js\";\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdSubscriber {\n    #provider;\n    #filterIdPromise;\n    #poller;\n    #running;\n    #network;\n    #hault;\n    /**\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n     *  and [[_emitResults]] to setup the subscription and provide the event\n     *  to the %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#filterIdPromise = null;\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#network = null;\n        this.#hault = false;\n    }\n    /**\n     *  Sub-classes **must** override this to begin the subscription.\n     */\n    _subscribe(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle the events.\n     */\n    _emitResults(provider, result) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle recovery on errors.\n     */\n    _recover(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    async #poll(blockNumber) {\n        try {\n            // Subscribe if necessary\n            if (this.#filterIdPromise == null) {\n                this.#filterIdPromise = this._subscribe(this.#provider);\n            }\n            // Get the Filter ID\n            let filterId = null;\n            try {\n                filterId = await this.#filterIdPromise;\n            }\n            catch (error) {\n                if (!isError(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n                    throw error;\n                }\n            }\n            // The backend does not support Filter ID; downgrade to\n            // polling\n            if (filterId == null) {\n                this.#filterIdPromise = null;\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n                return;\n            }\n            const network = await this.#provider.getNetwork();\n            if (!this.#network) {\n                this.#network = network;\n            }\n            if (this.#network.chainId !== network.chainId) {\n                throw new Error(\"chaid changed\");\n            }\n            if (this.#hault) {\n                return;\n            }\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [filterId]);\n            await this._emitResults(this.#provider, result);\n        }\n        catch (error) {\n            console.log(\"@TODO\", error);\n        }\n        this.#provider.once(\"block\", this.#poller);\n    }\n    #teardown() {\n        const filterIdPromise = this.#filterIdPromise;\n        if (filterIdPromise) {\n            this.#filterIdPromise = null;\n            filterIdPromise.then((filterId) => {\n                this.#provider.send(\"eth_uninstallFilter\", [filterId]);\n            });\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#hault = true;\n        this.#teardown();\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#teardown();\n        }\n        this.#provider.off(\"block\", this.#poller);\n    }\n    resume() { this.start(); }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event;\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */\n    constructor(provider, filter) {\n        super(provider);\n        this.#event = copy(filter);\n    }\n    _recover(provider) {\n        return new PollingEventSubscriber(provider, this.#event);\n    }\n    async _subscribe(provider) {\n        const filterId = await provider.send(\"eth_newFilter\", [this.#event]);\n        return filterId;\n    }\n    async _emitResults(provider, results) {\n        for (const result of results) {\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\n        }\n    }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider) {\n        return await provider.send(\"eth_newPendingTransactionFilter\", []);\n    }\n    async _emitResults(provider, results) {\n        for (const result of results) {\n            provider.emit(\"pending\", result);\n        }\n    }\n}\n//# sourceMappingURL=subscriber-filterid.js.map"]},"metadata":{},"sourceType":"module"}