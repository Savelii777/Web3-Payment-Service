{"ast":null,"code":"import { keccak256 } from \"../crypto/index.js\";\nimport { getBytes, assertArgument } from \"../utils/index.js\";\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n  //    if (!isHexString(address, 20)) {\n  //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n  //    }\n  address = address.toLowerCase();\n  const chars = address.substring(2).split(\"\");\n  const expanded = new Uint8Array(40);\n  for (let i = 0; i < 40; i++) {\n    expanded[i] = chars[i].charCodeAt(0);\n  }\n  const hashed = getBytes(keccak256(expanded));\n  for (let i = 0; i < 40; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 0x0f) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n  return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n  ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n  address = address.toUpperCase();\n  address = address.substring(4) + address.substring(0, 2) + \"00\";\n  let expanded = address.split(\"\").map(c => {\n    return ibanLookup[c];\n  }).join(\"\");\n  // Javascript can handle integers safely up to 15 (decimal) digits\n  while (expanded.length >= safeDigits) {\n    let block = expanded.substring(0, safeDigits);\n    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n  }\n  let checksum = String(98 - parseInt(expanded, 10) % 97);\n  while (checksum.length < 2) {\n    checksum = \"0\" + checksum;\n  }\n  return checksum;\n}\n;\nconst Base36 = function () {\n  ;\n  const result = {};\n  for (let i = 0; i < 36; i++) {\n    const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n    result[key] = BigInt(i);\n  }\n  return result;\n}();\nfunction fromBase36(value) {\n  value = value.toLowerCase();\n  let result = BN_0;\n  for (let i = 0; i < value.length; i++) {\n    result = result * BN_36 + Base36[value[i]];\n  }\n  return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */\nexport function getAddress(address) {\n  assertArgument(typeof address === \"string\", \"invalid address\", \"address\", address);\n  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n    // Missing the 0x prefix\n    if (!address.startsWith(\"0x\")) {\n      address = \"0x\" + address;\n    }\n    const result = getChecksumAddress(address);\n    // It is a checksummed address with a bad checksum\n    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n    return result;\n  }\n  // Maybe ICAP? (we only support direct mode)\n  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n    // It is an ICAP address with a bad checksum\n    assertArgument(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n    let result = fromBase36(address.substring(4)).toString(16);\n    while (result.length < 40) {\n      result = \"0\" + result;\n    }\n    return getChecksumAddress(\"0x\" + result);\n  }\n  assertArgument(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */\nexport function getIcapAddress(address) {\n  //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n  let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n  while (base36.length < 30) {\n    base36 = \"0\" + base36;\n  }\n  return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}","map":{"version":3,"sources":["../../src.ts/address/address.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { keccak256 } from \"../crypto/index.js\";\nimport { getBytes, assertArgument } from \"../utils/index.js\";\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = getBytes(keccak256(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = (function () {\n    ;\n    const result = {};\n    for (let i = 0; i < 36; i++) {\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n})();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */\nexport function getAddress(address) {\n    assertArgument(typeof (address) === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        assertArgument(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    assertArgument(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */\nexport function getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n//# sourceMappingURL=address.js.map"]},"metadata":{},"sourceType":"module"}